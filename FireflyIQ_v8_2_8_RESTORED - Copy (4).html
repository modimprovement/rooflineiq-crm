<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§­ FireflyiQ Lights - PRO Roofline Measurer ğŸ“</title>
    
    <style>
        :root {
            --primary-orange: #ff6a00;
            --accent-gold: #ffd700;
            --dark-bg: #1a1a1a;
            --card-bg: rgba(255, 255, 255, 0.95);
            --text-light: #ffffff;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-light);
        }
        
        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--accent-gold);
            position: relative;
        }
        
        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .logo img {
            height: 60px;
            width: auto;
            margin-right: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow);
        }
        
        .brand-text {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin: 10px 0;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        /* FireflyiQ Integration Badge */
        .firefly-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 215, 0, 0.2);
            padding: 10px 15px;
            border-radius: 20px;
            border: 2px solid var(--accent-gold);
            display: flex;
            align-items: center;
        }
        
        .firefly-badge img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
        }
        
        .firefly-badge span {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        /* BADASS SLIDER STYLING ğŸš€ */
        .light-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            border-radius: 10px;
            background: linear-gradient(to right, #87CEEB, #98FB98, #FFD700, #FF6B6B, #4ECDC4);
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
            cursor: pointer;
        }
        
        .light-slider:hover {
            opacity: 1;
        }
        
        .light-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #ffd700;
            border: 3px solid #333;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .light-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .light-slider::-moz-range-thumb {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #ffd700;
            border: 3px solid #333;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* Section Styling */
        .section {
            margin: 20px;
            background: var(--card-bg);
            border-radius: 15px;
            box-shadow: var(--shadow);
            overflow: hidden;
            color: #333;
        }
        
        .section-header {
            background: linear-gradient(135deg, var(--primary-orange), #ff8533);
            color: white;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 1.1rem;
            transition: background 0.3s ease;
        }
        
        .section-header:hover {
            background: linear-gradient(135deg, #ff5500, var(--primary-orange));
        }
        
        .section-header.active {
            background: linear-gradient(135deg, #ff4400, #ff6600);
        }
        
        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .section-content {
            padding: 20px;
            display: block;
        }
        
        /* Input Controls */
        .input-field {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin: 5px 0;
            transition: border-color 0.3s ease;
        }
        
        .input-field:focus {
            border-color: var(--primary-orange);
            outline: none;
            box-shadow: 0 0 10px rgba(255, 106, 0, 0.3);
        }
        
        /* Button Styling */
        .btn {
            background: linear-gradient(135deg, var(--primary-orange), #ff8533);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        .btn:hover {
            background: linear-gradient(135deg, #ff5500, var(--primary-orange));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 106, 0, 0.4);
        }
        
        .btn.secondary {
            background: linear-gradient(135deg, #666, #888);
        }
        
        .btn.secondary:hover {
            background: linear-gradient(135deg, #555, #777);
        }
        
        /* Map and Canvas Styling */
        .map-container, .streetview-container {
            position: relative;
            margin: 15px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: var(--shadow);
        }
        
        #map, #streetView {
            width: 100%;
            height: 800px;
            border: none;
        }
        
        #streetContainer {
            height: 800px !important;
            min-height: 800px !important;
        }
        
        /* Responsive height adjustments */
        @media (max-width: 1200px) {
            #map, #streetView {
                height: 700px;
            }
            #streetContainer {
                height: 700px !important;
                min-height: 700px !important;
            }
        }
        
        @media (max-width: 768px) {
            #map, #streetView {
                height: 600px;
            }
            #streetContainer {
                height: 600px !important;
                min-height: 600px !important;
            }
        }
        
        @media (max-width: 480px) {
            #map, #streetView {
                height: 500px;
            }
            #streetContainer {
                height: 500px !important;
                min-height: 500px !important;
            }
        }
        
        /* Night mode styles */
        .night-mode {
            filter: brightness(0.6) contrast(1.1);
            transition: filter 0.3s ease;
        }
        
        .night-mode img,
        .night-mode canvas {
            filter: brightness(0.6) contrast(1.1);
        }
        
        .night-mode .google-map {
            filter: brightness(0.6) contrast(1.1);
        }
        
        /* Enhanced night mode for Google Maps */
        .night-mode #map,
        .night-mode #streetView {
            filter: brightness(0.6) contrast(1.1) saturate(0.9);
        }
        
        /* Night mode glow effect */
        .night-mode::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(74, 144, 226, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1;
        }
        
        /* Night mode button active state */
        .btn.active {
            background: linear-gradient(135deg, #4a90e2, #357abd) !important;
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.6) !important;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            cursor: crosshair;
        }
        
        /* Light Transition Slider */
        .transition-canvas-container {
            position: relative;
            z-index: 1;
            max-height: 300px;
            overflow: hidden;
        }
        
        #lightTransitionCanvas {
            position: relative !important;
            z-index: 1 !important;
            max-height: 300px !important;
            overflow: hidden !important;
        }
        
        /* Prevent unwanted movement during drawing */
        .drawing-active {
            overflow: hidden !important;
            position: relative !important;
        }
        
        .drawing-active canvas {
            position: relative !important;
            transform: none !important;
        }
        
        /* Control Panels */
        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .drawing-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        .drawing-mode-selector {
            display: flex;
            background: #f0f0f0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .drawing-mode-selector button {
            background: transparent;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .drawing-mode-selector button.active {
            background: var(--primary-orange);
            color: white;
        }
        
        /* Special styling for mixed mode button */
        .drawing-mode-selector button#mixedMode.active {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: white;
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.6);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Zoom Controls */
        .zoom-control-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        /* Measurements Display */
        .measurements-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .measurement-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .measurement-card h3 {
            color: var(--primary-orange);
            margin-bottom: 10px;
        }
        
        .measurement-value {
            font-size: 2rem;
            font-weight: bold;
            color: #333;
        }
        
        .measurement-unit {
            font-size: 1rem;
            color: #666;
        }
        
        /* Multi-Color Light System */
        .color-scheme-section {
            margin: 15px 0;
        }
        
        .color-preview {
            margin: 15px 0;
            text-align: center;
        }
        
        .color-gradient {
            height: 30px;
            border-radius: 15px;
            margin: 10px 0;
            border: 2px solid white;
            box-shadow: 0 4px 15px rgba(255,255,255,0.3);
        }
        
        .custom-color-palette {
            display: none;
            margin: 15px 0;
        }
        
        .custom-colors-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .custom-color-input {
            width: 100%;
            height: 40px;
            border: 2px solid white;
            border-radius: 8px;
            cursor: pointer;
        }
        
        /* Animation Controls */
        .animation-controls {
            margin: 15px 0;
        }
        
        .speed-control {
            margin: 15px 0;
        }
        
        .speed-slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .speed-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.8);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 15px 10px;
            }
            
            .firefly-badge {
                position: relative;
                top: auto;
                right: auto;
                margin: 10px auto;
                display: inline-flex;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .brand-text {
                font-size: 1.5rem;
            }
            
            .section {
                margin: 10px;
            }
            
            .drawing-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .measurements-display {
                grid-template-columns: 1fr;
            }
        }
        
        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Status Messages */
        .status-message {
            padding: 10px 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .status-success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            color: #2E7D32;
        }
        
        .status-warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #FFC107;
            color: #F57C00;
        }
        
        .status-error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #F44336;
            color: #C62828;
        }
        
        /* View Toggle Button Styles */
        .view-toggle {
            transition: all 0.3s ease;
            border: 2px solid transparent;
            font-weight: bold;
            min-width: 120px;
        }
        
        .view-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .view-toggle.active {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            transform: scale(1.05);
        }
        
        .view-toggle:not(.active) {
            opacity: 0.7;
        }
        
        .view-toggle:not(.active):hover {
            opacity: 1;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="logo-container">
            <div class="logo">
                <img src="rooflineiq logo.png" alt="RooflineIQ Logo">
            </div>
            <div class="brand-text">RooflineIQ</div>
        </div>
        
                        <h1>ğŸ§­ PRO ROOFLINE MEASURER ğŸ“</h1>
        <p>AI-Powered Multi-Color Light Design & Measurement System</p>
        
        <!-- FireflyiQ Integration Badge -->
        <div class="firefly-badge">
            <img src="fireflyiq_logo_300.png" alt="FireflyiQ" />
            <span>Powered by FireflyiQ</span>
        </div>
    </div>



    <!-- Step 1: Property Setup & Aerial View Measurements -->
    <div class="section" id="step2Section">
        <div class="section-header" onclick="toggleSection('step2Section')">
            <span>ğŸ›°ï¸ Step 1: Property Setup & Aerial View Measurements</span>
            <span class="toggle-icon">â–¼</span>
        </div>
        <div class="section-content">


            <!-- Property Address Input -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(76, 175, 80, 0.1); border-radius: 8px; border: 1px solid #4CAF50;">
                <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ¡ Property Address:</label>
                <div style="position: relative;">
                    <input type="text" id="addressInput" class="input-field" placeholder="Enter property address..." style="margin-bottom: 10px;">
                    <div id="addressSuggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #007bff; border-radius: 8px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0,0,0,0.15); margin-top: 5px;"></div>
                </div>
                <button class="btn" onclick="loadProperty()">ğŸš€ Load Property</button>
                <div id="propertyStatus" class="status-message" style="display: none; margin-top: 10px;"></div>
            </div>
            
            <!-- Zoom Control Panel -->
            <div class="zoom-control-panel">
                <label style="font-weight: bold;">ğŸ” Zoom Level:</label>
                <select id="zoomLevel" class="input-field" style="width: auto; margin-right: 10px;">
                    <option value="18">18 - Wide Area</option>
                    <option value="19">19 - Neighborhood</option>
                    <option value="20">20 - Property Focus</option>
                    <option value="21" selected>21 - Maximum Detail</option>
                </select>
                <button class="btn" id="applyZoom" onclick="applyZoomLevel()">Apply Zoom</button>
                                    <!-- Top-Down View button removed - not needed -->
                <div id="zoomStatus" style="margin-left: 10px; font-size: 0.9rem;"></div>
            </div>
            
            <!-- Map Container -->
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; border: 1px solid #4CAF50; font-size: 0.9rem; color: #2E7D32;">
                ğŸ’¡ <strong>Enhanced View:</strong> Increased to 800px height for better visibility and easier measurements
            </div>


            
            <div id="aerialContainer" class="map-container">
            <div id="map"></div>
            <canvas id="aerialCanvas"></canvas>
            
            <!-- Mixed Mode Status Indicator -->
            <div id="mixedModeIndicator" style="display: none; position: absolute; bottom: 10px; left: 10px; background: rgba(74, 144, 226, 0.9); color: white; padding: 8px 12px; border-radius: 20px; font-size: 0.8rem; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
                <span id="mixedModeIndicatorText">ğŸ“ Straight Line Mode</span>
            </div>
        </div>
            
            <!-- Aerial Measurements Display -->
            <div class="measurements-display">
                <div class="measurement-card">
                    <h3>ğŸ  Front</h3>
                    <div class="measurement-value" id="aerialFront">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¬…ï¸ Left Side</h3>
                    <div class="measurement-value" id="aerialLeftSide">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¡ï¸ Right Side</h3>
                    <div class="measurement-value" id="aerialRightSide">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¬…ï¸ Back</h3>
                    <div class="measurement-value" id="aerialBack">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ“ Total</h3>
                    <div class="measurement-value" id="aerialTotal">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
            </div>
            
            <!-- Side Selection Controls -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 193, 7, 0.1); border-radius: 8px; border: 1px solid #FFC107;">
                <label style="font-weight: bold; display: block; margin-bottom: 10px;">ğŸ  Select House Side:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button id="sideFront" class="btn side-btn active" onclick="selectHouseSide('front')" style="background: #4CAF50;">ğŸ  Front</button>
                    <button id="sideLeft" class="btn side-btn" onclick="selectHouseSide('left')" style="background: #2196F3;">â¬…ï¸ Left Side</button>
                    <button id="sideRight" class="btn side-btn" onclick="selectHouseSide('right')" style="background: #FF9800;">â¡ï¸ Right Side</button>
                    <button id="sideBack" class="btn side-btn" onclick="selectHouseSide('back')" style="background: #9C27B0;">ğŸ  Back</button>
                </div>
                <p style="font-size: 0.85rem; color: #666; margin-top: 8px; margin-bottom: 0;">
                    <strong>Current Side:</strong> <span id="currentSideLabel">Front</span> - All measurements will be labeled for this side
                </p>
            </div>
            
            <!-- Drawing Mode Controls -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(74, 144, 226, 0.1); border-radius: 8px; border: 1px solid #4A90E2;">
                <label style="font-weight: bold;">âœï¸ Drawing Mode:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                    <button id="straightMode" class="btn active" onclick="setDrawingMode('straight')">ğŸ“ Straight Lines</button>
                    <button id="freehandMode" class="btn" onclick="setDrawingMode('freehand')">âœ‹ Freehand</button>
                    <button onclick="clearAllDrawings()" style="background: #f44336;">ğŸ—‘ï¸ Clear All</button>
                </div>
                <div style="font-size: 0.85rem; color: #666;">
                    <span id="straightModeHelp" style="display: block;">ğŸ“ <strong>Straight Lines:</strong> Click to place points, right-click or double-click to complete path</span>
                    <span id="freehandModeHelp" style="display: none;">âœ‹ <strong>Freehand:</strong> Click and drag to draw continuous lines</span>
                </div>
            </div>
            
            <!-- Aerial Light Controls -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(156, 39, 176, 0.1); border-radius: 8px; border: 1px solid #9C27B0;">
                <label style="font-weight: bold; display: block; margin-bottom: 10px;">ğŸ¬ Aerial Light Controls:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <button id="aerialAnimationToggle" class="btn" onclick="toggleAerialAnimation()" style="background: #9C27B0; color: white; font-size: 0.9rem;">
                        â–¶ï¸ Start Animation
                    </button>
                    <select id="aerialAnimationMode" class="input-field" style="width: 140px; font-size: 0.9rem;">
                        <option value="static">ğŸ”„ Static</option>
                        <option value="twinkle">âœ¨ Twinkle</option>
                        <option value="chase">ğŸƒ Chase</option>
                        <option value="fade">ğŸŒŠ Fade</option>
                        <option value="rainbow">ğŸŒˆ Rainbow</option>
                        <option value="christmas">ğŸ„ Christmas</option>
                        <option value="patriotic">ğŸ‡ºğŸ‡¸ Patriotic</option>
                        <option value="fireworks">ğŸ† Fireworks</option>
                    </select>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">âš¡ Speed:</label>
                        <input type="range" id="aerialAnimationSpeed" min="1" max="10" value="5" style="width: 80px;" onchange="updateAerialAnimationSpeed()">
                        <span id="aerialSpeedValue">5</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸ’¡ Spacing:</label>
                        <input type="number" id="aerialLightSpacing" min="4" max="24" value="8" step="1" style="width: 60px; font-size: 0.8rem;" onchange="updateAerialLightSpacing()">
                        <span style="font-size: 0.8rem;">in</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸ’ Bulb Size:</label>
                        <input type="range" id="aerialBulbSize" min="0.5" max="3" value="1" step="0.1" style="width: 80px;" onchange="updateAerialBulbSize()">
                        <span id="aerialBulbSizeValue">1.0"</span>
                        <span style="font-size: 0.7rem; color: #666;" title="Adjust to match actual FireflyiQ bulb size">â„¹ï¸</span>
                    </div>
                    <button id="aerialClearLightsBtn" class="btn" onclick="clearAerialLights()" style="background: #F44336; color: white; font-size: 0.8rem;">
                        ğŸ—‘ï¸ Clear
                    </button>
                </div>
                <div style="margin-top: 10px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸŒ™ Darken Image:</label>
                        <input type="range" id="aerialDarknessSlider" min="0" max="90" value="0" style="width: 120px;" onchange="updateAerialDarkness()">
                        <span id="aerialDarknessValue">0%</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                        <label style="font-size: 0.8rem;">ğŸ¨ Color:</label>
                        <input type="color" id="aerialLightColor" value="#FFD700" style="width: 60px; height: 30px; border: none; border-radius: 4px;" onchange="updateAerialLightColor()">
                        <span style="font-size: 0.8rem;">ğŸ’¡ Click on image to place lights</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Step 2: Street View Measurements -->
    <div class="section" id="step3Section">
        <div class="section-header" onclick="toggleSection('step3Section')">
            <span>ğŸš— Step 2: Street View Measurements</span>
            <span class="toggle-icon">â–¶</span>
        </div>
        <div class="section-content">


            <div style="margin-bottom: 15px;">
                <p style="background: rgba(255, 193, 7, 0.2); padding: 10px; border-radius: 8px; border: 1px solid #FFC107;">
                    <strong>ğŸ“ Scale Calibration:</strong> Draw a reference line on a known feature (16' garage door, 8' single door, 3' front door), then enter the actual measurement.
                </p>
                <p style="background: rgba(74, 144, 226, 0.2); padding: 10px; border-radius: 8px; border: 1px solid #4A90E2; margin-top: 10px;">
                    <strong>ğŸ”‘ API Requirement:</strong> Street View capture uses Google's Static Maps API. Make sure your API key has "Street View Static API" enabled in Google Cloud Console.
                </p>
                
                <!-- Street View Orientation Controls -->
                <div style="background: rgba(255, 152, 0, 0.2); padding: 15px; border-radius: 8px; border: 1px solid #FF9800; margin-top: 10px;">
                    <h4 style="color: #E65100; margin-bottom: 15px; font-size: 1rem;">ğŸ¯ Street View Orientation</h4>
                    <p style="margin-bottom: 15px; font-size: 0.9rem; color: #666;">
                        Adjust the street view direction and angle before capturing. Use these controls to get the perfect view of your house.
                    </p>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label for="streetHeading" style="display: block; margin-bottom: 5px; font-weight: bold; color: #E65100; font-size: 0.9rem;">Direction (Heading)</label>
                            <input type="range" id="streetHeading" min="0" max="360" value="0" style="width: 100%;" onchange="updateStreetViewOrientation()">
                            <div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #666;">
                                <span id="headingValue">0Â°</span> (North = 0Â°, East = 90Â°, South = 180Â°, West = 270Â°)
                            </div>
                        </div>
                        
                        <div>
                            <label for="streetPitch" style="display: block; margin-bottom: 5px; font-weight: bold; color: #E65100; font-size: 0.9rem;">Angle (Pitch)</label>
                            <input type="range" id="streetPitch" min="-90" max="90" value="0" style="width: 100%;" onchange="updateStreetViewOrientation()">
                            <div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #666;">
                                <span id="pitchValue">0Â°</span> (0Â° = level, positive = up, negative = down)
                            </div>
                        </div>
                        
                        <div>
                            <label for="streetZoom" style="display: block; margin-bottom: 5px; font-weight: bold; color: #E65100; font-size: 0.9rem;">Zoom Level</label>
                            <input type="range" id="streetZoom" min="0" max="2" step="0.1" value="1" style="width: 100%;" onchange="updateStreetViewOrientation()">
                            <div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #666;">
                                <span id="zoomValue">1.0</span> (0 = far, 2 = close)
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center;">
                        <button id="resetOrientationBtn" class="btn" onclick="resetStreetViewOrientation()" style="background: #FF9800; color: white; margin-right: 10px; font-size: 0.9rem;">
                            ğŸ”„ Reset Orientation
                        </button>
                        <button id="applyOrientationBtn" class="btn" onclick="applyStreetViewOrientation()" style="background: #4CAF50; color: white; font-size: 0.9rem;">
                            âœ… Apply Changes
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Street View Container -->
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; border: 1px solid #4CAF50; font-size: 0.9rem; color: #2E7D32;">
                ğŸ’¡ <strong>Enhanced View:</strong> Increased to 800px height for better visibility and easier measurements
            </div>
            
            <!-- Street View Light Controls -->
            <div style="margin-bottom: 15px; padding: 12px; background: rgba(156, 39, 176, 0.1); border-radius: 8px; border: 1px solid #9C27B0;">
                <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ¬ Street View Light Controls:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <button id="streetAnimationToggle" class="btn" onclick="toggleStreetAnimation()" style="background: #9C27B0; color: white; font-size: 0.9rem;">
                        â–¶ï¸ Start Animation
                    </button>
                    <select id="streetAnimationMode" class="input-field" style="width: 140px; font-size: 0.9rem;">
                        <option value="static">ğŸ”„ Static</option>
                        <option value="twinkle">âœ¨ Twinkle</option>
                        <option value="chase">ğŸƒ Chase</option>
                        <option value="fade">ğŸŒŠ Fade</option>
                        <option value="rainbow">ğŸŒˆ Rainbow</option>
                        <option value="christmas">ğŸ„ Christmas</option>
                        <option value="patriotic">ğŸ‡ºğŸ‡¸ Patriotic</option>
                        <option value="fireworks">ğŸ† Fireworks</option>
                    </select>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">âš¡ Speed:</label>
                        <input type="range" id="streetAnimationSpeed" min="1" max="10" value="5" style="width: 80px;" onchange="updateStreetAnimationSpeed()">
                        <span id="streetSpeedValue">5</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸ’¡ Spacing:</label>
                        <input type="number" id="streetLightSpacing" min="4" max="24" value="8" step="1" style="width: 60px; font-size: 0.8rem;" onchange="updateStreetLightSpacing()">
                        <span style="font-size: 0.8rem;">in</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸ’ Bulb Size:</label>
                        <input type="range" id="streetBulbSize" min="0.5" max="3" value="1" step="0.1" style="width: 80px;" onchange="updateStreetBulbSize()">
                        <span id="streetBulbSizeValue">1.0"</span>
                        <span style="font-size: 0.7rem; color: #666;" title="Adjust to match actual FireflyiQ bulb size">â„¹ï¸</span>
                    </div>
                    <button id="streetClearLightsBtn" class="btn" onclick="clearStreetLights()" style="background: #F44336; color: white; font-size: 0.8rem;">
                        ğŸ—‘ï¸ Clear
                    </button>
                </div>
                <div style="margin-top: 10px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <label style="font-size: 0.8rem;">ğŸŒ™ Darken Image:</label>
                        <input type="range" id="streetDarknessSlider" min="0" max="90" value="0" style="width: 120px;" onchange="updateStreetDarkness()">
                        <span id="streetDarknessValue">0%</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                        <label style="font-size: 0.8rem;">ğŸ¨ Color:</label>
                        <input type="color" id="streetLightColor" value="#FFD700" style="width: 60px; height: 30px; border: none; border-radius: 4px;" onchange="updateStreetLightColor()">
                        <span style="font-size: 0.8rem;">ğŸ’¡ Click on image to place lights</span>
                    </div>
                </div>
            </div>
            
            <!-- Street View Drawing Controls -->
            <div style="margin-bottom: 15px; padding: 15px; background: rgba(74, 144, 226, 0.1); border-radius: 8px; border: 1px solid #4A90E2;">
                <label style="font-weight: bold;">âœï¸ Street View Drawing Mode:</label>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                    <button id="streetStraightLineBtn" class="btn active" onclick="setStreetDrawingMode('straight')">ğŸ“ Straight Lines</button>
                    <button id="streetFreehandBtn" class="btn" onclick="setStreetDrawingMode('freehand')">âœ‹ Freehand</button>
                    <button onclick="clearStreetViewDrawings()" style="background: #f44336;">ğŸ—‘ï¸ Clear All</button>
                </div>
                <div style="font-size: 0.85rem; color: #666;">
                    <span id="streetStraightModeHelp" style="display: block;">ğŸ“ <strong>Straight Lines:</strong> Click to place points for scale line and measurements</span>
                    <span id="streetFreehandModeHelp" style="display: none;">âœ‹ <strong>Freehand:</strong> Click and drag to draw continuous measurement lines</span>
                </div>
            </div>
            
            <div id="streetContainer" class="streetview-container" style="position: relative; height: 800px; min-height: 800px;">
                    <div id="streetView" style="width: 100%; height: 100%;"></div>
                    <canvas id="streetCanvas" style="width: 100%; height: 100%;"></canvas>
                
                <!-- Street View Capture Controls -->
                <div style="position: absolute; top: 10px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px;">
                    <div style="color: white; font-size: 0.8rem; margin-bottom: 8px; text-align: center; opacity: 0.9;">
                        ğŸ’¡ Uses Google Static Maps API
                    </div>
                    <button id="captureStreetViewBtn" class="btn" onclick="captureStreetView()" style="margin-bottom: 8px; width: 100%;">
                        ğŸ“¸ Capture Street View
                    </button>
                    <button id="resetStreetViewBtn" class="btn secondary" onclick="resetStreetView()" style="width: 100%; display: none;">
                        ğŸ”„ Back to Live View
                    </button>
                </div>
                

                    <div style="color: white; font-size: 0.8rem; margin-bottom: 8px; text-align: center; opacity: 0.9;">
                        âœï¸ Drawing Tools
                    </div>

                    <div style="margin-bottom: 8px;">
                        <label style="color: white; font-size: 0.7rem; display: block; margin-bottom: 4px;">Side:</label>
                        <select id="streetSideSelect" class="input-field" style="width: 100%; font-size: 0.7rem; padding: 4px;">
                            <option value="front">Front</option>
                            <option value="leftSide">Left Side</option>
                            <option value="rightSide">Right Side</option>
                            <option value="back">Back</option>
                        </select>
                    </div>



                </div>
                
                                    <!-- Captured Image Display -->
                    <div id="capturedStreetViewContainer" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 999; background: #000;">
                        <img id="capturedStreetViewImage" style="width: 100%; height: 100%; object-fit: cover;">
                        <canvas id="capturedStreetCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair;"></canvas>
                        
                        <!-- Capture Status Overlay -->
                        <div id="captureStatusOverlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; text-align: center; display: none;">
                            <div id="captureStatusText">Capturing...</div>
                            <div style="margin-top: 10px; font-size: 0.9rem; opacity: 0.8;">Please wait while we capture the Street View</div>
                        </div>
                    </div>
            </div>
            
            <!-- Street View Scale Calibration -->
            <div id="streetScaleSection" style="margin-top: 15px; padding: 15px; background: rgba(255, 193, 7, 0.1); border-radius: 8px; border: 1px solid #FFC107;">
                <h4 style="color: #FFC107; margin-bottom: 15px;">ğŸ“ Street View Scale Calibration</h4>
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: #666;">
                    After capturing Street View, draw a reference line on a known feature (16' garage door, 8' single door, 3' front door), then enter the actual measurement.
                </p>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 0, 0, 0.1); border-radius: 6px; border: 1px solid #FF0000;">
                    <strong>âš ï¸ Note:</strong> Static Street View shows a fixed view. For better positioning, try different addresses or use the aerial view for measurements.
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ“ Reference Width (feet):</label>
                        <input type="number" id="streetScaleInput" class="input-field" placeholder="16" value="16" step="0.1">
                    </div>
                    <div style="display: flex; gap: 8px; align-items: end;">
                        <button class="btn" onclick="applyStreetScale()">âœ… Apply Scale</button>

                    </div>
                </div>
                
                                <div id="streetScaleStatus" style="display: none; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 6px; border: 1px solid #4CAF50; color: #4CAF50;">
                    âœ… Scale applied successfully! You can now draw measurement lines.
                </div>
            </div>
            </div>
            
            <!-- File Upload for Scale Calibration -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(0, 255, 0, 0.1); border-radius: 10px; border: 1px solid #4CAF50;">
                <h4 style="color: #4CAF50; margin-bottom: 15px;">ğŸ“ Upload Image for Scale Calibration</h4>
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: #666;">
                    Upload a photo of your house with a known reference object (garage door, front door, etc.) for accurate scale calibration.
                </p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ“· Upload Image:</label>
                        <input type="file" id="scaleImageUpload" accept="image/*" class="input-field" onchange="handleImageUpload(event)">
                    </div>
                    <div>
                        <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ“ Reference Width (feet):</label>
                        <input type="number" id="uploadedImageScale" class="input-field" placeholder="16" value="16" step="0.1">
                    </div>
                </div>
                
                <div id="uploadedImagePreview" style="display: none; margin: 15px 0;">
                    <h5 style="margin-bottom: 10px;">ğŸ“¸ Image Preview:</h5>
                    <div style="position: relative; display: inline-block; z-index: 1;">
                        <img id="previewImage" style="max-width: 100%; max-height: 300px; border-radius: 8px; border: 2px solid #4CAF50;">
                        <canvas id="scaleCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair; border-radius: 8px;"></canvas>
                                                              <canvas id="measurementCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair; border-radius: 8px; display: none; pointer-events: none; z-index: 5;"></canvas>
                    </div>
                    <div style="margin-top: 10px;">
                        <p style="font-size: 0.9rem; color: #666; margin-bottom: 10px;">
                            <strong>Instructions:</strong> Click and drag to draw a line across your reference object (e.g., garage door width)
                        </p>
                        <button class="btn" onclick="applyUploadedImageScale()">âœ… Apply Scale from Image</button>
                        <button class="btn secondary" onclick="clearUploadedImage()">ğŸ—‘ï¸ Clear Image</button>
                    </div>
                    
                                                                          <!-- Measurement Drawing Controls (shown after scale is applied) -->
                    <div id="measurementControls" style="display: none; margin-top: 15px; padding: 15px; background: rgba(0, 123, 255, 0.1); border-radius: 8px; border: 1px solid #007bff; position: relative; z-index: 10;">
                        <!-- Side Selection for Uploaded Image -->
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(255, 193, 7, 0.1); border-radius: 6px; border: 1px solid #FFC107;">
                            <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ  Select House Side:</label>
                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                <button id="uploadedSideFront" class="btn side-btn active" onclick="selectUploadedImageSide('front')" style="background: #4CAF50; font-size: 0.8rem; padding: 6px 10px;">ğŸ  Front</button>
                                <button id="uploadedSideLeft" class="btn side-btn" onclick="selectUploadedImageSide('left')" style="background: #2196F3; font-size: 0.8rem; padding: 6px 10px;">â¬…ï¸ Left</button>
                                <button id="uploadedSideRight" class="btn side-btn" onclick="selectUploadedImageSide('right')" style="background: #FF9800; font-size: 0.8rem; padding: 6px 10px;">â¡ï¸ Right</button>
                                <button id="uploadedSideBack" class="btn side-btn" onclick="selectUploadedImageSide('back')" style="background: #9C27B0; font-size: 0.8rem; padding: 6px 10px;">ğŸ  Back</button>
                            </div>
                            <p style="font-size: 0.8rem; color: #666; margin-top: 6px; margin-bottom: 0;">
                                <strong>Current Side:</strong> <span id="currentUploadedSideLabel">Front</span>
                            </p>
                        </div>
                        
                        <h6 style="color: #007bff; margin-bottom: 10px;">ğŸ“ Draw Measurement Lines:</h6>
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <button id="uploadedStraightMode" class="btn" onclick="setUploadedImageDrawingMode('straight')">ğŸ“ Straight Lines</button>
                            <button id="uploadedFreehandMode" class="btn" onclick="setUploadedImageDrawingMode('freehand')">âœ‹ Freehand</button>
                        </div>
                        <p style="font-size: 0.9rem; color: #666; margin-bottom: 10px;">
                            <strong>Current Mode:</strong> <span id="currentUploadedMode">Straight Lines</span>
                        </p>
                        <button class="btn secondary" onclick="clearUploadedImageMeasurements()">ğŸ—‘ï¸ Clear Measurements</button>
                    </div>
                </div>
            </div>
            
            <!-- Street View Measurements Display -->
            <div class="measurements-display">
                <div class="measurement-card">
                    <h3>ğŸ  Front</h3>
                    <div class="measurement-value" id="streetFront">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¬…ï¸ Left Side</h3>
                    <div class="measurement-value" id="streetLeftSide">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¡ï¸ Right Side</h3>
                    <div class="measurement-value" id="streetRightSide">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>â¬…ï¸ Back</h3>
                    <div class="measurement-value" id="streetBack">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ“ Total</h3>
                    <div class="measurement-value" id="streetTotal">0</div>
                    <div class="measurement-unit">feet</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Step 3: Light Configuration & Calculations -->
    <div class="section" id="step4Section">
        <div class="section-header" onclick="toggleSection('step4Section')">
            <span>ğŸ’¡ Step 3: Light Configuration & Calculations</span>
            <span class="toggle-icon">â–¼</span>
        </div>
        <div class="section-content">



            <!-- Side-Specific Measurement Toggles -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 193, 7, 0.1); border-radius: 10px; border: 1px solid #FFC107;">
                <h4 style="color: var(--primary-orange); margin-bottom: 15px;">ğŸ  Side-Specific Measurement Sources</h4>
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: #666;">
                    Choose which measurement source to use for each side of the house. Front defaults to Street View, others to Aerial.
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="font-weight: bold; min-width: 60px;">Front:</label>
                        <select id="frontSource" class="input-field" style="width: auto;" onchange="updateSideSource('front')">
                            <option value="street" selected>Street View</option>
                            <option value="aerial">Aerial View</option>
                        </select>
                        <span id="frontStatus" style="font-size: 0.8rem; color: #666;">(Street View)</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="font-weight: bold; min-width: 60px;">Left:</label>
                        <select id="leftSource" class="input-field" style="width: auto;" onchange="updateSideSource('left')">
                            <option value="aerial" selected>Aerial View</option>
                            <option value="street">Street View</option>
                        </select>
                        <span id="leftStatus" style="font-size: 0.8rem; color: #666;">(Aerial View)</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="font-weight: bold; min-width: 60px;">Right:</label>
                        <select id="rightSource" class="input-field" style="width: auto;" onchange="updateSideSource('right')">
                            <option value="aerial" selected>Aerial View</option>
                            <option value="street">Street View</option>
                        </select>
                        <span id="rightStatus" style="font-size: 0.8rem; color: #666;">(Aerial View)</span>
                    </div>
                    
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label style="font-weight: bold; min-width: 60px;">Back:</label>
                        <select id="backSource" class="input-field" style="width: auto;" onchange="updateSideSource('back')">
                            <option value="aerial" selected>Aerial View</option>
                            <option value="street">Street View</option>
                        </select>
                        <span id="backStatus" style="font-size: 0.8rem; color: #666;">(Aerial View)</span>
                    </div>
                </div>
            </div>


            


            <!-- Waste Factor Control -->
            <div style="margin-bottom: 20px;">
                <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ“¦ Waste Factor (%):</label>
                <input type="number" id="wasteFactor" class="input-field" value="10" min="0" max="50" step="1" onchange="updateLightCalculations()" style="width: 150px;">
                <span style="margin-left: 10px; color: #666; font-size: 0.9rem;">ğŸ’¡ Recommended: 10% for most projects</span>
            </div>

            <!-- Bid Total Measurements Display -->
            <div style="margin: 20px 0; padding: 15px; background: rgba(76, 175, 80, 0.1); border-radius: 10px; border: 1px solid #4CAF50;">
                <h4 style="color: #2E7D32; margin-bottom: 15px;">ğŸ“ Bid Total Measurements</h4>
                <p style="margin-bottom: 15px; font-size: 0.9rem; color: #666;">
                    Total footage from all sides based on your selected measurement sources. This is the footage that will be used for pricing in Step 5.
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div class="measurement-card">
                        <h3>ğŸ  Front</h3>
                        <div class="measurement-value" id="bidFront">0</div>
                        <div class="measurement-unit">feet</div>
                        <div style="font-size: 0.7rem; color: #666;" id="frontSourceLabel">(Street View)</div>
                    </div>
                    
                    <div class="measurement-card">
                        <h3>â¬…ï¸ Left Side</h3>
                        <div class="measurement-value" id="bidLeftSide">0</div>
                        <div class="measurement-unit">feet</div>
                        <div style="font-size: 0.7rem; color: #666;" id="leftSourceLabel">(Aerial View)</div>
                    </div>
                    
                    <div class="measurement-card">
                        <h3>â¡ï¸ Right Side</h3>
                        <div class="measurement-value" id="bidRightSide">0</div>
                        <div class="measurement-unit">feet</div>
                        <div style="font-size: 0.7rem; color: #666;" id="rightSourceLabel">(Aerial View)</div>
                    </div>
                    
                    <div class="measurement-card">
                        <h3>â¬…ï¸ Back</h3>
                        <div class="measurement-value" id="bidBack">0</div>
                        <div class="measurement-unit">feet</div>
                        <div style="font-size: 0.7rem; color: #666;" id="backSourceLabel">(Aerial View)</div>
                    </div>
                </div>
                
                <div style="text-align: center; padding: 15px; background: rgba(255, 193, 7, 0.1); border-radius: 8px; border: 1px solid #FFC107;">
                    <h3 style="color: #E65100; margin-bottom: 10px;">ğŸ’° Total for Bid</h3>
                    <div class="measurement-value" id="bidTotal" style="font-size: 2rem; color: #E65100;">0</div>
                    <div class="measurement-unit" style="font-size: 1.2rem;">feet</div>
                </div>
            </div>

            <!-- Light Count & Waste Factor -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                <div class="measurement-card">
                    <h3>ğŸ’¡ Total Lights Needed</h3>
                    <div class="measurement-value" id="totalLights">0</div>
                    <div class="measurement-unit">lights</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ“¦ With Waste Factor</h3>
                    <div class="measurement-value" id="lightsWithWaste">0</div>
                    <div class="measurement-unit">lights</div>
                </div>
            </div>


        </div>
    </div>

    <!-- Step 4: Pricing & Sales -->
    <div class="section" id="step5Section">
        <div class="section-header" onclick="toggleSection('step5Section')">
            <span>ğŸ’° Step 4: Pricing & Sales</span>
            <span class="toggle-icon">â–¶</span>
        </div>
        <div class="section-content">
            <!-- Pricing Controls -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ’µ Retail Price per Foot:</label>
                    <input type="number" id="retailPrice" class="input-field" value="35" step="0.01" onchange="updatePricing()">
                </div>
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ·ï¸ Sale Price per Foot:</label>
                    <input type="number" id="salePrice" class="input-field" value="22" step="0.01" onchange="updatePricing()">
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ® Controller Cost:</label>
                    <input type="number" id="controllerCost" class="input-field" value="300" step="1" onchange="updatePricing()">
                </div>
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 8px;">ğŸ Extra Discount Amount:</label>
                    <input type="number" id="extraDiscount" class="input-field" value="0" step="0.01" onchange="updatePricing()" placeholder="Enter additional discount">
                </div>
            </div>

            <!-- Pricing Display -->
            <div class="measurements-display">
                <div class="measurement-card">
                    <h3>ğŸ’° Retail Total</h3>
                    <div class="measurement-value" id="retailTotal">$0</div>
                    <div class="measurement-unit">before taxes</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ¯ Sale Total</h3>
                    <div class="measurement-value" id="saleTotal">$0</div>
                    <div class="measurement-unit">special price</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ Extra Discount</h3>
                    <div class="measurement-value" id="extraDiscountDisplay">$0</div>
                    <div class="measurement-unit">additional savings</div>
                </div>
                <div class="measurement-card">
                    <h3>ğŸ’° Total Savings</h3>
                    <div class="measurement-value" id="totalSavings">$0</div>
                    <div class="measurement-unit">customer saves</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Step 5: Customer Agreement & Checkout -->
    <div class="section" id="step6Section">
        <div class="section-header" onclick="toggleSection('step6Section')">
            <span>âœï¸ Step 5: Customer Agreement & Checkout</span>
            <span class="toggle-icon">â–¶</span>
        </div>
        <div class="section-content">
            <div style="margin-bottom: 20px;">
                <h3 style="color: var(--primary-orange); margin-bottom: 15px;">Customer Information</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <input type="text" id="customerName" class="input-field" placeholder="Customer Name">
                    <input type="email" id="customerEmail" class="input-field" placeholder="Email Address">
                </div>
                <input type="tel" id="customerPhone" class="input-field" placeholder="Phone Number" style="margin-bottom: 15px;">
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 10px; font-weight: bold;">
                    <input type="checkbox" id="termsAccepted" style="transform: scale(1.2);">
                    I agree to the terms and conditions and authorize this estimate
                </label>
            </div>

            <div style="margin-bottom: 20px;">
                <h4 style="margin-bottom: 10px;">âœï¸ Digital Signature:</h4>
                <canvas id="signatureCanvas" style="border: 2px solid #ddd; border-radius: 8px; background: white; cursor: crosshair;" width="400" height="150"></canvas>
                <div style="margin-top: 10px;">
                    <button class="btn secondary" onclick="clearSignature()">Clear Signature</button>
                </div>
            </div>

            <div style="text-align: center;">
                <button class="btn" onclick="finalizeOrder()" style="font-size: 1.2rem; padding: 15px 30px;">
                    ğŸš€ Complete Order & Generate Contract
                </button>
            </div>
        </div>
    </div>

    <!-- Night Visualization Modal (placeholder for future implementation) -->
    <div id="nightVisualizationModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000;">
        <div style="position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center;">
            <button onclick="closeNightVisualization()" style="position: absolute; top: 20px; right: 20px; background: white; border: none; padding: 10px; border-radius: 50%; cursor: pointer; z-index: 1001;">âœ•</button>
            <canvas id="nightVisualizationCanvas" style="max-width: 90%; max-height: 90%; border-radius: 10px;"></canvas>
        </div>
    </div>

</body>
</html>

<script>
    // Initialize multi-color system when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Set up animation speed slider
        const speedSlider = document.getElementById('animationSpeed');
        if (speedSlider) {
            speedSlider.addEventListener('input', function() {
                const speedValue = document.getElementById('speedValue');
                const speed = parseInt(this.value);
                currentAnimationSpeed = speed;
                
                // Update speed text
                if (speed <= 3) speedValue.textContent = 'Slow';
                else if (speed <= 7) speedValue.textContent = 'Medium';
                else speedValue.textContent = 'Fast';
            });
        }
        
        // Set up custom color inputs
        const customColorInputs = ['customColor1', 'customColor2', 'customColor3', 'customColor4'];
        customColorInputs.forEach((id, index) => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('change', function() {
                    customColors[index] = this.value;
                });
            }
        });
        
        // Set up light spacing change listener
        const lightSpacingInput = document.getElementById('lightSpacing');
        if (lightSpacingInput) {
            lightSpacingInput.addEventListener('change', function() {
                updateLightVisualization();
            });
        }
        
        // Initialize collapsible sections
        initializeCollapsibleSections();
        
        // Initialize view toggles
        initializeViewToggles();
        
        // Initialize night mode system
        initializeNightMode();
        
        // Initialize measurements system
        initializeMeasurements();
        
        // Force update light visualization after initialization
        setTimeout(() => {
            updateLightVisualization();
        }, 100);
        
        // Initialize the BADASS light transition slider
        setTimeout(() => {
            initializeLightTransitionSlider();
        }, 2500);
        
        // Initialize the separate aerial and street view sliders
        setTimeout(() => {
            initializeSeparateSliders();
        }, 3000);
        
        // Initialize street view orientation controls
        setTimeout(() => {
            updateStreetViewOrientation();
        }, 3500);
        
        // Initialize darkness controls
        setTimeout(() => {
            updateAerialDarkness();
            updateStreetDarkness();
        }, 4000);
        
        // Auto-capture background after a delay to allow maps to load
        setTimeout(() => {
            captureTransitionBackground();
            
            // Update light calculations after background capture
            setTimeout(() => {
                updateLightVisualization();
            }, 1000);
        }, 5000);
        

        
        // Initialize Google Maps API
        if (typeof google !== 'undefined') {
            initializeGoogleMaps();
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            stopLightAnimation();
        });
    });
    
    // Collapsible section functionality
    function toggleSection(sectionId) {
        const section = document.getElementById(sectionId);
        const header = section.querySelector('.section-header');
        const content = section.querySelector('.section-content');
        const icon = header.querySelector('.toggle-icon');
        
        if (content.style.display === 'none' || content.style.display === '') {
            content.style.display = 'block';
            header.classList.add('active');
            icon.textContent = 'â–¼';
        } else {
            content.style.display = 'none';
            header.classList.remove('active');
            icon.textContent = 'â–¶';
        }
    }
    
    function initializeCollapsibleSections() {
        // Set default states
        const sections = ['step1Section', 'step2Section', 'step3Section', 'step4Section', 'step5Section', 'step6Section'];
        const defaultOpen = ['step2Section', 'step4Section']; // Measurement and visualization open by default
        
        sections.forEach(sectionId => {
            const section = document.getElementById(sectionId);
            if (section) {
                const content = section.querySelector('.section-content');
                const icon = section.querySelector('.toggle-icon');
                
                if (defaultOpen.includes(sectionId)) {
                    content.style.display = 'block';
                    icon.textContent = 'â–¼';
                } else {
                    content.style.display = 'none';
                    icon.textContent = 'â–¶';
                }
            }
        });
    }
    
    function initializeViewToggles() {
        try {
            // Set default view to "lines" for both aerial and street
            const aerialLinesBtn = document.getElementById('aerialShowLines');
            const streetLinesBtn = document.getElementById('streetShowLines');
            
            if (aerialLinesBtn) {
                aerialLinesBtn.classList.add('active');
                console.log('âœ… Aerial view toggle initialized to "Lines"');
            }
            
            if (streetLinesBtn) {
                streetLinesBtn.classList.add('active');
                console.log('âœ… Street view toggle initialized to "Lines"');
            }
            
            // Set initial view states
            showAerialLines();
            showStreetLines();
            
            console.log('âœ… View toggles initialized successfully');
        } catch (error) {
            console.error('Error initializing view toggles:', error);
        }
    }
    
    // View toggle functions for aerial and street views
    function toggleAerialView(viewType) {
        try {
            // Update button states
            const buttons = ['aerialShowLines', 'aerialShowLights', 'aerialShowFinal', 'aerialShowLabels'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.remove('active');
                }
            });
            document.getElementById(`aerialShow${viewType.charAt(0).toUpperCase() + viewType.slice(1)}`).classList.add('active');
            
            // Apply view changes
            switch(viewType) {
                case 'lines':
                    showAerialLines();
                    break;
                case 'lights':
                    showAerialLights();
                    break;
                case 'final':
                    showAerialFinal();
                    break;
                case 'labels':
                    showAerialLabels();
                    break;
            }
            
            console.log('Aerial view changed to:', viewType);
        } catch (error) {
            console.error('Error toggling aerial view:', error);
        }
    }
    
    function toggleStreetView(viewType) {
        try {
            // Update button states
            const buttons = ['streetShowLines', 'streetShowLights', 'streetShowFinal', 'streetShowLabels'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.remove('active');
                }
            });
            document.getElementById(`streetShow${viewType.charAt(0).toUpperCase() + viewType.slice(1)}`).classList.add('active');
            
            // Apply view changes
            switch(viewType) {
                case 'lines':
                    showStreetLines();
                    break;
                case 'lights':
                    showStreetLights();
                    break;
                case 'final':
                    showStreetFinal();
                    break;
                case 'labels':
                    showStreetLabels();
                    break;
            }
            
            console.log('Street view changed to:', viewType);
        } catch (error) {
            console.error('Error toggling street view:', error);
        }
    }
    
    // ===== GLOBAL VARIABLES =====
    let map;
    let streetView;
    let aerialCanvas, streetCanvas;
    let aerialCtx, streetCtx;
    let currentProperty = null;
    let drawingMode = 'straight';
    let isDrawing = false;
    let currentPath = [];
    let allPaths = [];
    let measurements = {
        aerial: { 
            front: 0, 
            leftSide: 0, 
            rightSide: 0, 
            back: 0, 
            perimeter: 0, 
            eaves: 0, 
            gables: 0 
        },
        street: { 
            front: 0, 
            leftSide: 0, 
            rightSide: 0, 
            back: 0, 
            total: 0, 
            eaves: 0, 
            gables: 0 
        }
    };
    
    // Initialize measurements and update display
    function initializeMeasurements() {
        // Ensure measurements object exists with all properties
        if (!measurements.aerial) {
            measurements.aerial = { front: 0, leftSide: 0, rightSide: 0, back: 0, perimeter: 0, eaves: 0, gables: 0 };
        }
        if (!measurements.street) {
            measurements.street = { front: 0, leftSide: 0, rightSide: 0, back: 0, total: 0, eaves: 0, gables: 0 };
        }
        
        // Update light calculations
        updateLightVisualization();
        
        console.log('Measurements initialized:', measurements);
    }
    
    // Multi-Color Light System Variables
    let currentColorScheme = 'rgbw';
    let currentAnimationMode = 'static';
    let currentAnimationSpeed = 5;
    let customColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00'];
    
    // Scale factors
    let aerialScaleFactor = 1;
    let streetScaleFactor = 0.1; // Start with small value to prevent confusion
    
    // Street View drawing variables
    let currentStreetDrawingMode = 'straight';
    let isStreetViewDrawing = false;
    
    // Separate slider variables
    let aerialTransitionBackgroundImage = null;
    let streetTransitionBackgroundImage = null;
    let aerialTransitionAnimationId = null;
    let streetTransitionAnimationId = null;
    
    // Street View capture variables
    let capturedStreetViewData = null;
    let isStreetViewCaptured = false;
    
    // Path variables
    let aerialPaths = [];
    let streetPaths = [];
    
    // Side selection variables
    let currentAerialSide = 'front';
    let currentUploadedImageSide = 'front';
    
    // Uploaded image variables
    let uploadedImageData = null;
    let scaleCanvas = null;
    let scaleCtx = null;
    let measurementCanvas = null;
    let measurementCtx = null;
    
    // Captured canvas variables
    let capturedCanvas = null;

    
    // Google Maps API Key
    const googleMapsApiKey = 'AIzaSyB1KpT96Ce5EzrS_18k6iljxhqfEhSUgAs';
    
    // ===== MULTI-COLOR LIGHT SYSTEM FUNCTIONS =====
    function updateColorPreview() {
        const colorScheme = document.getElementById('colorScheme').value;
        const colorPreview = document.getElementById('colorPreview');
        const customPalette = document.getElementById('customColorPalette');
        
        // Show/hide custom color palette
        if (colorScheme === 'custom') {
            customPalette.style.display = 'block';
        } else {
            customPalette.style.display = 'none';
        }
        
        // Update color preview based on scheme
        let gradient, description;
        switch(colorScheme) {
            case 'rgbw':
                gradient = 'linear-gradient(90deg, #ff0000, #00ff00, #0000ff, #ffffff)';
                description = 'RGBW Full Spectrum';
                break;
            case 'rwb':
                gradient = 'linear-gradient(90deg, #ff0000, #ffffff, #0000ff)';
                description = 'ğŸ‡ºğŸ‡¸ RWB Patriotic';
                break;
            case 'christmas':
                gradient = 'linear-gradient(90deg, #ff0000, #00ff00, #ffffff)';
                description = 'ï¿½ï¿½ Christmas Colors';
                break;
            case 'halloween':
                gradient = 'linear-gradient(90deg, #ff8c00, #800080, #000000)';
                description = 'ğŸƒ Halloween Colors';
                break;
            case 'easter':
                gradient = 'linear-gradient(90deg, #ffb6c1, #98fb98, #87ceeb, #dda0dd)';
                description = 'ğŸ° Easter Pastels';
                break;
            case 'warm':
                gradient = 'linear-gradient(90deg, #fff8dc, #ffefd5, #ffe4b5)';
                description = 'ğŸ”¥ Warm White (2700K)';
                break;
            case 'cool':
                gradient = 'linear-gradient(90deg, #f0f8ff, #e6f3ff, #ccf2ff)';
                description = 'â„ï¸ Cool White (5000K)';
                break;
            default:
                gradient = 'linear-gradient(90deg, #ff0000, #00ff00, #0000ff, #ffffff)';
                description = 'Custom Colors';
        }
        
        const gradientDiv = colorPreview.querySelector('.color-gradient');
        const descDiv = colorPreview.querySelector('div:last-child');
        
        if (gradientDiv) gradientDiv.style.background = gradient;
        if (descDiv) descDiv.textContent = `Current: ${description}`;
        
        // Update global color scheme
        currentColorScheme = colorScheme;
    }
    
    function updateAnimationPreview() {
        const animationMode = document.getElementById('animationMode').value;
        const speedSlider = document.getElementById('animationSpeed');
        const speedValue = document.getElementById('speedValue');
        
        // Update speed text based on animation
        let speedText;
        switch(animationMode) {
            case 'static':
                speedText = 'N/A';
                speedSlider.disabled = true;
                break;
            case 'twinkle':
                speedText = 'Twinkle Rate';
                speedSlider.disabled = false;
                break;
            case 'chase':
                speedText = 'Chase Speed';
                speedSlider.disabled = false;
                break;
            case 'fade':
                speedText = 'Fade Speed';
                speedSlider.disabled = false;
                break;
            case 'rainbow':
                speedText = 'Cycle Speed';
                speedSlider.disabled = false;
                break;
            case 'patriotic':
                speedText = 'Wave Speed';
                speedSlider.disabled = false;
                break;
            case 'fireworks':
                speedText = 'Burst Rate';
                speedSlider.disabled = false;
                break;
            default:
                speedText = 'Custom Speed';
                speedSlider.disabled = false;
        }
        
        if (speedValue) speedValue.textContent = speedText;
        currentAnimationMode = animationMode;
    }
    
    function getCurrentColors() {
        const colorScheme = document.getElementById('colorScheme').value;
        
        switch(colorScheme) {
            case 'rgbw':
                return ['#ff0000', '#00ff00', '#0000ff', '#ffffff'];
            case 'rwb':
                return ['#ff0000', '#ffffff', '#0000ff'];
            case 'christmas':
                return ['#ff0000', '#00ff00', '#ffffff'];
            case 'halloween':
                return ['#ff8c00', '#800080', '#000000'];
            case 'easter':
                return ['#ffb6c1', '#98fb98', '#87ceeb', '#dda0dd'];
            case 'warm':
                return ['#fff8dc', '#ffefd5', '#ffe4b5'];
            case 'cool':
                return ['#f0f8ff', '#e6f3ff', '#ccf2ff'];
            case 'custom':
                return [
                    document.getElementById('customColor1').value,
                    document.getElementById('customColor2').value,
                    document.getElementById('customColor3').value,
                    document.getElementById('customColor4').value
                ];
            default:
                return ['#ff0000', '#00ff00', '#0000ff', '#ffffff'];
        }
    }
    
    function getAnimationSpeed() {
        return parseInt(document.getElementById('animationSpeed').value);
    }
    
    function createMultiColorLightEffect(ctx, x, y, radius, colors, animationMode, speed) {
        const time = Date.now() * speed / 1000;
        let color;
        
        switch(animationMode) {
            case 'static':
                color = colors[0];
                break;
            case 'twinkle':
                const twinkleIntensity = Math.sin(time * 2) * 0.5 + 0.5;
                color = colors[Math.floor(time) % colors.length];
                ctx.globalAlpha = twinkleIntensity;
                break;
            case 'chase':
                color = colors[Math.floor(time) % colors.length];
                break;
            case 'fade':
                const fadeIntensity = Math.sin(time) * 0.5 + 0.5;
                color = colors[Math.floor(time / 2) % colors.length];
                ctx.globalAlpha = fadeIntensity;
                break;
            case 'rainbow':
                const hue = (time * 50) % 360;
                color = `hsl(${hue}, 100%, 50%)`;
                break;
            case 'patriotic':
                // Special RWB wave effect
                if (colors.includes('#ff0000') && colors.includes('#ffffff') && colors.includes('#0000ff')) {
                    const wave = Math.sin(time + x * 0.1) * 0.5 + 0.5;
                    if (wave < 0.33) color = '#ff0000';
                    else if (wave < 0.66) color = '#ffffff';
                    else color = '#0000ff';
                } else {
                    color = colors[Math.floor(time) % colors.length];
                }
                break;
            case 'fireworks':
                const burst = Math.sin(time * 3) * 0.5 + 0.5;
                color = colors[Math.floor(burst * colors.length)];
                ctx.globalAlpha = burst;
                break;
            default:
                color = colors[0];
        }
        
        // Draw the light
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add glow effect
        ctx.shadowColor = color;
        ctx.shadowBlur = radius * 2;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Reset global alpha
        ctx.globalAlpha = 1;
    }
    
    // ===== GOOGLE MAPS FUNCTIONS =====
    function initializeGoogleMaps() {
        // Initialize map with default location
        map = new google.maps.Map(document.getElementById('map'), {
            zoom: 21,
            center: { lat: 39.8283, lng: -98.5795 }, // Center of US
            mapTypeId: 'satellite',
            zoomControl: true,
            streetViewControl: false,
            fullscreenControl: false,
            mapTypeControl: false,
            minZoom: 18,
            maxZoom: 21
        });
        
        // Initialize street view
        streetView = new google.maps.StreetViewPanorama(document.getElementById('streetView'), {
            position: { lat: 39.8283, lng: -98.5795 },
            pov: { heading: 0, pitch: 0 },
            zoom: 1,
            addressControl: false,
            enableCloseButton: false,
            fullscreenControl: false,
            motionTracking: false,
            motionTrackingControl: false
        });
        
        // Initialize canvases
        initializeCanvases();
        
        // Get initial Google Maps scale
        setTimeout(() => {
            getGoogleMapScale();
        }, 1000);
    }
    
    function initializeCanvases() {
        // Aerial canvas
        aerialCanvas = document.getElementById('aerialCanvas');
        aerialCtx = aerialCanvas.getContext('2d');
        
        // Street canvas
        streetCanvas = document.getElementById('streetCanvas');
        streetCtx = streetCanvas.getContext('2d');
        
        // Set canvas sizes to match containers
        resizeCanvases();
        
        // Setup drawing events
        setupCanvas(aerialCanvas, aerialCtx, 'aerial');
        setupCanvas(streetCanvas, streetCtx, 'street');
        
        // Resize canvases when window resizes
        window.addEventListener('resize', resizeCanvases);
    }
    
    function resizeCanvases() {
        const mapContainer = document.getElementById('map');
        const streetContainer = document.getElementById('streetView');
        
        if (mapContainer && aerialCanvas) {
            aerialCanvas.width = mapContainer.offsetWidth;
            aerialCanvas.height = mapContainer.offsetHeight;
        }
        
        if (streetContainer && streetCanvas) {
            streetCanvas.width = streetContainer.offsetWidth;
            streetCanvas.height = streetContainer.offsetHeight;
        }
    }
    
    // Setup canvas event listeners
    function setupCanvas(canvas, ctx, type) {
        if (!canvas || !ctx) return;
        
        // Initialize drawing data
        canvas.drawingData = {
            paths: [],
            currentPath: [],
            isDrawing: false
        };
        
        // Add event listeners
        canvas.addEventListener('mousedown', (e) => startDrawing(e, canvas, ctx, type));
        canvas.addEventListener('mousemove', (e) => continueDrawing(e, canvas, ctx, type));
        canvas.addEventListener('mouseup', (e) => endDrawing(e, canvas, ctx, type));
        canvas.addEventListener('mouseleave', (e) => endDrawing(e, canvas, ctx, type));
        
        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent, canvas, ctx, type);
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            continueDrawing(mouseEvent, canvas, ctx, type);
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            endDrawing(mouseEvent, canvas, ctx, type);
        });
        
        console.log(`Canvas ${type} setup complete`);
    }
    
    // ===== DRAWING FUNCTIONS =====
    
    // ===== AERIAL DRAWING FUNCTIONS =====
    // These functions draw measurement lines that lights will be placed along
    
    function handleStraightLineClick(e, canvas, ctx, type) {
        const rect = canvas.getBoundingClientRect();
        
        // Calculate the scale factors for proper coordinate mapping
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        // Calculate the offset-adjusted coordinates
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        if (!canvas.drawingData.currentPath) {
            canvas.drawingData.currentPath = [];
        }
        
        canvas.drawingData.currentPath.push({ x, y });
        
        // Draw a small point to show where we clicked
        const pointSize = 3;
        ctx.fillStyle = '#0066cc';
        ctx.beginPath();
        ctx.arc(x, y, pointSize, 0, Math.PI * 2);
        ctx.fill();
        
        // If this is exactly 2 points, complete the path and place lights
        if (canvas.drawingData.currentPath.length === 2) {
            // Complete the path
            canvas.drawingData.paths.push([...canvas.drawingData.currentPath]);
            
            // Also update global paths for consistency
            if (type === 'aerial') {
                aerialPaths.push([...canvas.drawingData.currentPath]);
            } else if (type === 'capturedStreet') {
                capturedStreetPaths.push([...canvas.drawingData.currentPath]);
            } else {
                streetPaths.push([...canvas.drawingData.currentPath]);
            }
            
            canvas.drawingData.currentPath = [];
            
            // Calculate measurements immediately
            calculateMeasurementsFromPaths(canvas, type);
            
            // Place lights along the completed path
            placeLightsAlongPath(canvas, type);
            
            // Show completion message
            showStatus('Path completed! Lights placed at 8" intervals.', 'success');
        }
    }
    
    function startFreehand(e, canvas, ctx, type) {
        const rect = canvas.getBoundingClientRect();
        
        // Adjust for canvas scaling and positioning
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        canvas.drawingData.isDrawing = true;
        canvas.drawingData.currentPath = [{ x, y }];
        
        ctx.beginPath();
        ctx.moveTo(x, y);
    }
    
    function drawFreehand(e, canvas, ctx, type) {
        if (!canvas.drawingData.isDrawing) return;
        
        const rect = canvas.getBoundingClientRect();
        
        // Adjust for canvas scaling and positioning
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        canvas.drawingData.currentPath.push({ x, y });
        
        // Draw a small point to show where we're drawing
        const pointSize = 2;
        ctx.fillStyle = '#0066cc';
        ctx.beginPath();
        ctx.arc(x, y, pointSize, 0, Math.PI * 2);
        ctx.fill();
    }
    
    function endFreehand(e, canvas, ctx, type) {
        if (!canvas.drawingData.isDrawing) return;
        
        canvas.drawingData.isDrawing = false;
        canvas.drawingData.paths.push([...canvas.drawingData.currentPath]);
        
        // Also update global paths for consistency
        if (type === 'aerial') {
            aerialPaths.push([...canvas.drawingData.currentPath]);
        } else if (type === 'capturedStreet') {
            capturedStreetPaths.push([...canvas.drawingData.currentPath]);
        } else {
            streetPaths.push([...canvas.drawingData.currentPath]);
        }
        
        canvas.drawingData.currentPath = [];
        
        // Debug logging
        console.log('Freehand drawing completed:', {
            type: type,
            paths: canvas.drawingData.paths,
            totalPaths: canvas.drawingData.paths.length,
            currentPathLength: canvas.drawingData.currentPath.length
        });
        
        // Calculate measurements for this type
        calculateMeasurementsFromPaths(canvas, type);
        
        // Place lights along the completed path
        placeLightsAlongPath(canvas, type);
    }
    
    // ===== LIGHT PLACEMENT SYSTEM =====
    // This function places lights at exactly 8" intervals along drawn paths
    function placeLightsAlongPath(canvas, type) {
        try {
            console.log('ğŸ”„ Placing lights along path for', type);
            
            // Get the most recent path
            const paths = canvas.drawingData.paths;
            if (paths.length === 0) return;
            
            const latestPath = paths[paths.length - 1];
            if (!latestPath || latestPath.length < 2) return;
            
            // Get spacing from user input (default 8 inches)
            let spacingInches = 8;
            if (type === 'aerial') {
                spacingInches = parseFloat(document.getElementById('aerialLightSpacing')?.value || 8);
            } else if (type === 'capturedStreet' || type === 'street') {
                spacingInches = parseFloat(document.getElementById('streetLightSpacing')?.value || 8);
            }
            const spacingFeet = spacingInches / 12; // Convert to feet
            
            // Get scale factor for this view type
            let scaleFactor = 0.1; // Default fallback
            if (type === 'aerial' && typeof aerialScaleFactor !== 'undefined' && aerialScaleFactor > 0) {
                scaleFactor = aerialScaleFactor;
            } else if ((type === 'capturedStreet' || type === 'street') && typeof streetScaleFactor !== 'undefined' && streetScaleFactor > 0) {
                scaleFactor = streetScaleFactor;
            }
            if (!scaleFactor || scaleFactor <= 0) {
                console.log('Scale factor not available, using default');
                return;
            }
            
            // Calculate total path length in feet
            let totalPathLength = 0;
            for (let i = 1; i < latestPath.length; i++) {
                const dx = latestPath[i].x - latestPath[i-1].x;
                const dy = latestPath[i].y - latestPath[i-1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                totalPathLength += segmentLength * scaleFactor;
            }
            
            console.log('Path length:', totalPathLength, 'feet, spacing:', spacingFeet, 'feet');
            console.log('Scale factor:', scaleFactor, 'ft/pixel');
            console.log('8 inches =', (8/12 * scaleFactor), 'feet =', (8/12 * scaleFactor * 12), 'pixels on screen');
            
            // Calculate how many lights we need
            const numLights = Math.floor(totalPathLength / spacingFeet) + 1;
            console.log('Placing', numLights, 'lights along path');
            
            // Ensure we have at least 2 lights for visibility
            if (numLights < 2) {
                console.log('Path too short, placing 2 lights for visibility');
                numLights = 2;
            }
            
            // Store light positions for this path
            const lightPositions = [];
            
            // Place lights along the path with minimum pixel spacing
            let lastLightPosition = null;
            for (let i = 0; i < numLights; i++) {
                const distanceAlongPath = i * spacingFeet;
                const lightPosition = getPositionAlongPath(latestPath, distanceAlongPath, scaleFactor);
                
                if (lightPosition) {
                    // Check if this light is too close to the previous one
                    if (lastLightPosition) {
                        const dx = lightPosition.x - lastLightPosition.x;
                        const dy = lightPosition.y - lastLightPosition.y;
                        const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                        
                        // If lights are too close together, skip this one to maintain visual separation
                        if (pixelDistance < 8) { // Minimum 8 pixels between lights for visibility
                            console.log(`Skipping light ${i} - too close to previous light (${pixelDistance.toFixed(1)} pixels)`);
                            continue;
                        }
                    }
                    
                    lightPositions.push(lightPosition);
                    lastLightPosition = lightPosition;
                    
                    // Debug: log spacing between lights
                    if (lightPositions.length > 1) {
                        const dx = lightPosition.x - lightPositions[lightPositions.length - 2].x;
                        const dy = lightPosition.y - lightPositions[lightPositions.length - 2].y;
                        const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                        console.log(`Light ${lightPositions.length - 1}: spacing = ${pixelDistance.toFixed(1)} pixels`);
                    }
                }
            }
            
            // Store the light positions for this path
            if (type === 'aerial') {
                if (!window.aerialLightPositions) window.aerialLightPositions = [];
                window.aerialLightPositions.push({
                    pathIndex: paths.length - 1,
                    positions: lightPositions,
                    spacing: spacingInches
                });
            } else if (type === 'capturedStreet') {
                if (!window.capturedStreetLightPositions) window.capturedStreetLightPositions = [];
                window.capturedStreetLightPositions.push({
                    pathIndex: paths.length - 1,
                    positions: lightPositions,
                    spacing: spacingInches
                });
            } else {
                if (!window.streetLightPositions) window.streetLightPositions = [];
                window.streetLightPositions.push({
                    pathIndex: paths.length - 1,
                    positions: lightPositions,
                    spacing: spacingInches
                });
            }
            
            // Redraw the canvas with lights
            redrawCanvasWithLights(canvas, type);
            
            console.log('âœ… Lights placed successfully:', lightPositions.length, 'lights');
            
        } catch (error) {
            console.error('Error placing lights along path:', error);
        }
    }
    
    // Helper function to get position along a path at a specific distance
    function getPositionAlongPath(path, targetDistance, scaleFactor) {
        try {
            let currentDistance = 0;
            
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i-1].x;
                const dy = path[i].y - path[i-1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                const segmentFeet = segmentLength * scaleFactor;
                
                if (currentDistance + segmentFeet >= targetDistance) {
                    // Calculate position along this segment
                    const segmentProgress = (targetDistance - currentDistance) / segmentFeet;
                    const x = path[i-1].x + (path[i].x - path[i-1].x) * segmentProgress;
                    const y = path[i-1].y + (path[i].y - path[i-1].y) * segmentProgress;
                    
                    return { x, y };
                }
                
                currentDistance += segmentFeet;
            }
            
            // If we reach the end, return the last point
            if (path.length > 0) {
                return path[path.length - 1];
            }
            
            return null;
        } catch (error) {
            console.error('Error getting position along path:', error);
            return null;
        }
    }
    
    // Function to redraw canvas with all lights
    function redrawCanvasWithLights(canvas, type) {
        try {
            const ctx = canvas.getContext('2d');
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw background image if it exists
            if (canvas.backgroundImage) {
                ctx.drawImage(canvas.backgroundImage, 0, 0, canvas.width, canvas.height);
            }
            
            // Draw all lights (no paths - just individual lights)
            drawAllLightsOnCanvas(canvas, type);
            
        } catch (error) {
            console.error('Error redrawing canvas with lights:', error);
        }
    }
    
    // Function to draw all lights on a canvas
    function drawAllLightsOnCanvas(canvas, type) {
        try {
            const ctx = canvas.getContext('2d');
            let lightPositions = [];
            
            // Get light positions for this view type
            if (type === 'aerial') {
                lightPositions = window.aerialLightPositions || [];
            } else if (type === 'capturedStreet') {
                lightPositions = window.capturedStreetLightPositions || [];
            } else {
                lightPositions = window.streetLightPositions || [];
            }
            
            console.log('Drawing', lightPositions.length, 'light sets for', type);
            
            // Draw each set of lights
            lightPositions.forEach((lightSet, setIndex) => {
                console.log('Light set', setIndex, 'has', lightSet.positions.length, 'positions');
                lightSet.positions.forEach((lightPos, posIndex) => {
                    console.log('Drawing light', posIndex, 'at', lightPos.x, lightPos.y);
                    drawLight(ctx, lightPos.x, lightPos.y, type);
                });
            });
            
        } catch (error) {
            console.error('Error drawing lights on canvas:', error);
        }
    }
    
    // Function to draw a single light with animation support
    function drawLight(ctx, x, y, type) {
        try {
            // Get bulb size from user setting (default 1 inch)
            let lightSize = 3; // Much smaller default - 1" should be tiny on screen
            
            if (type === 'aerial') {
                lightSize = (window.aerialBulbSize || 1) * 3; // Scale 1" to 3 pixels for realistic size
            } else if (type === 'capturedStreet' || type === 'street') {
                lightSize = (window.streetBulbSize || 1) * 3; // Scale 1" to 3 pixels for realistic size
            }
            
            // Get current animation mode
            const animationMode = document.getElementById('aerialAnimationMode')?.value || 'static';
            const animationSpeed = parseFloat(document.getElementById('aerialAnimationSpeed')?.value || 5);
            
            // Calculate animation intensity based on mode and time
            let intensity = 1.0;
            let color = '#FFD700'; // Default gold
            
            if (animationMode !== 'static') {
                const time = Date.now() * 0.001 * animationSpeed * 0.1;
                
                switch (animationMode) {
                    case 'twinkle':
                        intensity = 0.3 + 0.7 * Math.sin(time + x * 0.1 + y * 0.1);
                        break;
                    case 'chase':
                        intensity = 0.3 + 0.7 * Math.sin(time + (x + y) * 0.01);
                        break;
                    case 'fade':
                        intensity = 0.4 + 0.6 * Math.sin(time * 0.5);
                        break;
                    case 'rainbow':
                        const hue = (time * 50 + x * 0.1 + y * 0.1) % 360;
                        color = `hsl(${hue}, 100%, 50%)`;
                        break;
                    case 'christmas':
                        intensity = 0.3 + 0.7 * Math.sin(time + x * 0.1);
                        color = intensity > 0.5 ? '#FF0000' : '#00FF00';
                        break;
                    case 'patriotic':
                        intensity = 0.3 + 0.7 * Math.sin(time + y * 0.1);
                        color = intensity > 0.5 ? '#FF0000' : '#0000FF';
                        break;
                    case 'fireworks':
                        intensity = 0.2 + 0.8 * Math.random();
                        color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        break;
                }
            }
            
            // Draw the enhanced light with white core and yellow halo effect
            drawEnhancedLight(ctx, x, y, lightSize * intensity, color);
            
        } catch (error) {
            console.error('Error drawing light:', error);
        }
    }
    
    // Enhanced light drawing function with white core and colored halo
    function drawEnhancedLight(ctx, x, y, size, color) {
        try {
            // Parse the color to determine if it's the default gold or a custom color
            const isDefaultGold = color === '#FFD700' || color === 'gold';
            
            // For default gold, use the beautiful white core with yellow halo
            if (isDefaultGold) {
                // 1. Draw the outer yellow halo (soft, diffused glow)
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = size * 2; // Larger blur for softer halo
                ctx.fillStyle = 'rgba(255, 215, 0, 0.15)'; // Very soft yellow with low opacity
                ctx.beginPath();
                ctx.arc(x, y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 2. Draw the middle yellow glow (medium intensity)
                ctx.shadowBlur = size * 1.2;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.25)'; // Medium yellow with medium opacity
                ctx.beginPath();
                ctx.arc(x, y, size * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // 3. Draw the inner yellow glow (more intense)
                ctx.shadowBlur = size * 0.8;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)'; // More intense yellow
                ctx.beginPath();
                ctx.arc(x, y, size * 1.4, 0, Math.PI * 2);
                ctx.fill();
                
                // 4. Draw the bright white core (the actual light bulb)
                ctx.shadowBlur = 0; // No shadow for the core
                ctx.fillStyle = '#FFFFFF'; // Pure white core
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // 5. Add a subtle inner white glow for extra brightness
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Slightly transparent white
                ctx.beginPath();
                ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // 6. Add a tiny bright center point for maximum intensity
                ctx.fillStyle = '#FFFFFF'; // Pure white center
                ctx.beginPath();
                ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // For custom colors (animations), use the color with enhanced glow
                // 1. Draw the outer colored halo (soft, diffused glow)
                ctx.shadowColor = color;
                ctx.shadowBlur = size * 2; // Larger blur for softer halo
                ctx.fillStyle = color.replace(')', ', 0.15)').replace('rgb', 'rgba'); // Very soft with low opacity
                ctx.beginPath();
                ctx.arc(x, y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 2. Draw the middle colored glow (medium intensity)
                ctx.shadowBlur = size * 1.2;
                ctx.fillStyle = color.replace(')', ', 0.25)').replace('rgb', 'rgba'); // Medium opacity
                ctx.beginPath();
                ctx.arc(x, y, size * 1.8, 0, Math.PI * 2);
                ctx.fill();
                
                // 3. Draw the inner colored glow (more intense)
                ctx.shadowBlur = size * 0.8;
                ctx.fillStyle = color.replace(')', ', 0.4)').replace('rgb', 'rgba'); // More intense
                ctx.beginPath();
                ctx.arc(x, y, size * 1.4, 0, Math.PI * 2);
                ctx.fill();
                
                // 4. Draw the bright colored core (the actual light bulb)
                ctx.shadowBlur = 0; // No shadow for the core
                ctx.fillStyle = color; // Use the actual color
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // 5. Add a subtle inner colored glow for extra brightness
                ctx.fillStyle = color.replace(')', ', 0.8)').replace('rgb', 'rgba'); // Slightly transparent
                ctx.beginPath();
                ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // 6. Add a tiny bright center point for maximum intensity
                ctx.fillStyle = color; // Pure color center
                ctx.beginPath();
                ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
        } catch (error) {
            console.error('Error drawing enhanced light:', error);
        }
    }
    
    // ===== MEASUREMENT FUNCTIONS =====
    // Enhanced measurement calculation with eaves/gables classification is defined later in the file
    
    function getGoogleMapScale() {
        // Get current zoom level and latitude
        const zoom = map.getZoom();
        const center = map.getCenter();
        const lat = center.lat();
        
        // Calculate meters per pixel at current zoom and latitude
        const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
        
        // Convert to feet per pixel
        const feetPerPixel = metersPerPixel * 3.28084;
        
        // Update aerial scale factor
        aerialScaleFactor = feetPerPixel;
        
        console.log(`Zoom: ${zoom}, Lat: ${lat.toFixed(6)}, Scale: ${feetPerPixel.toFixed(6)} ft/pixel`);
        
        // Update zoom status
        const zoomStatus = document.getElementById('zoomStatus');
        if (zoomStatus) {
            zoomStatus.textContent = `Scale: ${feetPerPixel.toFixed(3)} ft/pixel`;
        }
        
        return feetPerPixel;
    }
    
    // ===== PROPERTY LOADING =====
    function loadProperty() {
        const address = document.getElementById('addressInput').value;
        if (!address.trim()) {
            showStatus('Please enter a property address', 'error');
            return;
        }
        
        showStatus('Loading property...', 'loading');
        
        const geocoder = new google.maps.Geocoder();
        geocoder.geocode({ address: address }, (results, status) => {
            if (status === 'OK') {
                const location = results[0].geometry.location;
                currentProperty = {
                    address: address,
                    location: location
                };
                
                // Update map
                map.setCenter(location);
                map.setZoom(21);
                
                // Initialize street view
                initializeStreetView(location);
                
                // Update scale
                setTimeout(() => {
                    getGoogleMapScale();
                }, 1000);
                
                showStatus(`Property loaded: ${address}`, 'success');
            } else {
                showStatus('Could not find property address', 'error');
            }
        });
    }
    
    function initializeStreetView(location) {
        const streetViewService = new google.maps.StreetViewService();
        const radius = 50;
        
        streetViewService.getPanorama({
            location: location,
            radius: radius
        }, (data, status) => {
            if (status === 'OK') {
                const position = data.location.latLng;
                const heading = google.maps.geometry.spherical.computeHeading(position, location);
                
                streetView.setPosition(position);
                streetView.setPov({
                    heading: heading,
                    pitch: 0
                });
                
                showStatus('Street view loaded successfully', 'success');
            } else {
                showStatus('Street view not available for this location', 'warning');
            }
        });
    }
    
    // ===== UTILITY FUNCTIONS =====
    function showStatus(message, type) {
        const statusEl = document.getElementById('propertyStatus');
        statusEl.style.display = 'block';
        statusEl.textContent = message;
        statusEl.className = `status-message status-${type}`;
        
        if (type !== 'loading') {
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }
    }
    
    function applyZoomLevel() {
        const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
        map.setZoom(zoomLevel);
        
        setTimeout(() => {
            getGoogleMapScale();
        }, 500);
    }
    
    function clearAerialDrawing() {
        console.log('ğŸ§¹ Clearing aerial drawing and measurements...');
        
        // Clear canvas
        aerialCtx.clearRect(0, 0, aerialCanvas.width, aerialCanvas.height);
        
        // Clear drawing data
        aerialCanvas.drawingData = {
            paths: [],
            currentPath: [],
            isDrawing: false
        };
        
        // Clear global paths array
        aerialPaths = [];
        
        // Reset measurements COMPLETELY with all properties
        measurements.aerial = { 
            front: 0, 
            leftSide: 0, 
            rightSide: 0, 
            back: 0, 
            perimeter: 0, 
            eaves: 0, 
            gables: 0 
        };
        
        // Update display elements with safety checks
        const aerialPerimeter = document.getElementById('aerialPerimeter');
        const aerialEaves = document.getElementById('aerialEaves');
        const aerialGables = document.getElementById('aerialGables');
        
        if (aerialPerimeter) aerialPerimeter.textContent = '0';
        if (aerialEaves) aerialEaves.textContent = '0';
        if (aerialGables) aerialGables.textContent = '0';
        
        // Clear light overlay
        const lightCanvas = document.getElementById('aerialLightOverlay');
        if (lightCanvas) {
            const lightCtx = lightCanvas.getContext('2d');
            lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
        }
        
        // Clear stored light positions
        if (window.aerialLightPositions) {
            window.aerialLightPositions = [];
        }
        
        // Update all systems
        updateLightVisualization();
        updatePricing();
        
        console.log('âœ… Aerial drawing and measurements cleared completely');
    }
    
    function clearStreetDrawing() {
        console.log('ğŸ§¹ Clearing street drawing and measurements...');
        
        // Clear canvas
        streetCtx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
        
        // Clear drawing data
        streetCanvas.drawingData = {
            paths: [],
            currentPath: [],
            isDrawing: false
        };
        
        // Clear global paths array
        capturedStreetPaths = [];
        
        // Reset measurements COMPLETELY
        measurements.street = { 
            front: 0, 
            leftSide: 0, 
            rightSide: 0, 
            back: 0, 
            total: 0, 
            eaves: 0, 
            gables: 0 
        };
        
        // Update display elements with safety checks
        const streetTotal = document.getElementById('streetTotal');
        const streetEaves = document.getElementById('streetEaves');
        const streetGables = document.getElementById('streetGables');
        const streetScaleSection = document.getElementById('streetScaleSection');
        
        if (streetTotal) streetTotal.textContent = '0';
        if (streetEaves) streetEaves.textContent = '0';
        if (streetGables) streetGables.textContent = '0';
        if (streetScaleSection) streetScaleSection.style.display = 'none';
        
        // Clear light overlays
        const lightCanvases = ['streetLightOverlay', 'capturedStreetLightOverlay'];
        lightCanvases.forEach(canvasId => {
            const lightCanvas = document.getElementById(canvasId);
            if (lightCanvas) {
                const lightCtx = lightCanvas.getContext('2d');
                lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
            }
        });
        
        // Clear stored light positions
        if (window.streetLightPositions) {
            window.streetLightPositions = [];
        }
        if (window.capturedStreetLightPositions) {
            window.capturedStreetLightPositions = [];
        }
        
        // Update all systems
        updateLightVisualization();
        updatePricing();
        
        console.log('âœ… Street drawing and measurements cleared completely');
    }
    
    function clearAllDrawings() {
        console.log('ğŸ§¹ Clearing ALL drawings and measurements...');
        
        // Clear aerial and street drawings (which now clear measurements too)
        clearAerialDrawing();
        clearStreetDrawing();
        
        // Clear any remaining global arrays
        aerialPaths = [];
        capturedStreetPaths = [];
        
        // Reset any other measurement-related variables
        streetScaleFactor = 0.1; // Reset to default
        
        // Stop light animation
        stopLightAnimation();
        
        // Force update all displays
        updateLightVisualization();
        updatePricing();
        
        showStatus('All drawings and measurements cleared completely', 'success');
        console.log('âœ… ALL drawings and measurements cleared completely');
    }
    
    // View display functions for aerial view
    function showAerialLines() {
        try {
            // Show only the measurement lines
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas && aerialCanvas.drawingData) {
                // Redraw all paths normally
                redrawAllPaths(aerialCanvas, aerialCtx, 'aerial');
            }
            
            // Clear any light overlays
            const lightOverlay = document.getElementById('aerialLightOverlay');
            if (lightOverlay) {
                const ctx = lightOverlay.getContext('2d');
                ctx.clearRect(0, 0, lightOverlay.width, lightOverlay.height);
            }
            
            console.log('Aerial view: Lines only');
        } catch (error) {
            console.error('Error showing aerial lines:', error);
        }
    }
    
    // DISABLED: Old view toggle system - now using new light placement system
    // function showAerialLights() {
    //     try {
    //         // Show lines + lights
    //         const aerialCanvas = document.getElementById('aerialCanvas');
    //         if (aerialCanvas && aerialCanvas.drawingData) {
    //             redrawAllPaths(aerialCanvas, aerialCtx, 'aerial');
    //         }
    //         
    //         // Draw lights on the overlay
    //         const lightOverlay = document.getElementById('aerialLightOverlay');
    //         if (lightOverlay) {
    //         const ctx = lightOverlay.getContext('2d');
    //         const rect = lightOverlay.getBoundingClientRect();
    //         lightOverlay.width = rect.width;
    //         lightOverlay.height = rect.height;
    //         drawAerialLights(ctx, lightOverlay.width, lightOverlay.height, 0.8);
    //         }
    //         
    //         console.log('Aerial view: Lines + Lights');
    //     } catch (error) {
    //         console.error('Error showing aerial lights:', error);
    //     }
    // }
    
    function showAerialFinal() {
        try {
            // Show lines + lights (no dark mode)
            showAerialLights();
            
            console.log('Aerial view: Final render with lights');
        } catch (error) {
            console.error('Error showing aerial final:', error);
        }
    }
    
    // View display functions for street view
    function showStreetLines() {
        try {
            // Show only the measurement lines
            const capturedCanvas = document.getElementById('capturedStreetCanvas');
            if (capturedCanvas && capturedCanvas.drawingData) {
                // Redraw all paths normally
                redrawAllPaths(capturedCanvas, streetCtx, 'street');
            }
            
            // Clear any light overlays
            const lightOverlay = document.getElementById('capturedStreetLightOverlay');
            if (lightOverlay) {
                const ctx = lightOverlay.getContext('2d');
                ctx.clearRect(0, 0, lightOverlay.width, lightOverlay.height);
            }
            
            // Reset any night effects
            const streetContainer = document.getElementById('streetContainer');
            if (streetContainer) {
                streetContainer.style.filter = 'none';
            }
            
            console.log('Street view: Lines only');
        } catch (error) {
            console.error('Error showing street lines:', error);
        }
    }
    
    // DISABLED: Old view toggle system - now using new light placement system
    // function showStreetLights() {
    //     try {
    //         // Show lines + lights
    //         const capturedCanvas = document.getElementById('capturedStreetCanvas');
    //         if (capturedCanvas && capturedCanvas.drawingData) {
    //         redrawAllPaths(capturedCanvas, streetCtx, 'street');
    //         }
    //         
    //         // Draw lights on the overlay
    //         const lightOverlay = document.getElementById('capturedStreetLightOverlay');
    //         if (lightOverlay) {
    //         const ctx = lightOverlay.getContext('2d');
    //         const rect = lightOverlay.getBoundingClientRect();
    //         lightOverlay.width = rect.width;
    //         lightOverlay.height = rect.height;
    //         drawStreetLights(ctx, lightOverlay.width, lightOverlay.height, 0.8);
    //         }
    //         
    //         console.log('Street view: Lines + Lights');
    //     } catch (error) {
    //         console.error('Error showing street lights:', error);
    //     }
    // }
    
    function showStreetFinal() {
        try {
            // Show lines + lights (no dark mode)
            showStreetLights();
            
            console.log('Street view: Final render with lights');
        } catch (error) {
            console.error('Error showing street final:', error);
        }
    }
    
    // View functions for showing measurement labels
    function showAerialLabels() {
        try {
            // Show lines + measurement labels
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas && aerialCanvas.drawingData) {
                redrawAllPaths(aerialCanvas, aerialCtx, 'aerial');
                
                // Draw measurement labels
                drawMeasurementLabels(aerialCanvas, aerialCtx, 'aerial');
            }
            
            // Clear any light overlays
            const lightOverlay = document.getElementById('aerialLightOverlay');
            if (lightOverlay) {
                const ctx = lightOverlay.getContext('2d');
                ctx.clearRect(0, 0, lightOverlay.width, lightOverlay.height);
            }
            
            console.log('Aerial view: Lines + Labels');
        } catch (error) {
            console.error('Error showing aerial labels:', error);
        }
    }
    
    function showStreetLabels() {
        try {
            // Show lines + measurement labels
            const capturedCanvas = document.getElementById('capturedStreetCanvas');
            if (capturedCanvas && capturedCanvas.drawingData) {
                redrawAllPaths(capturedCanvas, streetCtx, 'street');
                
                // Draw measurement labels
                drawMeasurementLabels(capturedCanvas, streetCtx, 'street');
            }
            
            // Clear any light overlays
            const lightOverlay = document.getElementById('capturedStreetLightOverlay');
            if (lightOverlay) {
                const ctx = lightOverlay.getContext('2d');
                ctx.clearRect(0, 0, lightOverlay.width, lightOverlay.height);
            }
            
            // Reset any night effects
            const streetContainer = document.getElementById('streetContainer');
            if (streetContainer) {
                streetContainer.style.filter = 'none';
            }
            
            console.log('Street view: Lines + Labels');
        } catch (error) {
            console.error('Error showing street labels:', error);
        }
    }
    
    function updateCurrentModeStatus() {
        const statusDiv = document.getElementById('currentModeStatus');
        const statusText = document.getElementById('currentModeStatusText');
        
        if (!statusDiv || !statusText) return;
        
        if (drawingMode === 'mixed') {
            statusDiv.style.display = 'block';
            statusText.innerHTML = 'ğŸ”„ <strong>Mixed Mode Active:</strong> You can now use both straight lines and freehand drawing on the same image!';
        } else {
            statusDiv.style.display = 'none';
        }
    }
    
    function updateMixedModeIndicator(currentMode) {
        const indicator = document.getElementById('mixedModeIndicator');
        const indicatorText = document.getElementById('mixedModeIndicatorText');
        
        if (!indicator || !indicatorText) return;
        
        if (drawingMode === 'mixed') {
            indicator.style.display = 'block';
            if (currentMode === 'straight') {
                indicatorText.innerHTML = 'ğŸ“ Straight Line Mode';
            } else if (currentMode === 'freehand') {
                indicatorText.innerHTML = 'âœ‹ Freehand Mode';
            }
        } else {
            indicator.style.display = 'none';
        }
    }
    
    function applyStreetScale() {
        const scaleInput = document.getElementById('streetScaleInput');
        const referenceWidth = parseFloat(scaleInput.value);
        
        if (!referenceWidth || referenceWidth <= 0) {
            alert('Please enter a valid reference width');
            return;
        }
        
        // Calculate scale based on last drawn line
        const paths = streetCanvas.drawingData.paths;
        if (paths.length === 0) {
            alert('Please draw a reference line first');
            return;
        }
        
        const lastPath = paths[paths.length - 1];
        let lineLength = 0;
        
        for (let i = 1; i < lastPath.length; i++) {
            const dx = lastPath[i].x - lastPath[i-1].x;
            const dy = lastPath[i].y - lastPath[i-1].y;
            lineLength += Math.sqrt(dx * dx + dy * dy);
        }
        
        if (lineLength > 0) {
            streetScaleFactor = referenceWidth / lineLength;
            
            // Remove the reference line from paths (don't count it in measurements)
            paths.pop();
            
            // Recalculate measurements
            calculateMeasurementsFromPaths(streetCanvas, 'street');
            
            showStatus(`Scale calibrated: ${referenceWidth}ft reference`, 'success');
        }
    }
    
    // ===== LIGHT VISUALIZATION =====
    // Background images for toggle system (initialized elsewhere)
    
    function updateLightVisualization() {
        console.log('ğŸ”„ updateLightVisualization() called');
        console.log('Current measurements object:', measurements);
        
        // Ensure measurements object exists
        if (!measurements.aerial) {
            measurements.aerial = { perimeter: 0, front: 0, leftSide: 0, rightSide: 0, back: 0 };
        }
        if (!measurements.street) {
            measurements.street = { total: 0, front: 0, leftSide: 0, rightSide: 0, back: 0 };
        }
        
        // Use the bid total footage if available, otherwise fall back to combined measurements
        let totalFeet = window.bidTotalFeet || 0;
        if (totalFeet === 0) {
            const aerialTotal = measurements.aerial.perimeter || 0;
            const streetTotal = measurements.street.total || 0;
            totalFeet = aerialTotal + streetTotal;
        }
        
        // Get spacing from aerial or street light controls (they should be synced)
        const aerialSpacing = parseFloat(document.getElementById('aerialLightSpacing')?.value || 8);
        const streetSpacing = parseFloat(document.getElementById('streetLightSpacing')?.value || 8);
        const spacing = aerialSpacing || streetSpacing || 8; // Default to 8 inches
        
        console.log('Light calculation values:', {
            totalFeet,
            spacing,
            bidTotalFeet: window.bidTotalFeet
        });
        
        // Calculate lights needed (convert spacing from inches to feet)
        const spacingFeet = spacing / 12;
        const totalLights = totalFeet > 0 ? Math.ceil(totalFeet / spacingFeet) : 0;
        
        // Get waste factor from user input
        const wasteFactorPercent = parseFloat(document.getElementById('wasteFactor')?.value || 10);
        const wasteFactor = 1 + (wasteFactorPercent / 100);
        const lightsWithWaste = Math.ceil(totalLights * wasteFactor);
        
        // Update display elements
        const totalLightsElement = document.getElementById('totalLights');
        const lightsWithWasteElement = document.getElementById('lightsWithWaste');
        
        if (totalLightsElement) totalLightsElement.textContent = totalLights;
        if (lightsWithWasteElement) lightsWithWasteElement.textContent = lightsWithWaste;
        
        console.log('Light calculations updated:', {
            totalFeet,
            spacing,
            spacingFeet,
            totalLights,
            lightsWithWaste
        });
        
        // Calculate bid total and update pricing
        calculateBidTotal();
        updatePricing();
    }
    
    // Debug function to test light calculations
    function debugLightCalculations() {
        console.log('=== DEBUG LIGHT CALCULATIONS ===');
        console.log('Measurements object:', measurements);
        console.log('Aerial measurements:', measurements.aerial);
        console.log('Street measurements:', measurements.street);
        console.log('Street scale factor:', streetScaleFactor);
        console.log('Captured street paths:', capturedStreetPaths);
        
        if (measurements.street && measurements.street.total > 0) {
            console.log('âœ… Street measurements found:', measurements.street.total, 'feet');
        } else {
            console.log('âŒ No street measurements found');
        }
        
        if (measurements.aerial && measurements.aerial.perimeter > 0) {
            console.log('âœ… Aerial measurements found:', measurements.aerial.perimeter, 'feet');
        } else {
            console.log('âŒ No aerial measurements found');
        }
    }
    
    // Debug function to test aerial measurements
    function debugAerialMeasurements() {
        console.log('=== DEBUG AERIAL MEASUREMENTS ===');
        console.log('Current aerial side:', getCurrentAerialSide());
        console.log('Aerial paths:', aerialCanvas?.drawingData?.paths);
        console.log('Aerial scale factor:', aerialScaleFactor);
        console.log('Aerial measurements:', measurements.aerial);
        
        if (measurements.aerial && measurements.aerial.perimeter > 0) {
            console.log('âœ… Aerial perimeter:', measurements.aerial.perimeter, 'ft');
            console.log('âœ… Aerial eaves:', measurements.aerial.eaves, 'ft');
            console.log('âœ… Aerial gables:', measurements.aerial.gables, 'ft');
        } else {
            console.log('âŒ No aerial measurements found');
        }
    }
    
    // NEW: Apply Street View Lines function
    function applyStreetViewLines() {
        try {
            console.log('ğŸ”„ Applying Street View lines...');
            
            if (!capturedStreetPaths || capturedStreetPaths.length === 0) {
                showStatus('No lines drawn yet. Please draw some lines first.', 'warning');
                return;
            }
            
            // Calculate measurements from all drawn paths
            let totalFeet = 0;
            const currentSide = getCurrentStreetSide();
            
            capturedStreetPaths.forEach((path, pathIndex) => {
                if (path && path.length >= 2) {
                    let pathLength = 0;
                    
                    for (let i = 1; i < path.length; i++) {
                        const dx = path[i].x - path[i-1].x;
                        const dy = path[i].y - path[i-1].y;
                        const segmentLength = Math.sqrt(dx * dx + dy * dy);
                        pathLength += segmentLength;
                    }
                    
                    const pathFeet = pathLength * streetScaleFactor;
                    totalFeet += pathFeet;
                    
                    console.log(`Path ${pathIndex + 1}: ${pathLength.toFixed(2)} pixels = ${pathFeet.toFixed(2)} feet`);
                }
            });
            
            // Add to existing measurement for this side
            if (!measurements.street) {
                measurements.street = { front: 0, leftSide: 0, rightSide: 0, back: 0, total: 0, eaves: 0, gables: 0 };
            }
            
            const existingMeasurement = measurements.street[currentSide] || 0;
            measurements.street[currentSide] = Math.round(existingMeasurement + totalFeet);
            
            // Recalculate total from all sides
            measurements.street.total = (measurements.street.front || 0) + 
                                      (measurements.street.leftSide || 0) + 
                                      (measurements.street.rightSide || 0) + 
                                      (measurements.street.back || 0);
            
            // Update eaves and gables based on total
            measurements.street.eaves = Math.round(measurements.street.total * 0.8);
            measurements.street.gables = Math.round(measurements.street.total * 0.2);
            
            console.log(`âœ… Street View ${currentSide} side: ${totalFeet.toFixed(1)} ft added, Total: ${measurements.street.total} ft`);
            
            // Update all displays
            updateStreetDisplay();
            updateCombinedMeasurements();
            calculateBidTotal();
            updateLightVisualization();
            updatePricing();
            
            showStatus(`Street View lines applied! ${currentSide} side: +${totalFeet.toFixed(1)} ft, Total: ${measurements.street.total} ft`, 'success');
            
        } catch (error) {
            console.error('Error applying street view lines:', error);
            showStatus('Error applying lines: ' + error.message, 'error');
        }
    }
    
    // Function to update light calculations when waste factor changes
    function updateLightCalculations() {
        updateLightVisualization();
    }
    
    // Toggle functions for light preview
    let aerialLightsShown = false;
    let streetLightsShown = false;
    

    

    
    // Function to draw lights on actual measurement paths
    function drawLightsOnActualPaths(ctx, width, height, type) {
        try {
            if (!measurements[type] || !measurements[type].segments) {
                console.log('No segments found for', type);
                return;
            }
            
            const segments = measurements[type].segments;
            const spacing = parseFloat(document.getElementById('lightSpacing')?.value || 12) / 12; // Convert inches to feet
            const lightSize = 3;
            
            ctx.save();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 10;
            
            segments.forEach(segment => {
                if (segment.start && segment.end) {
                    // Convert feet to pixels (approximate)
                    const scaleFactor = type === 'aerial' ? aerialScaleFactor : streetScaleFactor;
                    const pixelSpacing = Math.max(5, (spacing * scaleFactor) * 10); // Convert to reasonable pixel spacing
                    
                    // Draw the measurement line
                    ctx.beginPath();
                    ctx.moveTo(segment.start.x, segment.start.y);
                    ctx.lineTo(segment.end.x, segment.end.y);
                    ctx.stroke();
                    
                    // Calculate light positions along this line
                    const dx = segment.end.x - segment.start.x;
                    const dy = segment.end.y - segment.start.y;
                    const lineLength = Math.sqrt(dx * dx + dy * dy);
                    const numLights = Math.floor(lineLength / pixelSpacing);
                    
                    // Draw lights along the line
                    for (let i = 0; i <= numLights; i++) {
                        const t = i / numLights;
                        const x = segment.start.x + dx * t;
                        const y = segment.start.y + dy * t;
                        
                        // Draw enhanced light with white core and yellow halo
                        drawEnhancedLight(ctx, x, y, lightSize, '#FFD700');
                    }
                }
            });
            
            ctx.restore();
            console.log('Drew lights on actual paths for', type, 'with', segments.length, 'segments');
            
        } catch (error) {
            console.error('Error drawing lights on actual paths:', error);
        }
    }
    

    let aerialAnimationActive = false;
    let streetAnimationActive = false;
    let aerialAnimationId = null;
    let streetAnimationId = null;
    

    

    

    

    

    

    
    // Background capture functions for toggle system
    function captureAerialToggleBackground() {
        captureAerialTransitionBackground();
    }
    
    function updateAerialToggleBackground() {
        updateAerialTransitionBackground();
    }
    
    function captureStreetToggleBackground() {
        captureStreetTransitionBackground();
    }
    
    function updateStreetToggleBackground() {
        updateStreetTransitionBackground();
    }
    
    // Simplified light management for new toggle system
    function startLightAnimation() {
        // This function is now handled by the view toggle system
        console.log('Light animation managed by view toggles');
    }
    
    function stopLightAnimation() {
        // This function is now handled by the view toggle system
        console.log('Light animation managed by view toggles');
    }
    
    function clearLightOverlays() {
        try {
            // Clear aerial light overlay
            const aerialCanvas = document.getElementById('aerialLightOverlay');
            if (aerialCanvas) {
                const ctx = aerialCanvas.getContext('2d');
                ctx.clearRect(0, 0, aerialCanvas.width, aerialCanvas.height);
            }
            
            // Clear street light overlays
            const streetCanvas = document.getElementById('streetLightOverlay');
            if (streetCanvas) {
                const ctx = streetCanvas.getContext('2d');
                ctx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
            }
            
            const capturedStreetCanvas = document.getElementById('capturedStreetLightOverlay');
            if (capturedStreetCanvas) {
                const ctx = capturedStreetCanvas.getContext('2d');
                ctx.clearRect(0, 0, capturedStreetCanvas.width, capturedStreetCanvas.height);
            }
            
            console.log('Light overlays cleared');
        } catch (error) {
            console.error('Error clearing light overlays:', error);
        }
    }
    
    function debugStreetViewCanvas() {
        try {
            const canvas = document.getElementById('capturedStreetCanvas');
            if (!canvas) {
                console.log('âŒ Captured Street View canvas not found');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            console.log('ğŸ” Street View Canvas Debug Info:', {
                canvasId: canvas.id,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                rectWidth: rect.width,
                rectHeight: rect.height,
                rectLeft: rect.left,
                rectTop: rect.top,
                scaleX: canvas.width / rect.width,
                scaleY: canvas.height / rect.height,
                position: canvas.style.position,
                zIndex: canvas.style.zIndex,
                display: canvas.style.display
            });
            
            // Show a visual indicator of canvas boundaries
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // Add text labels
            ctx.fillStyle = '#00ff00';
            ctx.font = '16px Arial';
            ctx.fillText('Canvas Boundary', 10, 20);
            ctx.fillText(`Size: ${canvas.width}x${canvas.height}`, 10, 40);
            
            console.log('âœ… Canvas boundary highlighted in green');
            
        } catch (error) {
            console.error('Error debugging street view canvas:', error);
        }
    }
    
    // DISABLED: Old light animation system - now using new light placement system
    // function animateLights() {
    //     try {
    //         lightAnimationFrame++;
    //         
    //         // Safety check: stop animation after too many frames to prevent infinite loops
    //         if (lightAnimationFrame > 10000) {
    //             console.warn('Animation frame limit reached, stopping light animation');
    //             if (lightAnimationId) {
    //                 cancelAnimationFrame(lightAnimationId);
    //                 lightAnimationId = null;
    //             }
    //             return;
    //         }
    //         
    //         // Check if page is visible to save resources
    //         if (document.hidden) {
    //             // Page is hidden, continue animation but don't draw
    //             lightAnimationId = requestAnimationFrame(animateLights);
    //             return;
    //         }
    //         
    //         // Get the appropriate canvas for aerial view
    //         const aerialCanvas = document.getElementById('aerialLightOverlay');
    //         if (aerialCanvas) {
    //             const ctx = aerialCanvas.getContext('2d');
    //             const rect = aerialCanvas.getBoundingClientRect();
    //         
    //             // Set canvas size to match container
    //             aerialCanvas.width = rect.width;
    //             aerialCanvas.height = rect.height;
    //         
    //             // Draw lights on aerial view with proper parameters
    //             drawAerialLights(ctx, aerialCanvas.width, aerialCanvas.height, 0.8);
    //         }
    //         
    //         // Draw lights on street view
    //         drawStreetLights();
    //         
    //         // Continue animation
    //         lightAnimationId = requestAnimationFrame(animateLights);
    //     } catch (error) {
    //         console.error('Error in animateLights:', error);
    //         // Stop animation on error
    //         if (lightAnimationId) {
    //             cancelAnimationFrame(lightAnimationId);
    //             lightAnimationId = null;
    //         }
    //     }
    // }
    
    // DISABLED: Old light drawing system - now using new light placement system
    // function drawAerialLights() {
    //     const canvas = document.getElementById('aerialLightOverlay');
    //     if (!canvas) return;
    //     
    //     const ctx = canvas.getContext('2d');
    //     const rect = canvas.getBoundingClientRect();
    //     
    //     // Set canvas size to match container
    //     canvas.width = rect.width;
    //     canvas.height = rect.height;
    //     
    //     // Clear canvas
    //     canvas.height = rect.height;
    //     
    //     // Get aerial measurements
    //     if (measurements.aerial && measurements.aerial.perimeter > 0) {
    //         drawLightsOnCanvas(ctx, canvas.width, canvas.height, measurements.aerial.perimeter, 'aerial', false);
    //     }
    // }
    // 
    // function drawStreetLights() {
    //     // Draw on live street view
    //     const liveCanvas = document.getElementById('streetLightOverlay');
    //     if (liveCanvas) {
    //         const ctx = liveCanvas.getContext('2d');
    //         const rect = liveCanvas.getBoundingClientRect();
    //     
    //         liveCanvas.width = rect.width;
    //         liveCanvas.height = rect.height;
    //         ctx.clearRect(0, 0, liveCanvas.width, liveCanvas.height);
    //     
    //         if (measurements.street && measurements.street.total > 0) {
    //         drawLightsOnCanvas(ctx, liveCanvas.width, liveCanvas.height, measurements.street.total, 'street', false);
    //     }
    //     }
    //     
    //     // Draw on captured street view if visible
    //     const capturedCanvas = document.getElementById('capturedStreetLightOverlay');
    //     if (capturedCanvas && document.getElementById('capturedStreetViewContainer').style.display !== 'none') {
    //         const ctx = capturedCanvas.getContext('2d');
    //         const rect = capturedCanvas.getBoundingClientRect();
    //     
    //         capturedCanvas.width = rect.width;
    //         capturedCanvas.height = rect.height;
    //         ctx.clearRect(0, 0, capturedCanvas.width, capturedCanvas.height);
    //     
    //         if (measurements.street && measurements.street.total > 0) {
    //         drawLightsOnCanvas(ctx, capturedCanvas.width, capturedCanvas.height, measurements.street.total, 'street', false);
    //     }
    //     }
    // }
    
    function drawLightsOnCanvas(ctx, width, height, totalFeet, viewType, isPreview = false) {
        console.log('drawLightsOnCanvas called with:', { width, height, totalFeet, viewType, isPreview });
        
        const spacing = parseFloat(document.getElementById('lightSpacing').value);
        const spacingFeet = spacing / 12;
        const animationSpeed = parseFloat(document.getElementById('animationSpeed')?.value || 1);
        const colorScheme = document.getElementById('colorScheme')?.value || 'white';
        
        console.log('Light settings:', { spacing, spacingFeet, animationSpeed, colorScheme });
        
        // Calculate number of lights based on actual spacing
        const numLights = Math.ceil(totalFeet / spacingFeet);
        console.log('Number of lights to draw:', numLights);
        
        // Get color palette
        const colors = getColorPalette(colorScheme);
        console.log('Color palette:', colors);
        
        // Adjust light sizes based on whether this is a preview
        const outerGlowRadius = isPreview ? 20 : 8;
        const lightRadius = isPreview ? 12 : 5;
        const innerGlowRadius = isPreview ? 6 : 2;
        const centerRadius = isPreview ? 3 : 1;
        const shadowBlur = isPreview ? 40 : 20;
        
        // Calculate actual spacing between lights in pixels
        const totalPixels = width;
        const pixelsPerLight = totalPixels / numLights;
        
        console.log('Spacing calculation:', { totalPixels, pixelsPerLight, spacingFeet });
        
        // Draw lights with proper spacing
        for (let i = 0; i < numLights; i++) {
            // Calculate position based on actual spacing, not progress
            const baseX = (i * pixelsPerLight) + (pixelsPerLight / 2);
            const animationOffset = (lightAnimationFrame * 0.01 * animationSpeed) % pixelsPerLight;
            const x = (baseX + animationOffset) % width;
            
            // Add some wave effect to Y position
            let y;
            if (viewType === 'aerial') {
                y = 30 + Math.sin((i * 0.5) + (lightAnimationFrame * 0.05)) * 8;
            } else {
                y = 25 + Math.sin((i * 0.3) + (lightAnimationFrame * 0.03)) * 6;
            }
            
            // Choose color based on light index and animation
            const colorIndex = (i + Math.floor(lightAnimationFrame * 0.1)) % colors.length;
            const color = colors[colorIndex];
            
            console.log(`Drawing light ${i + 1}/${numLights} at (${x.toFixed(1)}, ${y.toFixed(1)}) with color ${color}`);
            
            // Draw light with enhanced glow effect
            ctx.save();
            ctx.shadowColor = color;
            ctx.shadowBlur = shadowBlur;
            
            // Outer glow
            ctx.beginPath();
            ctx.arc(x, y, outerGlowRadius, 0, Math.PI * 2);
            ctx.fillStyle = color + '40'; // Semi-transparent
            ctx.fill();
            
            // Light circle
            ctx.beginPath();
            ctx.arc(x, y, lightRadius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            
            // Inner glow
            ctx.beginPath();
            ctx.arc(x, y, innerGlowRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            
            // Bright center
            ctx.beginPath();
            ctx.arc(x, y, centerRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            
            ctx.restore();
        }
        
        console.log('All lights drawn successfully');
    }
    
    function getColorPalette(scheme) {
        console.log('getColorPalette called with scheme:', scheme);
        
        switch(scheme) {
            case 'rgbw':
                return ['#ff0000', '#00ff00', '#0000ff', '#ffffff'];
            case 'rwb':
                return ['#ff0000', '#ffffff', '#0000ff'];
            case 'christmas':
                return ['#ff0000', '#00ff00', '#ffffff'];
            case 'halloween':
                return ['#ff8c00', '#800080', '#000000'];
            case 'easter':
                return ['#ffb6c1', '#98fb98', '#87ceeb', '#dda0dd'];
            case 'warm':
                return ['#ffd700', '#ffb347', '#ff8c00'];
            case 'cool':
                return ['#87ceeb', '#b0e0e6', '#add8e6'];
            case 'custom':
                // Get custom colors from the custom color inputs
                const customColors = [];
                for (let i = 1; i <= 4; i++) {
                    const colorInput = document.getElementById(`customColor${i}`);
                    if (colorInput) {
                        customColors.push(colorInput.value);
                    }
                }
                return customColors.length > 0 ? customColors : ['#ffffff'];
            default:
                console.log('Unknown color scheme, using default white');
                return ['#ffffff', '#f0f0f0', '#e0e0e0'];
        }
    }
    
    function stopLightAnimation() {
        if (lightAnimationId) {
            cancelAnimationFrame(lightAnimationId);
            lightAnimationId = null;
        }
    }
    
    function clearLightOverlays() {
        const canvases = [
            'aerialLightOverlay',
            'streetLightOverlay', 
            'capturedStreetLightOverlay'
        ];
        
        canvases.forEach(canvasId => {
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });
    }
    
    function updatePricing() {
        try {
            // Use the bid total footage if available, otherwise fall back to combined measurements
            let totalFeet = window.bidTotalFeet || 0;
            if (totalFeet === 0) {
                const aerialPerimeter = measurements.aerial?.perimeter || 0;
                const streetTotal = measurements.street?.total || 0;
                totalFeet = aerialPerimeter + streetTotal;
            }
            
            console.log('Pricing calculation - Total feet:', totalFeet, 'Bid total feet:', window.bidTotalFeet);
            
            // Get pricing elements safely using the correct IDs
            const retailPriceElement = document.getElementById('retailPrice');
            const salePriceElement = document.getElementById('salePrice');
            const controllerCostElement = document.getElementById('controllerCost');
            const extraDiscountElement = document.getElementById('extraDiscount');
            const retailTotalElement = document.getElementById('retailTotal');
            const saleTotalElement = document.getElementById('saleTotal');
            const extraDiscountDisplayElement = document.getElementById('extraDiscountDisplay');
            const totalSavingsElement = document.getElementById('totalSavings');
            
            // Only proceed if all required elements exist
            if (retailPriceElement && salePriceElement && controllerCostElement && 
                retailTotalElement && saleTotalElement && extraDiscountDisplayElement && totalSavingsElement) {
                
                const retailPrice = parseFloat(retailPriceElement.value) || 35;
                const salePrice = parseFloat(salePriceElement.value) || 22;
                const controllerCost = parseFloat(controllerCostElement.value) || 300;
                const extraDiscount = parseFloat(extraDiscountElement?.value || 0);
                
                const retailTotal = (totalFeet * retailPrice) + controllerCost;
                const saleTotal = (totalFeet * salePrice) + controllerCost;
                const finalSaleTotal = saleTotal - extraDiscount;
                const totalSavings = retailTotal - finalSaleTotal;
                
                retailTotalElement.textContent = `$${retailTotal.toFixed(0)}`;
                saleTotalElement.textContent = `$${finalSaleTotal.toFixed(0)}`;
                extraDiscountDisplayElement.textContent = `$${extraDiscount.toFixed(0)}`;
                totalSavingsElement.textContent = `$${totalSavings.toFixed(0)}`;
                
                console.log('Pricing updated:', { 
                    totalFeet, 
                    retailPrice, 
                    salePrice, 
                    controllerCost, 
                    extraDiscount,
                    retailTotal, 
                    saleTotal: finalSaleTotal, 
                    totalSavings 
                });
            } else {
                console.log('Pricing elements not found, skipping update. Missing:', {
                    retailPrice: !!retailPriceElement,
                    salePrice: !!salePriceElement,
                    controllerCost: !!controllerCostElement,
                    retailTotal: !!retailTotalElement,
                    saleTotal: !!saleTotalElement,
                    extraDiscountDisplay: !!extraDiscountDisplayElement,
                    totalSavings: !!totalSavingsElement
                });
            }
        } catch (error) {
            console.error('Error updating pricing:', error);
        }
    }
    
    // ===== NIGHT VISUALIZATION =====
    function showAerialVisualization() {
        // Placeholder for aerial night visualization
        alert('Aerial night visualization coming soon! This will show a darkened aerial view with animated lights.');
    }
    
    function showStreetVisualization() {
        // Placeholder for street night visualization
        alert('Street night visualization coming soon! This will show a darkened street view with animated lights.');
    }
    
    function closeNightVisualization() {
        document.getElementById('nightVisualizationModal').style.display = 'none';
    }
    
    // ===== SIGNATURE AND CHECKOUT =====
    function clearSignature() {
        const canvas = document.getElementById('signatureCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    function finalizeOrder() {
        const customerName = document.getElementById('customerName').value;
        const customerEmail = document.getElementById('customerEmail').value;
        const customerPhone = document.getElementById('customerPhone').value;
        const termsAccepted = document.getElementById('termsAccepted').checked;
        
        if (!customerName || !customerEmail || !customerPhone) {
            alert('Please fill in all customer information');
            return;
        }
        
        if (!termsAccepted) {
            alert('Please accept the terms and conditions');
            return;
        }
        
        // Create order data
        const orderData = {
            customer: { name: customerName, email: customerEmail, phone: customerPhone },
            property: currentProperty,
            measurements: measurements,
            pricing: {
                retailTotal: document.getElementById('retailTotal').textContent,
                saleTotal: document.getElementById('saleTotal').textContent,
                savings: document.getElementById('savings').textContent
            },
            lights: {
                total: document.getElementById('totalLights').textContent,
                withWaste: document.getElementById('lightsWithWaste').textContent,
                spacing: document.getElementById('lightSpacing').value,
                colorScheme: currentColorScheme,
                animation: currentAnimationMode
            },
            timestamp: new Date().toISOString()
        };
        
        console.log('Order Data:', orderData);
        alert('Order completed successfully! Contract generation coming soon.');
    }
    
    // Initialize when Google Maps API is loaded
    function initMap() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGoogleMaps);
        } else {
            initializeGoogleMaps();
        }
    }
    
    // DISABLED: Old light animation system - now using new light placement system
    // function startLightAnimationIfNeeded() {
    //     const totalFeet = (measurements.aerial?.perimeter || 0) + (measurements.street?.total || 0);
    //     if (totalFeet > 0) {
    //         startLightAnimation();
    //     }
    // }
    
    // ===== ENHANCED DRAWING AND MEASUREMENT SYSTEM =====
    
    // Enhanced path management
    let capturedStreetPaths = []; // Add captured street paths
    let currentDrawingPath = [];
    let isCurrentlyDrawing = false;
    
    // Side-specific measurement system
    let sideMeasurements = {
        front: { source: 'street', eaves: 0, gables: 0 },
        left: { source: 'aerial', eaves: 0, gables: 0 },
        right: { source: 'aerial', eaves: 0, gables: 0 },
        back: { source: 'aerial', eaves: 0, gables: 0 }
    };
    
    // Enhanced drawing functions
    function startDrawing(e, canvas, ctx, type) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        isCurrentlyDrawing = true;
        currentDrawingPath = [{ x, y, timestamp: Date.now() }];
        
        // Add drawing-active class to prevent screen movement
        document.body.classList.add('drawing-active');
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        
        // Visual feedback - use light color instead of red
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
    }
    
    function continueDrawing(e, canvas, ctx, type) {
        if (!isCurrentlyDrawing) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        currentDrawingPath.push({ x, y, timestamp: Date.now() });
        
        ctx.lineTo(x, y);
        ctx.stroke();
    }
    
    function endDrawing(e, canvas, ctx, type) {
        if (!isCurrentlyDrawing) return;
        
        isCurrentlyDrawing = false;
        
        // Remove drawing-active class to restore normal behavior
        document.body.classList.remove('drawing-active');
        
        if (currentDrawingPath.length > 1) {
            if (type === 'aerial') {
                // Add side information to the path
                const pathWithSide = {
                    points: [...currentDrawingPath],
                    side: currentAerialSide,
                    timestamp: Date.now()
                };
                aerialPaths.push(pathWithSide);
                // Also update canvas drawing data
                if (aerialCanvas && aerialCanvas.drawingData) {
                    aerialCanvas.drawingData.paths.push(pathWithSide);
                }
            } else if (type === 'capturedStreet') {
                capturedStreetPaths.push([...currentDrawingPath]);
                // Also update canvas drawing data
                if (capturedCanvas && capturedCanvas.drawingData) {
                    capturedCanvas.drawingData.paths.push([...currentDrawingPath]);
                }
            } else {
                streetPaths.push([...currentDrawingPath]);
                // Also update canvas drawing data
                if (streetCanvas && streetCanvas.drawingData) {
                    streetCanvas.drawingData.paths.push([...currentDrawingPath]);
                }
            }
            
            // Calculate measurements
            calculateEnhancedMeasurements(type);
        }
        
        currentDrawingPath = [];
        
        // Ensure drawing-active class is removed
        document.body.classList.remove('drawing-active');
    }
    
    // Enhanced measurement calculation
    function calculateEnhancedMeasurements(type) {
        const paths = type === 'aerial' ? aerialPaths : streetPaths;
        let totalLength = 0;
        let segments = [];
        
        paths.forEach((path, pathIndex) => {
            let pathLength = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i-1].x;
                const dy = path[i].y - path[i-1].y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                pathLength += segmentLength;
                
                segments.push({
                    pathIndex: pathIndex,
                    segmentIndex: i,
                    length: segmentLength,
                    start: path[i-1],
                    end: path[i]
                });
            }
            totalLength += pathLength;
        });
        
        // Apply scale factor
        const scaleFactor = type === 'aerial' ? aerialScaleFactor : streetScaleFactor;
        const totalFeet = totalLength * scaleFactor;
        
        // Update measurements - ADD to existing, don't replace
        if (type === 'aerial') {
            // Get the current side being measured
            const currentSide = getCurrentAerialSide();
            
            // Add the new measurement to the current side
            measurements.aerial[currentSide] = Math.round(totalFeet);
            
            // Recalculate perimeter from all sides
            measurements.aerial.perimeter = (measurements.aerial.front || 0) + 
                                          (measurements.aerial.leftSide || 0) + 
                                          (measurements.aerial.rightSide || 0) + 
                                          (measurements.aerial.back || 0);
            
            // Update eaves and gables based on total perimeter
            measurements.aerial.eaves = Math.round(measurements.aerial.perimeter * 0.7);
            measurements.aerial.gables = Math.round(measurements.aerial.perimeter * 0.3);
            
            console.log(`âœ… Aerial ${currentSide} side: ${totalFeet.toFixed(1)} ft, Total perimeter: ${measurements.aerial.perimeter} ft`);
            updateAerialDisplay();
        } else {
            // Get the current side being measured
            const currentSide = getCurrentStreetSide();
            
            // Add the new measurement to the current side
            measurements.street[currentSide] = Math.round(totalFeet);
            
            // Recalculate total from all sides
            measurements.street.total = (measurements.street.front || 0) + 
                                      (measurements.street.leftSide || 0) + 
                                      (measurements.street.rightSide || 0) + 
                                      (measurements.street.back || 0);
            
            // Update eaves and gables based on total
            measurements.street.eaves = Math.round(measurements.street.total * 0.8);
            measurements.street.gables = Math.round(measurements.street.total * 0.2);
            
            console.log(`âœ… Street ${currentSide} side: ${totalFeet.toFixed(1)} ft, Total: ${measurements.street.total} ft`);
            updateStreetDisplay();
        }
        
        updateCombinedMeasurements();
        updateLightVisualization();
        updatePricing();
    }
    
    function updateAerialDisplay() {
        document.getElementById('aerialPerimeter').textContent = measurements.aerial.perimeter;
        document.getElementById('aerialEaves').textContent = measurements.aerial.eaves;
        document.getElementById('aerialGables').textContent = measurements.aerial.gables;
        
        // Update bid total when aerial measurements change
        calculateBidTotal();
    }
    
    function updateStreetDisplay() {
        document.getElementById('streetTotal').textContent = measurements.street.total;
        document.getElementById('streetEaves').textContent = measurements.street.eaves;
        document.getElementById('streetGables').textContent = measurements.street.gables;
        
        // Update bid total when street measurements change
        calculateBidTotal();
    }
    
    function updateCombinedMeasurements() {
        const totalFeet = measurements.aerial.perimeter + measurements.street.total;
        console.log('Combined measurements updated:', { aerial: measurements.aerial, street: measurements.street, total: totalFeet });
    }
    
    // Enhanced canvas setup - preserve existing paths
    function setupEnhancedCanvas(canvas, ctx, type) {
        // Store existing drawing data before reinitializing
        const existingDrawingData = canvas.drawingData ? { ...canvas.drawingData } : null;
        
        // Remove existing event listeners by cloning
        const newCanvas = canvas.cloneNode(true);
        canvas.parentNode.replaceChild(newCanvas, canvas);
        
        // Update references
        if (type === 'aerial') {
            aerialCanvas = newCanvas;
            aerialCtx = newCanvas.getContext('2d');
            ctx = aerialCtx;
            canvas = aerialCanvas;
        } else {
            streetCanvas = newCanvas;
            streetCtx = newCanvas.getContext('2d');
            ctx = streetCtx;
            canvas = streetCanvas;
        }
        
        // Initialize drawing data
        if (!canvas.drawingData) {
            canvas.drawingData = {
                paths: [],
                currentPath: [],
                isDrawing: false
            };
        }
        
        // Restore existing paths if they exist
        if (existingDrawingData && existingDrawingData.paths) {
            canvas.drawingData.paths = [...existingDrawingData.paths];
            canvas.drawingData.currentPath = existingDrawingData.currentPath || [];
            canvas.drawingData.isDrawing = existingDrawingData.isDrawing || false;
            
            // Redraw all existing paths
            redrawAllPaths(canvas, ctx, type);
        }
        
        // Add enhanced event listeners
        if (drawingMode === 'straight') {
            canvas.addEventListener('click', (e) => handleStraightLineClick(e, canvas, ctx, type));
            // Add right-click to complete straight line path
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (canvas.drawingData.currentPath && canvas.drawingData.currentPath.length >= 2) {
                    // Complete the path
                    canvas.drawingData.paths.push([...canvas.drawingData.currentPath]);
                    canvas.drawingData.currentPath = [];
                    
                    // Calculate measurements
                    calculateMeasurementsFromPaths(canvas, type);
                    
                    // Show completion message
                    showStatus('Straight line path completed! Right-click to finish future paths.', 'success');
                }
            });
            // Add double-click to complete straight line path
            canvas.addEventListener('dblclick', (e) => {
                if (canvas.drawingData.currentPath && canvas.drawingData.currentPath.length >= 2) {
                    // Complete the path
                    canvas.drawingData.paths.push([...canvas.drawingData.currentPath]);
                    canvas.drawingData.currentPath = [];
                    
                    // Calculate measurements
                    calculateMeasurementsFromPaths(canvas, type);
                    
                    // Show completion message
                    showStatus('Straight line path completed! Right-click to finish future paths.', 'success');
                }
            });
        }
        
        if (drawingMode === 'freehand') {
            canvas.addEventListener('mousedown', (e) => startFreehand(e, canvas, ctx, type));
            canvas.addEventListener('mousemove', (e) => drawFreehand(e, canvas, ctx, type));
            canvas.addEventListener('mouseup', (e) => endFreehand(e, canvas, ctx, type));
            canvas.addEventListener('mouseleave', (e) => endFreehand(e, canvas, ctx, type));
        }
        
        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            if (drawingMode === 'freehand') {
                startFreehand(mouseEvent, canvas, ctx, type);
            } else {
                handleStraightLineClick(mouseEvent, canvas, ctx, type);
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (drawingMode === 'freehand') {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                drawFreehand(mouseEvent, canvas, ctx, type);
            }
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (drawingMode === 'freehand') {
                const mouseEvent = new MouseEvent('mouseup', {});
                endFreehand(mouseEvent, canvas, ctx, type);
            }
        });
    }
    
    // Enhanced drawing mode switching - preserve existing paths
    function setDrawingMode(mode) {
        drawingMode = mode;
        
        // Update UI
        document.getElementById('straightMode').classList.toggle('active', mode === 'straight');
        document.getElementById('freehandMode').classList.toggle('active', mode === 'freehand');
        
        // Store existing paths before reinitializing
        const aerialPaths = aerialCanvas?.drawingData?.paths || [];
        const streetPaths = streetCanvas?.drawingData?.paths || [];
        
        // Reinitialize canvases with enhanced setup
        setupEnhancedCanvas(aerialCanvas, aerialCtx, 'aerial');
        setupEnhancedCanvas(streetCanvas, streetCtx, 'street');
        
        // Restore existing paths
        if (aerialCanvas && aerialPaths.length > 0) {
            aerialCanvas.drawingData.paths = [...aerialPaths];
            redrawAllPaths(aerialCanvas, aerialCtx, 'aerial');
        }
        if (streetCanvas && streetPaths.length > 0) {
            streetCanvas.drawingData.paths = [...streetPaths];
            redrawAllPaths(streetCanvas, streetCtx, 'street');
        }
        
        console.log('Drawing mode changed to:', mode, 'with', aerialPaths.length + streetPaths.length, 'existing paths preserved');
    }
    
    // Enhanced clear functions - REMOVED DUPLICATE
    // The main clearAerialDrawing function is at line 2018
    
    function clearStreetDrawing() {
        if (streetCtx && streetCanvas) {
            streetCtx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
            streetPaths = [];
            if (streetCanvas.drawingData) {
                streetCanvas.drawingData.paths = [];
                streetCanvas.drawingData.currentPath = [];
                streetCanvas.drawingData.isDrawing = false;
            }
            
            // Reset measurements
            measurements.street = { front: 0, leftSide: 0, rightSide: 0, back: 0, total: 0, eaves: 0, gables: 0 };
            updateStreetDisplay();
            
            // Hide scale section
            document.getElementById('streetScaleSection').style.display = 'none';
            
            updateLightVisualization();
            updatePricing();
            
            console.log('Street drawing cleared');
        }
    }
    
    // Enhanced Google Maps initialization
    function initializeGoogleMaps() {
        try {
            // Initialize map with default location
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 21,
                center: { lat: 39.8283, lng: -98.5795 }, // Center of US
                mapTypeId: 'satellite',
                zoomControl: true,
                streetViewControl: false,
                fullscreenControl: false,
                mapTypeControl: false,
                minZoom: 18,
                maxZoom: 21,
                gestureHandling: 'cooperative',
                tilt: 0, // Force top-down view (no tilt)
                heading: 0 // Force north-up orientation
            });
            
            // Initialize street view
            streetView = new google.maps.StreetViewPanorama(document.getElementById('streetView'), {
                position: { lat: 39.8283, lng: -98.5795 },
                pov: { heading: 0, pitch: 0 },
                zoom: 1,
                addressControl: false,
                enableCloseButton: false,
                fullscreenControl: false,
                motionTracking: false,
                motionTrackingControl: false,
                clickToGo: false
            });
            
            // Initialize canvases with enhanced setup
            initializeEnhancedCanvases();
            
            // Get initial Google Maps scale
            setTimeout(() => {
                getGoogleMapScale();
            }, 1000);
            
            console.log('Google Maps initialized successfully');
            
            // Initialize address suggestions after Google Maps is ready
            initializeAddressSuggestions();
        } catch (error) {
            console.error('Error initializing Google Maps:', error);
            showStatus('Error initializing Google Maps. Please check your API key.', 'error');
        }
    }
    
    function initializeEnhancedCanvases() {
        try {
            // Aerial canvas
            aerialCanvas = document.getElementById('aerialCanvas');
            aerialCtx = aerialCanvas.getContext('2d');
            
            // Street canvas
            streetCanvas = document.getElementById('streetCanvas');
            streetCtx = streetCanvas.getContext('2d');
            
            // Set canvas sizes to match containers
            resizeCanvases();
            
            // Setup drawing events with enhanced system
            setupEnhancedCanvas(aerialCanvas, aerialCtx, 'aerial');
            setupEnhancedCanvas(streetCanvas, streetCtx, 'street');
            
            // Resize canvases when window resizes
            window.addEventListener('resize', resizeCanvases);
            
            console.log('Enhanced canvases initialized');
        } catch (error) {
            console.error('Error initializing canvases:', error);
        }
    }
    
    // Enhanced scale calculation
    function getGoogleMapScale() {
        try {
            if (!map || !map.getCenter) {
                console.warn('Map not ready for scale calculation');
                return 1;
            }
            
            // Get current zoom level and latitude
            const zoom = map.getZoom();
            const center = map.getCenter();
            
            if (!center || typeof center.lat !== 'function') {
                console.warn('Map center not available');
                return 1;
            }
            
            const lat = center.lat();
            
            // Calculate meters per pixel at current zoom and latitude
            const metersPerPixel = 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
            
            // Convert to feet per pixel
            const feetPerPixel = metersPerPixel * 3.28084;
            
            // Update aerial scale factor
            aerialScaleFactor = feetPerPixel;
            
            console.log(`Zoom: ${zoom}, Lat: ${lat.toFixed(6)}, Scale: ${feetPerPixel.toFixed(6)} ft/pixel`);
            
            // Update zoom status
            const zoomStatus = document.getElementById('zoomStatus');
            if (zoomStatus) {
                zoomStatus.textContent = `Scale: ${feetPerPixel.toFixed(3)} ft/pixel`;
            }
            
            return feetPerPixel;
        } catch (error) {
            console.error('Error calculating scale:', error);
            return 1;
        }
    }
    
    // Enhanced property loading
    function loadProperty() {
        const address = document.getElementById('addressInput').value;
        if (!address.trim()) {
            showStatus('Please enter a property address', 'error');
            return;
        }
        
        showStatus('Loading property...', 'loading');
        
        try {
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ address: address }, (results, status) => {
                if (status === 'OK') {
                    const location = results[0].geometry.location;
                    currentProperty = {
                        address: address,
                        location: location
                    };
                    
                    // Update map
                    map.setCenter(location);
                    map.setZoom(21);
                    
                    // Initialize street view
                    initializeStreetView(location);
                    
                    // Update scale
                    setTimeout(() => {
                        getGoogleMapScale();
                    }, 1000);
                    
                    showStatus(`Property loaded: ${address}`, 'success');
                } else {
                    showStatus('Could not find property address', 'error');
                }
            });
        } catch (error) {
            console.error('Error loading property:', error);
            showStatus('Error loading property. Please try again.', 'error');
        }
    }
    
    // Enhanced street view initialization
    function initializeStreetView(location) {
        try {
            const streetViewService = new google.maps.StreetViewService();
            const radius = 50;
            
            streetViewService.getPanorama({
                location: location,
                radius: radius
            }, (data, status) => {
                if (status === 'OK') {
                    const position = data.location.latLng;
                    const heading = google.maps.geometry.spherical.computeHeading(position, location);
                    
                    streetView.setPosition(position);
                    streetView.setPov({
                        heading: heading,
                        pitch: 0
                    });
                    
                    showStatus('Street view loaded successfully', 'success');
                } else {
                    showStatus('Street view not available for this location', 'warning');
                }
            });
        } catch (error) {
            console.error('Error initializing street view:', error);
            showStatus('Error loading street view', 'error');
        }
    }
    
    // Enhanced zoom application
    function applyZoomLevel() {
        try {
            const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
            map.setZoom(zoomLevel);
            
            setTimeout(() => {
                getGoogleMapScale();
            }, 500);
            
            console.log('Zoom level applied:', zoomLevel);
        } catch (error) {
            console.error('Error applying zoom:', error);
        }
    }
    
    // Set perfect top-down view
    function setTopDownView() {
        try {
            // Reset to perfect top-down view
            map.setTilt(0);
            map.setHeading(0);
            
            // Force the view to update
            map.setOptions({
                tilt: 0,
                heading: 0
            });
            
            showStatus('Top-down view applied', 'success');
            console.log('Top-down view applied - Tilt: 0, Heading: 0');
        } catch (error) {
            console.error('Error setting top-down view:', error);
            showStatus('Error setting top-down view', 'error');
        }
    }
    
    // Enhanced street scale application
    function applyStreetScale() {
        try {
            const scaleInput = document.getElementById('streetScaleInput');
            const referenceWidth = parseFloat(scaleInput.value);
            
            if (!referenceWidth || referenceWidth <= 0) {
                alert('Please enter a valid reference width');
                return;
            }
            
            // Calculate scale based on last drawn line
            const paths = streetCanvas.drawingData.paths;
            if (paths.length === 0) {
                alert('Please draw a reference line first');
                return;
            }
            
            const lastPath = paths[paths.length - 1];
            let lineLength = 0;
            
            for (let i = 1; i < lastPath.length; i++) {
                const dx = lastPath[i].x - lastPath[i-1].x;
                const dy = lastPath[i].y - lastPath[i-1].y;
                lineLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            if (lineLength > 0) {
                streetScaleFactor = referenceWidth / lineLength;
                
                // Remove the reference line from paths (don't count it in measurements)
                paths.pop();
                
                // Recalculate measurements
                calculateEnhancedMeasurements('street');
                
                showStatus(`Scale calibrated: ${referenceWidth}ft reference`, 'success');
                console.log('Street scale factor updated:', streetScaleFactor);
            }
        } catch (error) {
            console.error('Error applying street scale:', error);
            alert('Error applying scale. Please try again.');
        }
    }
    
    // ===== IMAGE UPLOAD SCALE CALIBRATION =====
    
    let scaleDrawingData = {
        startPoint: null,
        endPoint: null,
        isDrawing: false
    };
    let uploadedImageDrawingMode = 'straight';
    let uploadedImagePaths = [];
    let uploadedImageCurrentPath = [];
    let isUploadedImageDrawing = false;
    
    function handleImageUpload(event) {
        try {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    uploadedImageData = {
                        image: img,
                        width: img.width,
                        height: img.height
                    };
                    
                    displayUploadedImage();
                    setupScaleCanvas();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            
            showStatus('Image uploaded successfully', 'success');
        } catch (error) {
            console.error('Error handling image upload:', error);
            showStatus('Error uploading image', 'error');
        }
    }
    
    function displayUploadedImage() {
        try {
            const previewDiv = document.getElementById('uploadedImagePreview');
            const previewImg = document.getElementById('previewImage');
            
            if (uploadedImageData && previewDiv && previewImg) {
                previewImg.src = uploadedImageData.image.src;
                previewDiv.style.display = 'block';
                
                // Set canvas size to match image
                const scaleCanvas = document.getElementById('scaleCanvas');
                if (scaleCanvas) {
                    scaleCanvas.width = uploadedImageData.width;
                    scaleCanvas.height = uploadedImageData.height;
                    scaleCanvas.style.width = '100%';
                    scaleCanvas.style.height = '100%';
                }
            }
        } catch (error) {
            console.error('Error displaying uploaded image:', error);
        }
    }
    
                // FIRST setupScaleCanvas function - for image uploads
    function setupScaleCanvas() {
        try {
            scaleCanvas = document.getElementById('scaleCanvas');
            if (!scaleCanvas) return;
            
            scaleCtx = scaleCanvas.getContext('2d');
            
            // Set canvas dimensions to match the container
            const container = scaleCanvas.parentElement;
            if (container) {
                scaleCanvas.width = container.offsetWidth;
                scaleCanvas.height = container.offsetHeight;
                console.log('Scale Canvas dimensions set to:', scaleCanvas.width, 'x', scaleCanvas.height);
            }
            
            // Clear any existing event listeners
            scaleCanvas.replaceWith(scaleCanvas.cloneNode(true));
            scaleCanvas = document.getElementById('scaleCanvas');
            scaleCtx = scaleCanvas.getContext('2d');
            
            // Set dimensions for the new canvas
            if (container) {
                scaleCanvas.width = container.offsetWidth;
                scaleCanvas.height = container.offsetHeight;
                console.log('New Scale Canvas dimensions set to:', scaleCanvas.width, 'x', scaleCanvas.height);
            }
            
            // Add drawing event listeners
            scaleCanvas.addEventListener('mousedown', startScaleDrawing);
            scaleCanvas.addEventListener('mousemove', continueScaleDrawing);
            scaleCanvas.addEventListener('mouseup', endScaleDrawing);
            scaleCanvas.addEventListener('mouseleave', endScaleDrawing);
            
            // Touch support for mobile
            scaleCanvas.addEventListener('touchstart', handleTouchStart);
            scaleCanvas.addEventListener('touchmove', handleTouchMove);
            scaleCanvas.addEventListener('touchend', handleTouchEnd);
            
            // Initialize measurement canvas
            measurementCanvas = document.getElementById('measurementCanvas');
            if (measurementCanvas) {
                measurementCtx = measurementCanvas.getContext('2d');
                // Set canvas size to match image
                if (uploadedImageData) {
                    measurementCanvas.width = uploadedImageData.width;
                    measurementCanvas.height = uploadedImageData.height;
                    // Set CSS dimensions to match the display
                    measurementCanvas.style.width = '100%';
                    measurementCanvas.style.height = '100%';
                }
            }
            
            console.log('Scale canvas setup complete - FIRST FUNCTION');
        } catch (error) {
            console.error('Error setting up scale canvas:', error);
        }
    }
    
    function startScaleDrawing(e) {
        try {
            const rect = scaleCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (scaleCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (scaleCanvas.height / rect.height);
            
            scaleDrawingData.startPoint = { x, y };
            scaleDrawingData.isDrawing = true;
            
            // Clear previous drawings
            scaleCtx.clearRect(0, 0, scaleCanvas.width, scaleCanvas.height);
            
            // Draw starting point
            scaleCtx.fillStyle = '#0066cc';
            scaleCtx.beginPath();
            scaleCtx.arc(x, y, 5, 0, Math.PI * 2);
            scaleCtx.fill();
        } catch (error) {
            console.error('Error starting scale drawing:', error);
        }
    }
    
    function continueScaleDrawing(e) {
        try {
            if (!scaleDrawingData.isDrawing || !scaleDrawingData.startPoint) return;
            
            const rect = scaleCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (scaleCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (scaleCanvas.height / rect.height);
            
            // Clear and redraw
            scaleCtx.clearRect(0, 0, scaleCanvas.width, scaleCanvas.height);
            
            // Draw starting point
            scaleCtx.fillStyle = '#0066cc';
            scaleCtx.beginPath();
            scaleCtx.arc(scaleDrawingData.startPoint.x, scaleDrawingData.startPoint.y, 5, 0, Math.PI * 2);
            scaleCtx.fill();
            
            // Draw line
            scaleCtx.strokeStyle = '#0066cc';
            scaleCtx.lineWidth = 3;
            scaleCtx.beginPath();
            scaleCtx.moveTo(scaleDrawingData.startPoint.x, scaleDrawingData.startPoint.y);
            scaleCtx.lineTo(x, y);
            scaleCtx.stroke();
            
            // Draw end point
            scaleCtx.fillStyle = '#0066cc';
            scaleCtx.beginPath();
            scaleCtx.arc(x, y, 5, 0, Math.PI * 2);
            scaleCtx.fill();
        } catch (error) {
            console.error('Error continuing scale drawing:', error);
        }
    }
    
    function endScaleDrawing(e) {
        try {
            if (!scaleDrawingData.isDrawing || !scaleDrawingData.startPoint) return;
            
            const rect = scaleCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (scaleCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (scaleCanvas.height / rect.height);
            
            scaleDrawingData.endPoint = { x, y };
            scaleDrawingData.isDrawing = false;
            
            console.log('Scale line drawn:', scaleDrawingData);
        } catch (error) {
            console.error('Error ending scale drawing:', error);
        }
    }
    
    // Touch event handlers for mobile
    function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        startScaleDrawing(mouseEvent);
    }
    
    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
        });
        continueScaleDrawing(mouseEvent);
    }
    
    function handleTouchEnd(e) {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        endScaleDrawing(mouseEvent);
    }
    
    function applyUploadedImageScale() {
        try {
            console.log('ğŸ”§ applyUploadedImageScale() called');
            console.log('Scale drawing data:', scaleDrawingData);
            
            if (!scaleDrawingData.startPoint || !scaleDrawingData.endPoint) {
                console.log('âŒ No reference line drawn');
                alert('Please draw a reference line first');
                return;
            }
            
            const referenceWidth = parseFloat(document.getElementById('uploadedImageScale').value);
            console.log('Reference width input:', referenceWidth);
            
            if (!referenceWidth || referenceWidth <= 0) {
                console.log('âŒ Invalid reference width:', referenceWidth);
                alert('Please enter a valid reference width');
                return;
            }
            
            // Calculate line length in pixels
            const dx = scaleDrawingData.endPoint.x - scaleDrawingData.startPoint.x;
            const dy = scaleDrawingData.endPoint.y - scaleDrawingData.startPoint.y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);
            
            console.log('Line calculation:', { dx, dy, lineLength, startPoint: scaleDrawingData.startPoint, endPoint: scaleDrawingData.endPoint });
            
            if (lineLength > 0) {
                // Calculate scale factor (feet per pixel)
                const scaleFactor = referenceWidth / lineLength;
                
                // Apply this scale to street view measurements
                streetScaleFactor = scaleFactor;
                
                console.log('âœ… Scale factor calculated and applied:', scaleFactor);
                showStatus(`Scale calibrated from image: ${referenceWidth}ft reference = ${scaleFactor.toFixed(6)} ft/pixel`, 'success');
                
                // Update any existing street view measurements
                if (measurements.street && measurements.street.total > 0) {
                    console.log('Updating street measurements with new scale...');
                    updateStreetDisplay();
                    updateCombinedMeasurements();
                    updateLightVisualization();
                    updatePricing();
                } else {
                    console.log('No existing street measurements to update');
                }
                
                // Also update aerial measurements if they exist
                if (measurements.aerial && measurements.aerial.perimeter > 0) {
                    console.log('Updating aerial measurements with new scale...');
                    updateCombinedMeasurements();
                    updateLightVisualization();
                    updatePricing();
                }
                
                console.log('âœ… Scale application complete');
                
                // Disable scale drawing mode and clear the canvas
                scaleDrawingData = {
                    startPoint: null,
                    endPoint: null,
                    isDrawing: false
                };
                
                if (scaleCtx && scaleCanvas) {
                    scaleCtx.clearRect(0, 0, scaleCanvas.width, scaleCanvas.height);
                }
                
                // Switch to measurement drawing mode
                switchToMeasurementMode();
                
                showStatus('Scale applied! You can now draw measurement lines on the image.', 'success');
            } else {
                console.log('âŒ Line length is 0 or invalid');
                alert('Invalid reference line. Please draw a proper line.');
            }
        } catch (error) {
            console.error('âŒ Error applying uploaded image scale:', error);
            alert('Error applying scale. Please try again.');
        }
    }
    
    function clearUploadedImage() {
        try {
            // Clear file input
            document.getElementById('scaleImageUpload').value = '';
            
            // Hide preview
            document.getElementById('uploadedImagePreview').style.display = 'none';
            
            // Clear canvases
            if (scaleCtx && scaleCanvas) {
                scaleCtx.clearRect(0, 0, scaleCanvas.width, scaleCanvas.height);
            }
            if (measurementCtx && measurementCanvas) {
                measurementCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
            }
            
            // Reset data
            uploadedImageData = null;
            scaleDrawingData = {
                startPoint: null,
                endPoint: null,
                isDrawing: false
            };
            uploadedImagePaths = [];
            uploadedImageCurrentPath = [];
            isUploadedImageDrawing = false;
            
            // Reset to scale mode
            if (scaleCanvas) {
                scaleCanvas.style.display = 'block';
            }
            if (measurementCanvas) {
                measurementCanvas.style.display = 'none';
            }
            
            // Hide measurement controls
            const measurementControls = document.getElementById('measurementControls');
            if (measurementControls) {
                measurementControls.style.display = 'none';
            }
            
            showStatus('Uploaded image cleared', 'success');
        } catch (error) {
            console.error('Error clearing uploaded image:', error);
        }
    }
    
    // REMOVED DUPLICATE - Enhanced light visualization function
    // This was conflicting with the main updateLightVisualization function
    
    // REMOVED DUPLICATE - Enhanced pricing update function
    // This was conflicting with the main updatePricing function
    
    // Enhanced night visualization (placeholder for now)
    function showAerialVisualization() {
        try {
            // Placeholder for aerial night visualization
            alert('Aerial night visualization coming soon! This will show a darkened aerial view with animated lights.');
            console.log('Aerial visualization requested');
        } catch (error) {
            console.error('Error showing aerial visualization:', error);
        }
    }
    
    function showStreetVisualization() {
        try {
            // Placeholder for street night visualization
            alert('Street night visualization coming soon! This will show a darkened street view with animated lights.');
            console.log('Street visualization requested');
        } catch (error) {
            console.error('Error showing street visualization:', error);
        }
    }
    
    function closeNightVisualization() {
        try {
            document.getElementById('nightVisualizationModal').style.display = 'none';
        } catch (error) {
            console.error('Error closing night visualization:', error);
        }
    }
    
    // Enhanced signature and checkout
    function clearSignature() {
        try {
            const canvas = document.getElementById('signatureCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        } catch (error) {
            console.error('Error clearing signature:', error);
        }
    }
    
    function finalizeOrder() {
        try {
            const customerName = document.getElementById('customerName').value;
            const customerEmail = document.getElementById('customerEmail').value;
            const customerPhone = document.getElementById('customerPhone').value;
            const termsAccepted = document.getElementById('termsAccepted').checked;
            
            if (!customerName || !customerEmail || !customerPhone) {
                alert('Please fill in all customer information');
                return;
            }
            
            if (!termsAccepted) {
                alert('Please accept the terms and conditions');
                return;
            }
            
            // Create order data
            const orderData = {
                customer: { name: customerName, email: customerEmail, phone: customerPhone },
                property: currentProperty,
                measurements: measurements,
                pricing: {
                    retailTotal: document.getElementById('retailTotal').textContent,
                    saleTotal: document.getElementById('saleTotal').textContent,
                    extraDiscount: document.getElementById('extraDiscountDisplay').textContent,
                    totalSavings: document.getElementById('totalSavings').textContent
                },
                lights: {
                    total: document.getElementById('totalLights').textContent,
                    withWaste: document.getElementById('lightsWithWaste').textContent,
                    spacing: document.getElementById('lightSpacing').value,
                    colorScheme: currentColorScheme,
                    animation: currentAnimationMode
                },
                timestamp: new Date().toISOString()
            };
            
            console.log('Order Data:', orderData);
            alert('Order completed successfully! Contract generation coming soon.');
        } catch (error) {
            console.error('Error finalizing order:', error);
            alert('Error finalizing order. Please try again.');
        }
    }
    
    // Enhanced status display
    function showStatus(message, type) {
        try {
            const statusEl = document.getElementById('propertyStatus');
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.textContent = message;
                statusEl.className = `status-message status-${type}`;
                
                if (type !== 'loading') {
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                }
            }
        } catch (error) {
            console.error('Error showing status:', error);
        }
    }
    
    // Side-specific measurement source management
    function updateSideSource(side) {
        try {
            const sourceSelect = document.getElementById(`${side}Source`);
            const statusSpan = document.getElementById(`${side}Status`);
            
            if (sourceSelect && statusSpan) {
                const selectedSource = sourceSelect.value;
                sideMeasurements[side].source = selectedSource;
                
                // Update status display
                const sourceText = selectedSource === 'aerial' ? 'Aerial View' : 'Street View';
                statusSpan.textContent = `(${sourceText})`;
                
                // Update combined measurements
                updateCombinedMeasurements();
                calculateBidTotal();
                updateLightVisualization();
                updatePricing();
                
                console.log(`Side ${side} source updated to: ${selectedSource}`);
            }
        } catch (error) {
            console.error(`Error updating side source for ${side}:`, error);
        }
    }
    
    // Initialize side-specific measurement system
    function initializeSideMeasurements() {
        try {
            // Set default sources
            sideMeasurements = {
                front: { source: 'street', eaves: 0, gables: 0, total: 0 },
                left: { source: 'aerial', eaves: 0, gables: 0, total: 0 },
                right: { source: 'aerial', eaves: 0, gables: 0, total: 0 },
                back: { source: 'aerial', eaves: 0, gables: 0, total: 0 }
            };
            
            // Update status displays
            Object.keys(sideMeasurements).forEach(side => {
                const statusSpan = document.getElementById(`${side}Status`);
                if (statusSpan) {
                    const source = sideMeasurements[side].source;
                    const sourceText = source === 'aerial' ? 'Aerial View' : 'Street View';
                    statusSpan.textContent = `(${sourceText})`;
                }
            });
            
            console.log('Side-specific measurement system initialized');
        } catch (error) {
            console.error('Error initializing side measurements:', error);
        }
    }
    
    // Enhanced combined measurements with side-specific sources
    function updateCombinedMeasurements() {
        try {
            let totalFeet = 0;
            let sideBreakdown = {};
            
            // Calculate totals based on side-specific sources
            Object.keys(sideMeasurements).forEach(side => {
                const source = sideMeasurements[side].source;
                let sideTotal = 0;
                
                if (source === 'aerial') {
                    // Use aerial measurements for this side
                    sideTotal = measurements.aerial.perimeter * 0.25; // Assume equal distribution
                } else if (source === 'street') {
                    // Use street measurements for this side
                    sideTotal = measurements.street.total;
                }
                
                sideMeasurements[side].total = Math.round(sideTotal);
                totalFeet += sideTotal;
                sideBreakdown[side] = { source, total: sideTotal };
            });
            
            console.log('Combined measurements updated:', { 
                aerial: measurements.aerial, 
                street: measurements.street, 
                total: totalFeet,
                sideBreakdown 
            });
            
            return totalFeet;
        } catch (error) {
            console.error('Error updating combined measurements:', error);
            return 0;
        }
    }

    // Calculate bid total based on side-specific measurement sources
    function calculateBidTotal() {
        try {
            let bidTotal = 0;
            const sideValues = {};
            
            // Calculate each side based on selected source
            Object.keys(sideMeasurements).forEach(side => {
                const source = sideMeasurements[side].source;
                let sideTotal = 0;
                
                if (source === 'aerial' && measurements.aerial) {
                    // For aerial, use the actual measured value for this specific side
                    // Map the side names correctly: 'left' -> 'leftSide', 'right' -> 'rightSide'
                    let aerialSideKey = side;
                    if (side === 'left') aerialSideKey = 'leftSide';
                    if (side === 'right') aerialSideKey = 'rightSide';
                    
                    sideTotal = measurements.aerial[aerialSideKey] || 0;
                    
                    // If no specific side measurement exists, fall back to equal distribution
                    if (sideTotal === 0) {
                        sideTotal = measurements.aerial.perimeter / 4;
                    }
                } else if (source === 'street' && measurements.street) {
                    // For street, use the specific side measurement
                    // Map the side names correctly: 'left' -> 'leftSide', 'right' -> 'rightSide'
                    let streetSideKey = side;
                    if (side === 'left') streetSideKey = 'leftSide';
                    if (side === 'right') streetSideKey = 'rightSide';
                    
                    sideTotal = measurements.street[streetSideKey] || 0;
                }
                
                sideValues[side] = Math.round(sideTotal * 100) / 100; // Round to 2 decimal places
                bidTotal += sideTotal;
            });
            
            // Update the bid display
            document.getElementById('bidFront').textContent = sideValues.front || 0;
            document.getElementById('bidLeftSide').textContent = sideValues.left || 0;
            document.getElementById('bidRightSide').textContent = sideValues.right || 0;
            document.getElementById('bidBack').textContent = sideValues.back || 0;
            document.getElementById('bidTotal').textContent = Math.round(bidTotal * 100) / 100;
            
            // Update source labels
            document.getElementById('frontSourceLabel').textContent = `(${sideMeasurements.front.source === 'aerial' ? 'Aerial View' : 'Street View'})`;
            document.getElementById('leftSourceLabel').textContent = `(${sideMeasurements.left.source === 'aerial' ? 'Aerial View' : 'Street View'})`;
            document.getElementById('rightSourceLabel').textContent = `(${sideMeasurements.right.source === 'aerial' ? 'Aerial View' : 'Street View'})`;
            document.getElementById('backSourceLabel').textContent = `(${sideMeasurements.back.source === 'aerial' ? 'Aerial View' : 'Street View'})`;
            
            console.log('Bid total calculated:', { sideValues, bidTotal });
            
            // Store the bid total for use in pricing
            window.bidTotalFeet = bidTotal;
            
            return bidTotal;
        } catch (error) {
            console.error('Error calculating bid total:', error);
            return 0;
        }
    }
    
                // Initialize enhanced system when page loads
            document.addEventListener('DOMContentLoaded', function() {
                try {
                    // Initialize side measurements
                    initializeSideMeasurements();
                    
                    // Calculate initial bid total
                    calculateBidTotal();
                    
                    // Set up animation speed slider
                    const speedSlider = document.getElementById('animationSpeed');
            if (speedSlider) {
                speedSlider.addEventListener('input', function() {
                    const speedValue = document.getElementById('speedValue');
                    const speed = parseInt(this.value);
                    currentAnimationSpeed = speed;
                    
                    // Update speed text
                    if (speed <= 3) speedValue.textContent = 'Slow';
                    else if (speed <= 7) speedValue.textContent = 'Medium';
                    else speedValue.textContent = 'Fast';
                });
            }
            
            // Set up custom color inputs
            const customColorInputs = ['customColor1', 'customColor2', 'customColor3', 'customColor4'];
            customColorInputs.forEach((id, index) => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('change', function() {
                        customColors[index] = this.value;
                    });
                }
            });
            
            // Initialize collapsible sections
            initializeCollapsibleSections();
            
            // Initialize side-specific measurement system
            initializeSideMeasurements();
            
            // Initialize address suggestions system
            initializeAddressSuggestions();
            
            // Initialize Google Maps API if available
            if (typeof google !== 'undefined') {
                initializeGoogleMaps();
            } else {
                console.log('Google Maps API not loaded yet, waiting for callback...');
            }
            
            console.log('Enhanced system initialized');
        } catch (error) {
            console.error('Error initializing enhanced system:', error);
        }
    });
    
    // ===== ADDRESS SUGGESTIONS SYSTEM =====
    
    // Initialize address suggestions when page loads
    function setupAddressSuggestions() {
        console.log('ğŸ”— Setting up address suggestions system...');
        
        // Wait for the page to be fully loaded and Google Maps API to be ready
        setTimeout(() => {
            // Find the main address input field
            const mainInput = document.getElementById('addressInput');
            if (!mainInput) {
                console.log('âŒ Main address input not found');
                return;
            }
            
            // Check if Google Maps API is loaded
            if (typeof google === 'undefined' || !google.maps) {
                console.log('âŒ Google Maps API not loaded yet, retrying...');
                setTimeout(setupAddressSuggestions, 1000);
                return;
            }
            
            console.log('âœ… Google Maps API ready, setting up address suggestions...');
            
            // Use only Geocoding API for address handling
            console.log('âœ… Setting up address suggestions using Geocoding API only');
            
            // Always set up geocoding as a fallback
            const geocoder = new google.maps.Geocoder();
            
            // Handle address input with geocoding (fallback)
            mainInput.addEventListener('blur', () => {
                const address = mainInput.value.trim();
                if (address.length > 5) {
                    showStatus('ğŸ” Geocoding address...', 'loading');
                    geocoder.geocode({ address: address }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            const place = results[0];
                            console.log('âœ… Address geocoded:', place.formatted_address);
                            showStatus(`âœ… Address loaded: ${place.formatted_address}`, 'success');
                            
                            // Store the selected place for later use
                            window.selectedPlace = {
                                formatted_address: place.formatted_address,
                                geometry: place.geometry,
                                place_id: place.place_id
                            };
                            
                            // Show success indicator
                            mainInput.style.borderColor = '#28a745';
                            mainInput.style.backgroundColor = '#f8fff9';
                        } else {
                            console.log('âŒ Geocoding failed:', status);
                            showStatus(`âŒ Could not find address: ${address}`, 'error');
                            mainInput.style.borderColor = '#dc3545';
                            mainInput.style.backgroundColor = '#fff8f8';
                        }
                    });
                }
            });
            
            // Add input listener for real-time address search with geocoding
            let searchTimeout = null;
            mainInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                
                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }
                
                if (query.length >= 3) {
                    // Show custom suggestions immediately
                    showCustomSuggestions(query);
                    
                    // Debounced search for real addresses using Geocoding API
                    searchTimeout = setTimeout(() => {
                        searchRealAddresses(query);
                    }, 500); // Wait 500ms after user stops typing
                } else {
                    hideSuggestions();
                }
            });
            
            // Enter key to select first suggestion
            mainInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const firstSuggestion = document.querySelector('.suggestion-item');
                    if (firstSuggestion) {
                        firstSuggestion.click();
                    }
                }
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if (!mainInput.contains(e.target) && !document.getElementById('addressSuggestions').contains(e.target)) {
                    hideSuggestions();
                }
            });
            
            console.log('âœ… Address suggestions system setup complete!');
        }, 2000);
    }
    
    function showCustomSuggestions(query) {
        const container = document.getElementById('addressSuggestions');
        console.log('ğŸ” Searching for real addresses:', query);
        
        // Show loading indicator while searching
        container.innerHTML = `
            <div style="background: #007bff; color: white; padding: 10px; text-align: center; font-weight: bold; border-radius: 6px 6px 0 0;">
                ğŸ” Searching for Addresses
            </div>
            <div style="padding: 15px; text-align: center; color: #666;">
                <div style="margin-bottom: 10px;">ğŸ” Searching for: "${query}"</div>
                <div style="font-size: 0.9rem;">Finding real addresses via Google...</div>
            </div>
        `;
        
        container.style.display = 'block';
        
        // Immediately search for real addresses
        searchRealAddresses(query);
    }
    
    // Search for real addresses using Geocoding API
    function searchRealAddresses(query) {
        console.log('ğŸ” Searching for real addresses:', query);
        
        if (!google.maps || !google.maps.Geocoder) {
            console.log('âŒ Geocoder not available');
            return;
        }
        
        const geocoder = new google.maps.Geocoder();
        const container = document.getElementById('addressSuggestions');
        
        // Show loading indicator
        container.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">ğŸ” Searching for real addresses...</div>';
        
        // Search for addresses anywhere in the world
        geocoder.geocode({ 
            address: query,
            componentRestrictions: { country: 'us' }
        }, (results, status) => {
            if (status === 'OK' && results.length > 0) {
                console.log('âœ… Found real addresses:', results.length);
                
                // Show real address results
                const realAddresses = results.slice(0, 5); // Limit to 5 results
                container.innerHTML = `
                    <div style="background: #28a745; color: white; padding: 8px; text-align: center; font-weight: bold; border-radius: 6px 6px 0 0;">
                        ğŸ  Real Addresses Found
                    </div>
                    ${realAddresses.map((result, index) => `
                        <div class="suggestion-item" style="padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; background: #f8fff9;" 
                             onmouseover="this.style.background='#e8f5e8'" 
                             onmouseout="this.style.background='#f8fff9'"
                             onclick="selectRealAddress('${result.formatted_address}')">
                            <strong style="color: #28a745;">ğŸ </strong> ${result.formatted_address}
                        </div>
                    `).join('')}
                `;
            } else {
                console.log('âŒ No real addresses found:', status);
                container.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No real addresses found</div>';
            }
        });
    }
    
    // Handle selection of real addresses
    function selectRealAddress(address) {
        console.log('âœ… Real address selected:', address);
        selectCleanAddress(address);
    }
    
    function selectCleanAddress(selectedAddress) {
        console.log('âœ… Address selected:', selectedAddress);
        
        // Update the main input field
        const mainInput = document.getElementById('addressInput');
        if (mainInput) mainInput.value = selectedAddress;
        
        // Hide suggestions
        hideSuggestions();
        
        // Show confirmation
        showStatus(`âœ… Address loaded: ${selectedAddress}`, 'success');
    }
    
    function hideSuggestions() {
        const suggestions = document.getElementById('addressSuggestions');
        if (suggestions) suggestions.style.display = 'none';
    }
    
    // Initialize address suggestions when the system is ready
    function initializeAddressSuggestions() {
        // Wait for Google Maps API to be loaded
        if (typeof google !== 'undefined' && google.maps) {
            setupAddressSuggestions();
        } else {
            // Wait for the API to load
            setTimeout(initializeAddressSuggestions, 1000);
        }
    }
    
    // ===== STREET VIEW CAPTURE SYSTEM =====
    
    // Working Street View capture using Google Static Maps API (like FireflyIQ_v8_2_8 (2).html)
    async function captureStreetView() {
        try {
            console.log('ğŸ¯ captureStreetView() called - using Static Maps API');
            
            if (!streetView || !streetView.getVisible()) {
                showStatus('Street View not available. Please load a property first.', 'error');
                return;
            }
            
            // Get current location from map center (fallback to Street View position)
            let position = streetView.getPosition();
            if (!position && map) {
                position = map.getCenter();
                console.log('Using map center as fallback location');
            }
            
            if (!position) {
                showStatus('No location available. Please select a property first.', 'error');
                return;
            }
            
            showStatus('Fetching Street View from Google Static Maps API...', 'loading');
            
            // Get current Street View orientation (use custom orientation if set)
            let pov = streetView.getPov();
            if (window.streetViewOrientation) {
                pov = {
                    heading: window.streetViewOrientation.heading || pov.heading,
                    pitch: window.streetViewOrientation.pitch || pov.pitch
                };
            }
            
            // Build the Google Static Street View API URL
            if (!googleMapsApiKey) {
                showStatus('Google Maps API key not found. Please check your configuration.', 'error');
                return;
            }
            
            const url = `https://maps.googleapis.com/maps/api/streetview?size=1600x900&location=${position.lat()},${position.lng()}&heading=${Math.round(pov.heading)}&pitch=${Math.round(pov.pitch)}&key=${encodeURIComponent(googleMapsApiKey)}`;
            
            console.log('Fetching from Static Maps API:', url);
            
            // Fetch the Street View image from Google's servers
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const blob = await response.blob();
            
            // Convert blob to data URL
            const reader = new FileReader();
            const imageDataPromise = new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
            });
            
            reader.readAsDataURL(blob);
            const imageData = await imageDataPromise;
            
            console.log('âœ… Street View captured successfully from Static Maps API');
            hideCaptureStatus();
            
            // Store the captured image data
            capturedStreetViewData = {
                imageData: imageData,
                width: 1600,
                height: 900,
                timestamp: Date.now(),
                position: {
                    lat: position.lat(),
                    lng: position.lng()
                },
                pov: {
                    heading: pov.heading,
                    pitch: pov.pitch
                },
                orientation: window.streetViewOrientation || { heading: 0, pitch: 0, zoom: 1 }
            };
            
            console.log('Captured data:', capturedStreetViewData);
            
            // Switch to captured view
            switchToCapturedView();
            
            // Capture toggle backgrounds after Street View is captured
            setTimeout(() => {
                captureToggleBackgrounds();
            }, 1000);
            
            showStatus('Street View captured successfully! You can now draw on the static image.', 'success');
        
    } catch (error) {
        console.error('âŒ Static Maps API capture failed:', error);
        // hideCaptureStatus(); // This function doesn't exist yet
            
            if (error.message.includes('HTTP 403')) {
                showStatus('Access denied. Please check: 1) Static Maps API enabled, 2) Billing enabled, 3) API key restrictions.', 'error');
            } else if (error.message.includes('HTTP 400')) {
                showStatus('Invalid request. Please check the location and Street View availability.', 'error');
            } else {
                showStatus(`Failed to capture Street View: ${error.message}`, 'error');
            }
        }
    }
    

    
    // Function to redraw all paths on a canvas to ensure they're all visible
    function redrawAllPaths(canvas, ctx, type) {
        if (!canvas.drawingData || !canvas.drawingData.paths) return;
        
        console.log('ğŸ”„ Redrawing all paths for', type, ':', canvas.drawingData.paths.length, 'paths');
        
        // Clear the canvas first
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Redraw background image if it exists
        if (canvas.backgroundImage) {
            ctx.drawImage(canvas.backgroundImage, 0, 0, canvas.width, canvas.height);
        }
        
        // Place lights along all paths instead of drawing lines
        canvas.drawingData.paths.forEach((path, pathIndex) => {
            if (path.length < 2) return;
            
            // Place lights along the path
            for (let i = 0; i < path.length; i++) {
                const point = path[i];
                const lightSize = 5;
                
                // Draw light
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(point.x, point.y, lightSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Add subtle glow effect
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 6;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(point.x, point.y, lightSize + 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        });
        
        console.log('âœ… All paths redrawn successfully');
    }

    // Function to redraw all paths on the current active canvas
    function redrawAllPathsOnCurrentCanvas() {
        console.log('ğŸ”„ redrawAllPathsOnCurrentCanvas() called');
        
        // Check which view is currently active
        if (isStreetViewCaptured) {
            // Redraw on captured street view canvas
            const capturedCanvas = document.getElementById('capturedStreetCanvas');
            if (capturedCanvas) {
                const ctx = capturedCanvas.getContext('2d');
                redrawAllPaths(capturedCanvas, ctx, 'capturedStreet');
                showStatus('All paths redrawn on captured Street View', 'success');
            }
        } else if (document.getElementById('streetView').style.display !== 'none') {
            // Redraw on live street view canvas
            const streetCanvas = document.getElementById('streetCanvas');
            if (streetCanvas) {
                const ctx = streetCanvas.getContext('2d');
                redrawAllPaths(streetCanvas, ctx, 'street');
                showStatus('All paths redrawn on live Street View', 'success');
            }
        } else {
            // Redraw on aerial view canvas
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas) {
                const ctx = aerialCanvas.getContext('2d');
                redrawAllPaths(aerialCanvas, ctx, 'aerial');
                showStatus('All paths redrawn on aerial view', 'success');
            }
        }
    }

    // ===== BADASS LIGHT TRANSITION SLIDER FUNCTIONS ğŸš€ =====
    
    let lightTransitionAnimation = null;
    let lightTransitionValue = 0;
    let isTransitionPlaying = false;
    
    // Initialize the light transition slider
    function initializeLightTransitionSlider() {
        const slider = document.getElementById('lightTransitionSlider');
        const canvas = document.getElementById('lightTransitionCanvas');
        
        if (!slider || !canvas) {
            console.log('âŒ Light transition elements not found');
            return;
        }
        
        // Set up slider event listener
        slider.addEventListener('input', function() {
            lightTransitionValue = parseInt(this.value);
            updateLightTransition(lightTransitionValue);
        });
        
        // Set up canvas (only once during initialization)
        const ctx = canvas.getContext('2d');
        
        // Store the initial dimensions to prevent unnecessary resizing
        if (!canvas.dataset.initialized) {
            canvas.width = canvas.offsetWidth;
            canvas.height = 300; // Fixed height to prevent overflow issues
            canvas.dataset.initialized = 'true';
            console.log('ğŸ¨ Canvas initialized with dimensions:', canvas.width, 'x', canvas.height);
        }
        
        // Initial draw
        updateLightTransition(0);
        
        // Update background when measurements change
        updateTransitionBackground();
        
        console.log('ğŸš€ Light transition slider initialized');
        
        // Handle window resize events to prevent canvas jumping during drawing
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (canvas && canvas.dataset.initialized) {
                    const newWidth = canvas.offsetWidth;
                    if (canvas.width !== newWidth) {
                        canvas.width = newWidth;
                        canvas.height = 300;
                        console.log('ğŸ¨ Canvas resized due to window resize:', canvas.width, 'x', canvas.height);
                        // Redraw with current slider value
                        if (lightTransitionValue !== undefined) {
                            updateLightTransition(lightTransitionValue);
                        }
                    }
                }
            }, 100); // Debounce resize events
        });
        
        // Global mouse event listener to handle drawing interruption
        document.addEventListener('mouseup', function() {
            if (isCurrentlyDrawing) {
                isCurrentlyDrawing = false;
                document.body.classList.remove('drawing-active');
                console.log('ğŸ–±ï¸ Drawing interrupted by global mouse up');
            }
        });
        
        // Handle mouse leaving canvas during drawing
        document.addEventListener('mouseleave', function() {
            if (isCurrentlyDrawing) {
                isCurrentlyDrawing = false;
                document.body.classList.remove('drawing-active');
                console.log('ğŸ–±ï¸ Drawing interrupted by mouse leaving window');
            }
        });
    }
    
    // Update the transition background when measurements change
    function updateTransitionBackground() {
        // This function will be called whenever new measurements are added
        // to refresh the background image for the transition slider
        console.log('ğŸ”„ Updating transition background for new measurements');
        
        // Capture the current background
        captureTransitionBackground().then(() => {
            // Force a redraw of the transition
            if (lightTransitionValue !== undefined) {
                updateLightTransition(lightTransitionValue);
            }
        });
    }
    
    // Update the light transition based on slider value
    function updateLightTransition(value) {
        const canvas = document.getElementById('lightTransitionCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Ensure canvas has proper dimensions (only resize if needed)
        if (canvas.width !== canvas.offsetWidth || canvas.height !== 300) {
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;
            console.log('ğŸ¨ Canvas resized to:', canvas.width, 'x', canvas.height);
        }
        
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Calculate transition values (0 = clean house, 100 = house with lights)
        const lightIntensity = value / 100;
        
        // Draw the background image (clean house without measurement lines)
        drawBackgroundImage(ctx, width, height);
        
        // Draw animated lights if slider is moved
        if (lightIntensity > 0.1) {
            drawRealisticLights(ctx, width, height, lightIntensity);
        }
        
        // Add night mode effect as slider moves right
        if (lightIntensity > 0.3) {
            applyNightModeEffect(ctx, width, height, lightIntensity);
        }
        
        console.log('ğŸ¨ Light transition updated:', { value, lightIntensity });
    }
    
    // Draw the background image (clean house without measurement lines)
    function drawBackgroundImage(ctx, width, height) {
        // Use the stored transition background if available and valid
        if (transitionBackgroundImage && 
            transitionBackgroundImage.width > 0 && 
            transitionBackgroundImage.height > 0) {
            console.log('Using stored transition background:', 
                transitionBackgroundImage.width, 'x', transitionBackgroundImage.height);
            
            // Double-check the canvas is still valid before drawing
            try {
                ctx.drawImage(transitionBackgroundImage, 0, 0, width, height);
                console.log('âœ… Background image drawn successfully');
                return;
            } catch (drawError) {
                console.error('âŒ Error drawing background image:', drawError);
                // Clear the invalid background and use placeholder
                transitionBackgroundImage = null;
            }
        }
        
        // If stored background is invalid, clear it and use placeholder
        if (transitionBackgroundImage && 
            (transitionBackgroundImage.width === 0 || transitionBackgroundImage.height === 0)) {
            console.log('Stored background has invalid dimensions, clearing it');
            transitionBackgroundImage = null;
        }
        
        // Fallback: draw a placeholder
        console.log('Using placeholder background');
        drawPlaceholderBackground(ctx, width, height);
    }
    
    // Store the current background image for the transition slider
    let transitionBackgroundImage = null;
    
    // Capture and store the current background for the transition slider
    async function captureTransitionBackground() {
        try {
            console.log('ğŸ–¼ï¸ Capturing transition background...');
            
            let backgroundCanvas = null;
            
            // Priority 1: Aerial view (most reliable with html2canvas)
            if (map && typeof map.getVisible === 'function' && map.getVisible()) {
                console.log('Capturing aerial view as background');
                backgroundCanvas = await captureAerialViewForBackground();
            }
            // Priority 2: Captured street view (if aerial fails)
            else if (isStreetViewCaptured && capturedStreetViewData) {
                console.log('Using captured street view as background');
                backgroundCanvas = await createImageFromDataURL(capturedStreetViewData.imageData);
            }
            // Priority 3: Live street view (least reliable)
            else if (streetView && typeof streetView.getVisible === 'function' && streetView.getVisible()) {
                console.log('Capturing live street view as background');
                backgroundCanvas = await captureStreetViewForBackground();
            }
            
            if (backgroundCanvas && 
                backgroundCanvas.width > 0 && 
                backgroundCanvas.height > 0) {
                transitionBackgroundImage = backgroundCanvas;
                console.log('âœ… Transition background captured successfully:', 
                    backgroundCanvas.width, 'x', backgroundCanvas.height);
                showStatus('Background captured! Now you can see your house in the transition slider.', 'success');
            } else {
                console.log('âŒ Failed to capture background or invalid dimensions');
                if (backgroundCanvas) {
                    console.log('Canvas dimensions:', backgroundCanvas.width, 'x', backgroundCanvas.height);
                }
                showStatus('Could not capture background. Using placeholder instead.', 'warning');
            }
            
        } catch (error) {
            console.error('Error capturing transition background:', error);
            showStatus('Error capturing background: ' + error.message, 'error');
        }
    }
    
    // Create a canvas from a data URL
    function createImageFromDataURL(dataURL) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                ctx.drawImage(img, 0, 0);
                
                // Validate the canvas was created correctly
                if (canvas.width > 0 && canvas.height > 0) {
                    console.log('âœ… Canvas created successfully from data URL:', canvas.width, 'x', canvas.height);
                    resolve(canvas);
                } else {
                    console.error('âŒ Canvas created with invalid dimensions:', canvas.width, 'x', canvas.height);
                    reject(new Error('Canvas has invalid dimensions'));
                }
            };
            img.onerror = (error) => {
                console.error('âŒ Error loading image from data URL:', error);
                reject(error);
            };
            img.src = dataURL;
        });
    }
    
    // Get street view image (placeholder for now)
    function getStreetViewImage() {
        // This would need to be implemented with actual Street View capture
        // For now, return null to use fallback
        return null;
    }
    
    // Get aerial view image (placeholder for now)
    function getAerialViewImage() {
        // This would need to be implemented with actual aerial capture
        // For now, return null to use fallback
        return null;
    }
    
    // Capture current aerial view for background
    function captureAerialViewForBackground() {
        try {
            if (!map || typeof map.getVisible !== 'function') {
                console.log('Map not initialized or getVisible method not available, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            if (!map.getVisible()) {
                console.log('Map not visible, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            const mapContainer = document.getElementById('map');
            if (!mapContainer) {
                console.log('Map container not found, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            const containerWidth = mapContainer.offsetWidth;
            const containerHeight = mapContainer.offsetHeight;
            
            if (containerWidth === 0 || containerHeight === 0) {
                console.log('Map container has zero dimensions, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            console.log('Capturing aerial view with dimensions:', containerWidth, 'x', containerHeight);
            
            // Use html2canvas to capture the map
            return html2canvas(mapContainer, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#ffffff',
                width: containerWidth,
                height: containerHeight,
                logging: false,
                scale: 1,
                removeContainer: false,
                foreignObjectRendering: false
            }).then(canvas => {
                console.log('Aerial view captured successfully:', canvas.width, 'x', canvas.height);
                
                // Validate the captured image isn't just blank
                const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                
                if (!hasContent) {
                    console.log('Captured aerial view appears blank, using placeholder');
                    return createAerialPlaceholder();
                }
                
                return canvas;
            }).catch(error => {
                console.error('html2canvas failed for aerial view:', error);
                console.log('Using placeholder instead');
                return createAerialPlaceholder();
            });
            
        } catch (error) {
            console.error('Error in captureAerialViewForBackground:', error);
            return Promise.resolve(createAerialPlaceholder());
        }
    }
    
    // Capture aerial view specifically for the slider
    async function captureAerialForSlider() {
        try {
            console.log('ğŸ›°ï¸ Capturing aerial view for slider...');
            
            if (!map || !map.getVisible()) {
                showStatus('Map not visible. Please make sure the aerial view is loaded.', 'warning');
                return;
            }
            
            const backgroundCanvas = await captureAerialViewForBackground();
            
            if (backgroundCanvas && backgroundCanvas.width > 0 && backgroundCanvas.height > 0) {
                transitionBackgroundImage = backgroundCanvas;
                console.log('âœ… Aerial view captured for slider:', backgroundCanvas.width, 'x', backgroundCanvas.height);
                
                // Update the transition slider to show the new background
                updateLightTransition(0);
                
                showStatus('Aerial view captured! Your house should now appear in the slider.', 'success');
            } else {
                showStatus('Failed to capture aerial view. Please try again.', 'error');
            }
            
        } catch (error) {
            console.error('Error capturing aerial for slider:', error);
            showStatus('Error capturing aerial view: ' + error.message, 'error');
        }
    }
    
    // Create aerial placeholder when capture fails
    function createAerialPlaceholder() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 600;
        
        // Create a realistic aerial view background
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#87CEEB'); // Sky blue
        gradient.addColorStop(0.7, '#98FB98'); // Light green
        gradient.addColorStop(1, '#8FBC8F'); // Dark green
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw a simple house from above
        const houseWidth = canvas.width * 0.4;
        const houseHeight = canvas.height * 0.3;
        const houseX = (canvas.width - houseWidth) / 2;
        const houseY = (canvas.height - houseHeight) / 2;
        
        // House body
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(houseX, houseY, houseWidth, houseHeight);
        
        // Roof
        ctx.beginPath();
        ctx.moveTo(houseX - 20, houseY);
        ctx.lineTo(houseX + houseWidth / 2, houseY - 40);
        ctx.lineTo(houseX + houseWidth + 20, houseY);
        ctx.closePath();
        ctx.fill();
        
        // Add some texture to represent roof shingles
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            const y = houseY - 40 + (i * 8);
            ctx.beginPath();
            ctx.moveTo(houseX - 20, y);
            ctx.lineTo(houseX + houseWidth + 20, y);
            ctx.stroke();
        }
        
        return canvas;
    }
    
    // Capture current street view for background using Static Maps API
    async function captureStreetViewForBackground() {
        try {
            if (!streetView || !streetView.getVisible()) {
                console.log('Street View not visible, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            // Get current location from map center (fallback to Street View position)
            let position = streetView.getPosition();
            if (!position && map) {
                position = map.getCenter();
                console.log('Using map center as fallback location for background capture');
            }
            
            if (!position) {
                console.log('No location available, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            if (!googleMapsApiKey) {
                console.log('No API key available, using placeholder');
                return Promise.resolve(createAerialPlaceholder());
            }
            
            console.log('Capturing Street View background using Static Maps API');
            
            // Get current Street View orientation
            const pov = streetView.getPov();
            
            // Build the Google Static Street View API URL
            const url = `https://maps.googleapis.com/maps/api/streetview?size=800x600&location=${position.lat()},${position.lng()}&heading=${Math.round(pov.heading)}&pitch=${Math.round(pov.pitch)}&key=${encodeURIComponent(googleMapsApiKey)}`;
            
            console.log('Fetching Street View background from:', url);
            
            // Fetch the Street View image from Google's servers
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const blob = await response.blob();
            
            // Convert blob to canvas
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            return new Promise((resolve, reject) => {
                img.onload = () => {
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    console.log('Street View background captured successfully:', canvas.width, 'x', canvas.height);
                    resolve(canvas);
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(blob);
            });
            
        } catch (error) {
            console.error('Static Maps API failed for Street View background:', error);
            console.log('Using placeholder instead');
            return Promise.resolve(createAerialPlaceholder());
        }
    }
    
    // Draw placeholder background when no real image is available
    function drawPlaceholderBackground(ctx, width, height) {
        console.log('Drawing placeholder background with dimensions:', width, 'x', height);
        
        // Ensure we have valid dimensions
        if (width <= 0 || height <= 0) {
            console.error('Invalid dimensions for placeholder background:', width, 'x', height);
            return;
        }
        
        // Create a realistic house background
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#87CEEB'); // Sky blue
        gradient.addColorStop(0.7, '#98FB98'); // Light green
        gradient.addColorStop(1, '#8FBC8F'); // Dark green
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        
        // Draw a simple house silhouette
        const houseWidth = width * 0.6;
        const houseHeight = height * 0.4;
        const houseX = (width - houseWidth) / 2;
        const houseY = (height - houseHeight) / 2;
        
        // House body
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(houseX, houseY, houseWidth, houseHeight);
        
        // Roof
        ctx.beginPath();
        ctx.moveTo(houseX - 20, houseY);
        ctx.lineTo(houseX + houseWidth / 2, houseY - 40);
        ctx.lineTo(houseX + houseWidth + 20, houseY);
        ctx.closePath();
        ctx.fill();
        
        // Windows
        const windowSize = 15;
        const windowSpacing = houseWidth / 4;
        
        for (let i = 0; i < 3; i++) {
            const windowX = houseX + windowSpacing + (i * windowSpacing);
            const windowY = houseY + houseHeight / 3;
            
            ctx.fillStyle = '#2F2F2F';
            ctx.fillRect(windowX - windowSize/2, windowY - windowSize/2, windowSize, windowSize);
        }
        
        console.log('Placeholder background drawn successfully');
    }
    
    // Draw realistic lights based on actual measurements
    function drawRealisticLights(ctx, width, height, intensity) {
        // Get the current color scheme and animation mode
        const colorScheme = document.getElementById('colorScheme')?.value || 'rgbw';
        const animationMode = document.getElementById('colorScheme')?.value || 'static';
        const colors = getColorPalette(colorScheme);
        
        // Draw lights based on aerial measurements
        if (measurements.aerial && measurements.aerial.perimeter > 0) {
            drawLightsOnPath(ctx, width, height, 'aerial', intensity, colors, animationMode);
        }
        
        // Draw lights based on street view measurements
        if (measurements.street && measurements.street.total > 0) {
            drawLightsOnPath(ctx, width, height, 'street', intensity, colors, animationMode);
        }
    }
    
    // Draw lights along a specific measurement path
    function drawLightsOnPath(ctx, width, height, pathType, intensity, colors, animationMode) {
        const paths = pathType === 'aerial' ? aerialPaths : streetPaths;
        if (!paths || paths.length === 0) return;
        
        const spacing = parseFloat(document.getElementById('lightSpacing').value);
        const spacingFeet = spacing / 12;
        
        paths.forEach((path, pathIndex) => {
            if (!path || path.length < 2) return;
            
            // Calculate total path length in feet
            let pathLength = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i-1].x;
                const dy = path[i].y - path[i-1].y;
                pathLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // Apply scale factor to convert pixels to feet
            const scaleFactor = pathType === 'aerial' ? aerialScaleFactor : streetScaleFactor;
            const pathLengthFeet = pathLength * scaleFactor;
            
            // Calculate number of lights needed
            const numLights = Math.ceil(pathLengthFeet / spacingFeet);
            
            // Draw lights along the path
            for (let i = 0; i < numLights; i++) {
                const progress = i / numLights;
                const lightPosition = getLightPositionAlongPath(path, progress);
                
                if (lightPosition) {
                    // Scale position to canvas size
                    const x = (lightPosition.x / (pathType === 'aerial' ? aerialCanvas?.width || width : streetCanvas?.width || width)) * width;
                    const y = (lightPosition.y / (pathType === 'aerial' ? aerialCanvas?.height || height : streetCanvas?.height || height)) * height;
                    
                    // Choose color based on animation mode
                    const colorIndex = (i + Math.floor(Date.now() * 0.01)) % colors.length;
                    const color = colors[colorIndex];
                    
                    // Draw the light with animation effects
                    drawAnimatedLight(ctx, x, y, color, intensity, animationMode);
                }
            }
        });
    }
    
    // Get light position along a path
    function getLightPositionAlongPath(path, progress) {
        if (!path || path.length < 2) return null;
        
        const totalLength = path.length - 1;
        const targetIndex = progress * totalLength;
        const index1 = Math.floor(targetIndex);
        const index2 = Math.min(index1 + 1, totalLength);
        const fraction = targetIndex - index1;
        
        if (index1 === index2) {
            return path[index1];
        }
        
        // Interpolate between two points
        const x = path[index1].x + (path[index2].x - path[index1].x) * fraction;
        const y = path[index1].y + (path[index2].y - path[index1].y) * fraction;
        
        return { x, y };
    }
    
    // Draw a single animated light
    function drawAnimatedLight(ctx, x, y, color, intensity, animationMode) {
        const time = Date.now() * 0.001;
        let lightColor = color;
        let alpha = intensity;
        
        // Apply animation effects
        switch (animationMode) {
            case 'twinkle':
                alpha *= 0.5 + 0.5 * Math.sin(time * 3 + x * 0.1);
                break;
            case 'chase':
                alpha *= 0.7 + 0.3 * Math.sin(time * 3 + x * 0.05);
                break;
            case 'fade':
                alpha *= 0.6 + 0.4 * Math.sin(time + x * 0.02);
                break;
            case 'rainbow':
                const hue = (time * 50 + x * 0.5) % 360;
                lightColor = `hsl(${hue}, 0%, 50%)`;
                break;
            case 'patriotic':
                if (color === '#ff0000' || color === '#ffffff' || color === '#0000ff') {
                    alpha *= 0.8 + 0.2 * Math.sin(time * 1.5 + x * 0.03);
                }
                break;
        }
        
        ctx.save();
        ctx.shadowColor = lightColor;
        ctx.shadowBlur = 15 * intensity;
        
        // Outer glow
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = lightColor + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.fill();
        
        // Light circle
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = lightColor + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.fill();
        
        // Bright center
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff' + Math.floor(alpha * 0.255).toString(16).padStart(2, '0');
        ctx.fill();
        
        ctx.restore();
    }
    
    // Apply night mode effect to the background
    function applyNightModeEffect(ctx, width, height, intensity) {
        // Create a dark overlay that gets darker as slider moves right
        const alpha = intensity * 0.6; // Max 60% darkness
        
        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.fillRect(0, 0, width, height);
        
        // Add subtle blue tint for night effect
        if (intensity > 0.5) {
            const blueAlpha = (intensity - 0.5) * 0.3; // Max 30% blue tint
            
            ctx.fillStyle = `rgba(0, 0, 100, ${blueAlpha})`;
            ctx.fillRect(0, 0, width, height);
        }
    }
    
    // Draw stars in the night sky
    function drawStars(ctx, width, height, intensity) {
        const numStars = 50;
        ctx.fillStyle = '#ffffff';
        
        for (let i = 0; i < numStars; i++) {
            const x = (i * 37) % width;
            const y = (i * 73) % (height * 0.6);
            const size = (Math.sin(i + Date.now() * 0.001) * 0.5 + 0.5) * 2 * intensity;
            
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Play the light transition animation
    function playLightTransition() {
        if (isTransitionPlaying) return;
        
        isTransitionPlaying = true;
        document.getElementById('playTransitionBtn').style.display = 'none';
        document.getElementById('pauseTransitionBtn').style.display = 'inline-block';
        
        lightTransitionAnimation = setInterval(() => {
            lightTransitionValue = (lightTransitionValue + 1) % 101;
            document.getElementById('lightTransitionSlider').value = lightTransitionValue;
            updateLightTransition(lightTransitionValue);
            
            if (lightTransitionValue === 100) {
                lightTransitionValue = 0;
            }
        }, 100);
        
        console.log('â–¶ï¸ Light transition animation started');
    }
    
    // Pause the light transition animation
    function pauseLightTransition() {
        if (!isTransitionPlaying) return;
        
        isTransitionPlaying = false;
        clearInterval(lightTransitionAnimation);
        lightTransitionAnimation = null;
        
        document.getElementById('playTransitionBtn').style.display = 'inline-block';
        document.getElementById('pauseTransitionBtn').style.display = 'none';
        
        console.log('â¸ï¸ Light transition animation paused');
    }
    
    // Reset the light transition
    function resetLightTransition() {
        pauseLightTransition();
        
        lightTransitionValue = 0;
        document.getElementById('lightTransitionSlider').value = 0;
        updateLightTransition(0);
        
        document.getElementById('playTransitionBtn').style.display = 'inline-block';
        document.getElementById('pauseTransitionBtn').style.display = 'none';
        
        console.log('ğŸ”„ Light transition reset to day view');
    }

    // Test function to debug captured view display
    function testCapturedViewDisplay() {
        console.log('ğŸ§ª testCapturedViewDisplay() called');
        
        // Check if we have captured data
        if (!capturedStreetViewData) {
            console.log('âŒ No captured data available, creating test data');
            capturedStreetViewData = {
                imageData: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmY5ODAwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0iIzMzMyIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPlRlc3QgQ2FwdHVyZWQgVmlldzwvdGV4dD48L3N2Zz4=',
                width: 400,
                height: 300,
                timestamp: Date.now()
            };
        }
        
        // Debug the captured container elements
        const capturedContainer = document.getElementById('capturedStreetViewContainer');
        const capturedImage = document.getElementById('capturedStreetViewImage');
        const capturedCanvas = document.getElementById('capturedStreetCanvas');
        
        console.log('ğŸ” Debugging captured elements:');
        console.log('Container:', capturedContainer);
        console.log('Image:', capturedImage);
        console.log('Canvas:', capturedCanvas);
        
        if (capturedContainer) {
            console.log('ğŸ“ Container styles:', {
                display: capturedContainer.style.display,
                position: capturedContainer.style.position,
                top: capturedContainer.style.top,
                left: capturedContainer.style.left,
                width: capturedContainer.style.width,
                height: capturedContainer.style.height,
                zIndex: capturedContainer.style.zIndex,
                background: capturedContainer.style.background
            });
            console.log('ğŸ“ Container computed styles:', {
                display: window.getComputedStyle(capturedContainer).display,
                position: window.getComputedStyle(capturedContainer).position,
                top: window.getComputedStyle(capturedContainer).top,
                left: window.getComputedStyle(capturedContainer).left,
                width: window.getComputedStyle(capturedContainer).width,
                height: window.getComputedStyle(capturedContainer).height,
                zIndex: window.getComputedStyle(capturedContainer).zIndex
            });
        }
        
        // Try to switch to captured view
        console.log('ğŸ”„ Attempting to switch to captured view with test data');
        switchToCapturedView();
    }

    // Fallback capture method for when panorama API is not available
    function captureVisibleStreetView() {
        try {
            console.log('Using fallback capture method');
            showCaptureStatus('Using fallback capture method...');
            
            const streetViewContainer = document.getElementById('streetView');
            const containerWidth = streetViewContainer.offsetWidth;
            const containerHeight = streetViewContainer.offsetHeight;
            
            // Create a canvas to capture what's visible
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            captureCanvas.width = containerWidth;
            captureCanvas.height = containerHeight;
            
            // Try to capture the actual Street View content if possible
            try {
                // Get the Street View panorama element
                const panoramaElement = streetViewContainer.querySelector('canvas, img, div[data-pano]');
                if (panoramaElement) {
                    console.log('Found panorama element, attempting to capture');
                    
                    // Try to draw the panorama element to our canvas
                    if (panoramaElement.tagName === 'CANVAS') {
                        captureCtx.drawImage(panoramaElement, 0, 0, containerWidth, containerHeight);
                    } else if (panoramaElement.tagName === 'IMG') {
                        captureCtx.drawImage(panoramaElement, 0, 0, containerWidth, containerHeight);
                    } else {
                        // For other elements, try to capture the visible content
                        throw new Error('Unsupported panorama element type');
                    }
                } else {
                    throw new Error('No panorama element found');
                }
            } catch (captureError) {
                console.log('Could not capture actual content, using placeholder:', captureError);
                
                // Fill with a background color to represent the capture
                captureCtx.fillStyle = '#f0f0f0';
                captureCtx.fillRect(0, 0, containerWidth, containerHeight);
                
                // Add text to indicate this is a captured view
                captureCtx.fillStyle = '#333';
                captureCtx.font = '16px Arial';
                captureCtx.textAlign = 'center';
                captureCtx.fillText('Street View Captured', containerWidth / 2, containerHeight / 2);
                captureCtx.font = '14px Arial';
                captureCtx.fillText('You can now draw on this static image', containerWidth / 2, containerHeight / 2 + 30);
                captureCtx.fillText('(Fallback mode)', containerWidth / 2, containerHeight / 2 + 50);
            }
            
            // Convert to data URL
            const dataURL = captureCanvas.toDataURL('image/png');
            
            // Store captured data
            capturedStreetViewData = {
                imageData: dataURL,
                width: containerWidth,
                height: containerHeight,
                timestamp: Date.now()
            };
            
            console.log('Fallback capture completed, switching to captured view');
            hideCaptureStatus();
            
            // Switch to captured view
            switchToCapturedView();
            
            showStatus('Street View captured! You can now draw on the static image.', 'success');
            
        } catch (error) {
            console.error('Error in fallback capture:', error);
            hideCaptureStatus();
            showStatus('Error capturing Street View. Please try again.', 'error');
        }
    }
    
    // Switch from live Street View to captured static image
    function switchToCapturedView() {
        try {
            console.log('ğŸ”„ switchToCapturedView called with data:', capturedStreetViewData);
            
            if (!capturedStreetViewData) {
                console.error('âŒ No captured Street View data available');
                showStatus('No captured Street View available.', 'error');
                return;
            }
            
            console.log('ğŸ“Š Captured data details:', {
                hasImageData: !!capturedStreetViewData.imageData,
                width: capturedStreetViewData.width,
                height: capturedStreetViewData.height,
                timestamp: capturedStreetViewData.timestamp
            });
            
            // Hide the live Street View and canvas
            const streetViewDiv = document.getElementById('streetView');
            const streetCanvas = document.getElementById('streetCanvas');
            
            console.log('ğŸ‘ï¸ Hiding live elements:', { 
                streetViewDiv: !!streetViewDiv, 
                streetCanvas: !!streetCanvas 
            });
            
            if (streetViewDiv) streetViewDiv.style.display = 'none';
            if (streetCanvas) streetCanvas.style.display = 'none';
            
            // Show the captured image container
            const capturedContainer = document.getElementById('capturedStreetViewContainer');
            const capturedImage = document.getElementById('capturedStreetViewImage');
            const capturedCanvas = document.getElementById('capturedStreetCanvas');
            
            console.log('ğŸ” Found captured elements:', { 
                capturedContainer: !!capturedContainer, 
                capturedImage: !!capturedImage, 
                capturedCanvas: !!capturedCanvas 
            });
            
            if (capturedContainer && capturedImage && capturedCanvas) {
                console.log('âœ… Setting up captured image with dimensions:', {
                    width: capturedStreetViewData.width,
                    height: capturedStreetViewData.height
                });
                
                // Set the captured image
                capturedImage.src = capturedStreetViewData.imageData;
                capturedImage.width = capturedStreetViewData.width;
                capturedImage.height = capturedStreetViewData.height;
                
                console.log('ğŸ–¼ï¸ Image src set to:', capturedImage.src.substring(0, 100) + '...');
                
                // Set up the captured canvas for drawing
                capturedCanvas.width = capturedStreetViewData.width;
                capturedCanvas.height = capturedStreetViewData.height;
                
                // Show the captured view and ensure proper positioning
                capturedContainer.style.display = 'block';
                capturedContainer.style.position = 'relative';
                capturedContainer.style.top = 'auto';
                capturedContainer.style.left = 'auto';
                capturedContainer.style.width = '100%';
                capturedContainer.style.height = '100%';
                capturedContainer.style.zIndex = '1';
                capturedContainer.style.backgroundColor = '#000';
                
                // Ensure the parent container has relative positioning and proper height
                const parentContainer = capturedContainer.parentElement;
                if (parentContainer) {
                    parentContainer.style.position = 'relative';
                    // Force the parent container to have a height
                    if (parentContainer.id === 'streetContainer') {
                        parentContainer.style.height = '400px';
                        parentContainer.style.minHeight = '400px';
                    }
                }
                
                console.log('ğŸ“± Captured container display set to block');
                
                // Small delay to ensure DOM has updated
                setTimeout(() => {
                    console.log('ğŸ“ Container dimensions after delay:', {
                        offsetWidth: capturedContainer.offsetWidth,
                        offsetHeight: capturedContainer.offsetHeight,
                        style: capturedContainer.style.cssText
                    });
                }, 100);
                
                // Set up drawing on the captured canvas
                setupCapturedStreetCanvas();
                
                // Update button states
                const captureBtn = document.getElementById('captureStreetViewBtn');
                const resetBtn = document.getElementById('resetStreetViewBtn');
                if (captureBtn) captureBtn.style.display = 'none';
                if (resetBtn) resetBtn.style.display = 'block';
                
                isStreetViewCaptured = true;
                
                console.log('ğŸ‰ Successfully switched to captured Street View');
                showStatus('Street View captured and displayed! You can now draw on the static image.', 'success');
                
                // Update light visualization for the new view
                setTimeout(() => {
                    updateLightVisualization();
                }, 100);
            } else {
                console.error('âŒ Missing required elements for captured view');
                showStatus('Error: Missing elements for captured view display.', 'error');
            }
            
        } catch (error) {
            console.error('âŒ Error switching to captured view:', error);
            showStatus('Error switching to captured view.', 'error');
        }
    }
    
    // Set up drawing functionality on the captured Street View canvas
    function setupCapturedStreetCanvas() {
        try {
            const capturedCanvas = document.getElementById('capturedStreetCanvas');
            if (!capturedCanvas) return;
            
            const capturedCtx = capturedCanvas.getContext('2d');
            
            // Set canvas dimensions to match the container
            const container = capturedCanvas.parentElement;
            if (container) {
                capturedCanvas.width = container.offsetWidth;
                capturedCanvas.height = container.offsetHeight;
                console.log('Captured Street Canvas dimensions set to:', capturedCanvas.width, 'x', capturedCanvas.height);
            }
            
            // Store existing drawing data before reinitializing
            const existingDrawingData = capturedCanvas.drawingData ? { ...capturedCanvas.drawingData } : null;
            
            // Initialize drawing data for captured canvas
            capturedCanvas.drawingData = {
                paths: [],
                currentPath: [],
                isDrawing: false,
                startPoint: null
            };
            
            // Clear any existing event listeners
            const newCanvas = capturedCanvas.cloneNode(true);
            capturedCanvas.parentNode.replaceChild(newCanvas, capturedCanvas);
            
            // Get the new canvas reference
            const newCapturedCanvas = document.getElementById('capturedStreetCanvas');
            const newCapturedCtx = newCapturedCanvas.getContext('2d');
            
            // Set dimensions for the new canvas
            if (container) {
                newCapturedCanvas.width = container.offsetWidth;
                newCapturedCanvas.height = container.offsetHeight;
                console.log('New Captured Street Canvas dimensions set to:', newCapturedCanvas.width, 'x', newCapturedCanvas.height);
            }
            
            // Re-initialize drawing data
            newCapturedCanvas.drawingData = {
                paths: [],
                currentPath: [],
                isDrawing: false,
                startPoint: null
            };
            
            // Restore existing paths if they exist
            if (existingDrawingData && existingDrawingData.paths) {
                newCapturedCanvas.drawingData.paths = [...existingDrawingData.paths];
                newCapturedCanvas.drawingData.currentPath = existingDrawingData.currentPath || [];
                newCapturedCanvas.drawingData.isDrawing = existingDrawingData.isDrawing || false;
                
                // Redraw all existing paths
                redrawAllPaths(newCapturedCanvas, newCapturedCtx, 'capturedStreet');
            }
            
            // Set up drawing event listeners based on current drawing mode
            if (drawingMode === 'straight') {
                newCapturedCanvas.addEventListener('click', (e) => handleStraightLineClick(e, newCapturedCanvas, newCapturedCtx, 'capturedStreet'));
                newCapturedCanvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (newCapturedCanvas.drawingData.currentPath && newCapturedCanvas.drawingData.currentPath.length >= 2) {
                        newCapturedCanvas.drawingData.paths.push([...newCapturedCanvas.drawingData.currentPath]);
                        
                        // Also update global captured street paths
                        capturedStreetPaths.push([...newCapturedCanvas.drawingData.currentPath]);
                        
                        newCapturedCanvas.drawingData.currentPath = [];
                        calculateMeasurementsFromPaths(newCapturedCanvas, 'capturedStreet');
                        showStatus('Straight line path completed! Right-click to finish future paths.', 'success');
                    }
                });
                newCapturedCanvas.addEventListener('dblclick', (e) => {
                    if (newCapturedCanvas.drawingData.currentPath && newCapturedCanvas.drawingData.currentPath.length >= 2) {
                        newCapturedCanvas.drawingData.paths.push([...newCapturedCanvas.drawingData.currentPath]);
                        
                        // Also update global captured street paths
                        capturedStreetPaths.push([...newCapturedCanvas.drawingData.currentPath]);
                        
                        newCapturedCanvas.drawingData.currentPath = [];
                        calculateMeasurementsFromPaths(newCapturedCanvas, 'capturedStreet');
                        showStatus('Straight line path completed! Right-click to finish future paths.', 'success');
                    }
                });
            } else if (drawingMode === 'freehand') {
                newCapturedCanvas.addEventListener('mousedown', (e) => startFreehand(e, newCapturedCanvas, newCapturedCtx, 'capturedStreet'));
                newCapturedCanvas.addEventListener('mousemove', (e) => drawFreehand(e, newCapturedCanvas, newCapturedCtx, 'capturedStreet'));
                newCapturedCanvas.addEventListener('mouseup', (e) => endFreehand(e, newCapturedCanvas, newCapturedCtx, 'capturedStreet'));
                newCapturedCanvas.addEventListener('mouseleave', (e) => endFreehand(e, newCapturedCanvas, newCapturedCtx, 'capturedStreet'));
            }
            
            // Touch support for mobile
            newCapturedCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                if (drawingMode === 'freehand') {
                    startFreehand(mouseEvent, newCapturedCanvas, newCapturedCtx, 'capturedStreet');
                } else {
                    handleStraightLineClick(mouseEvent, newCapturedCanvas, newCapturedCtx, 'capturedStreet');
                }
            });
            
            newCapturedCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (drawingMode === 'freehand') {
                    const touch = e.touches[0];
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    drawFreehand(mouseEvent, newCapturedCanvas, newCapturedCtx, 'capturedStreet');
                }
            });
            
            newCapturedCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (drawingMode === 'freehand') {
                    const mouseEvent = new MouseEvent('mouseup', {});
                    endFreehand(mouseEvent, newCapturedCanvas, newCapturedCtx, 'capturedStreet');
                }
            });
            
            console.log('Captured Street View canvas setup complete');
            
        } catch (error) {
            console.error('Error setting up captured Street View canvas:', error);
        }
    }
    
    // Show capture status overlay
    function showCaptureStatus(message) {
        const overlay = document.getElementById('captureStatusOverlay');
        const statusText = document.getElementById('captureStatusText');
        if (overlay && statusText) {
            statusText.textContent = message;
            overlay.style.display = 'block';
        }
    }
    
    // Hide capture status overlay
    function hideCaptureStatus() {
        const overlay = document.getElementById('captureStatusOverlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }
    
    // Test capture functionality
    function testCapture() {
        try {
            console.log('Testing capture functionality...');
            
            // Create a simple test image
            const testCanvas = document.createElement('canvas');
            const testCtx = testCanvas.getContext('2d');
            testCanvas.width = 400;
            testCanvas.height = 300;
            
            // Draw a test pattern
            testCtx.fillStyle = '#4CAF50';
            testCtx.fillRect(0, 0, 400, 300);
            testCtx.fillStyle = '#fff';
            testCtx.font = '24px Arial';
            testCtx.textAlign = 'center';
            testCtx.fillText('Test Street View Capture', 200, 150);
            testCtx.font = '16px Arial';
            testCtx.fillText('This is a test image to verify the capture system', 200, 180);
            
            // Convert to data URL
            const testDataURL = testCanvas.toDataURL('image/png');
            
            // Store as captured data
            capturedStreetViewData = {
                imageData: testDataURL,
                width: 400,
                height: 300,
                timestamp: Date.now()
            };
            
            console.log('Test capture created, switching to captured view');
            
            // Switch to captured view
            switchToCapturedView();
            
            showStatus('Test capture successful! You can now draw on the test image.', 'success');
            
        } catch (error) {
            console.error('Error in test capture:', error);
            showStatus('Error in test capture.', 'error');
        }
    }
    
    // Debug Street View functionality
    function debugStreetView() {
        try {
            console.log('ğŸ› Debugging Street View...');
            
            // Check if Street View is available
            const streetViewElement = document.getElementById('streetView');
            console.log('Street View element:', streetViewElement);
            
            if (streetViewElement) {
                console.log('Street View element found');
                console.log('Dimensions:', streetViewElement.offsetWidth, 'x', streetViewElement.offsetHeight);
                console.log('Display style:', streetViewElement.style.display);
                console.log('Visibility:', streetViewElement.style.visibility);
                
                // Check for panorama elements
                const panoramaElements = streetViewElement.querySelectorAll('*');
                console.log('Total child elements:', panoramaElements.length);
                
                panoramaElements.forEach((element, index) => {
                    if (element.tagName === 'CANVAS' || element.tagName === 'IMG') {
                        console.log(`Found ${element.tagName} at index ${index}:`, element);
                        console.log('Dimensions:', element.width || element.offsetWidth, 'x', element.height || element.offsetHeight);
                    }
                });
                
                // Check if Google Maps API is loaded
                if (typeof google !== 'undefined' && google.maps) {
                    console.log('Google Maps API loaded');
                    if (streetView) {
                        console.log('Street View object available');
                        console.log('Position:', streetView.getPosition());
                        console.log('POV:', streetView.getPov());
                        console.log('Visible:', streetView.getVisible());
                    } else {
                        console.log('Street View object not available');
                    }
                } else {
                    console.log('Google Maps API not loaded');
                }
                
                showStatus('Debug info logged to console. Check browser console for details.', 'success');
            } else {
                console.log('Street View element not found');
                showStatus('Street View element not found', 'error');
            }
            
        } catch (error) {
            console.error('Error debugging Street View:', error);
            showStatus('Error during debug: ' + error.message, 'error');
        }
    }
    
    // Reset back to live Street View
    function resetStreetView() {
        try {
            // Hide captured view
            const capturedContainer = document.getElementById('capturedStreetViewContainer');
            if (capturedContainer) capturedContainer.style.display = 'none';
            
            // Show live Street View and canvas
            const streetViewDiv = document.getElementById('streetView');
            const streetCanvas = document.getElementById('streetCanvas');
            if (streetViewDiv) streetViewDiv.style.display = 'block';
            if (streetCanvas) streetCanvas.style.display = 'block';
            
            // Update button states
            document.getElementById('captureStreetViewBtn').style.display = 'block';
            document.getElementById('resetStreetViewBtn').style.display = 'none';
            
            // Clear captured data
            capturedStreetViewData = null;
            isStreetViewCaptured = false;
            
            // Clear captured street paths
            capturedStreetPaths = [];
            
            showStatus('Returned to live Street View', 'success');
            console.log('Reset to live Street View');
            
            // Update light visualization for the live view
            setTimeout(() => {
                updateLightVisualization();
            }, 100);
            
        } catch (error) {
            console.error('Error resetting Street View:', error);
            showStatus('Error resetting Street View.', 'error');
        }
    }
    
    // Update the drawing mode to work with both live and captured canvases
    function setDrawingMode(mode) {
        drawingMode = mode;
        
        // Update button states with null checks
        const straightModeBtn = document.getElementById('straightMode');
        const freehandModeBtn = document.getElementById('freehandMode');
        
        if (straightModeBtn) {
            straightModeBtn.classList.toggle('active', mode === 'straight');
        }
        if (freehandModeBtn) {
            freehandModeBtn.classList.toggle('active', mode === 'freehand');
        }
        
        // Update help text with null checks
        const straightModeHelp = document.getElementById('straightModeHelp');
        const freehandModeHelp = document.getElementById('freehandModeHelp');
        
        if (straightModeHelp) {
            straightModeHelp.style.display = mode === 'straight' ? 'block' : 'none';
        }
        if (freehandModeHelp) {
            freehandModeHelp.style.display = mode === 'freehand' ? 'block' : 'none';
        }
        
        // Re-setup canvases with new mode - this will now preserve existing paths
        if (aerialCanvas) {
            setupEnhancedCanvas(aerialCanvas, aerialCtx, 'aerial');
        }
        
        if (isStreetViewCaptured) {
            // Re-setup captured Street View canvas
            setupCapturedStreetCanvas();
        } else if (streetCanvas) {
            // Re-setup live Street View canvas
            setupEnhancedCanvas(streetCanvas, streetCtx, 'street');
        }
        
        updateCurrentModeStatus();
        
        showStatus(`Drawing mode changed to: ${mode}`, 'success');
    }

    // ===== EAVES/GABLES CLASSIFICATION SYSTEM =====
    function classifyLineAsEaveOrGable(path, type) {
        if (!path || path.length < 2) return 'unknown';
        
        // Calculate the overall slope of the line
        const startPoint = path[0];
        const endPoint = path[path.length - 1];
        
        // For Street View: classify based on slope
        if (type === 'street' || type === 'capturedStreet') {
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            
            // Calculate angle in degrees
            const angle = Math.abs(Math.atan2(dy, dx) * 180 / Math.PI);
            
            // Classify based on angle:
            // 0-15Â° or 165-180Â° = mostly horizontal (eave)
            // 15-75Â° or 105-165Â° = sloped (gable)
            // 75-105Â° = mostly vertical (gable)
            if ((angle >= 0 && angle <= 15) || (angle >= 165 && angle <= 180)) {
                return 'eave';
            } else if ((angle >= 15 && angle <= 75) || (angle >= 105 && angle <= 165)) {
                return 'gable';
            } else {
                return 'gable'; // Vertical lines are gables
            }
        }
        
        // For aerial: return 'unknown' to allow manual selection
        return 'unknown';
    }

    function setupAerialLineSelection() {
        const aerialCanvas = document.getElementById('aerialCanvas');
        if (!aerialCanvas) return;
        
        // Add click handler for line selection
        aerialCanvas.addEventListener('click', function(e) {
            const rect = aerialCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Find the closest line to the click
            const closestLine = findClosestLine(x, y, aerialCanvas.drawingData.paths);
            if (closestLine) {
                showLineClassificationDialog(closestLine);
            }
        });
    }

    function findClosestLine(clickX, clickY, paths) {
        if (!paths || paths.length === 0) return null;
        
        let closestLine = null;
        let closestDistance = Infinity;
        
        paths.forEach((path, pathIndex) => {
            for (let i = 1; i < path.length; i++) {
                const distance = pointToLineDistance(clickX, clickY, path[i-1], path[i]);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestLine = {
                        pathIndex: pathIndex,
                        segmentIndex: i-1,
                        path: path,
                        distance: distance
                    };
                }
            }
        });
        
        // Only return if click is within reasonable distance (20 pixels)
        return closestDistance <= 20 ? closestLine : null;
    }

    function pointToLineDistance(px, py, lineStart, lineEnd) {
        const A = px - lineStart.x;
        const B = py - lineStart.y;
        const C = lineEnd.x - lineStart.x;
        const D = lineEnd.y - lineStart.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) return Math.sqrt(A * A + B * B);
        
        let param = dot / lenSq;
        
        let xx, yy;
        if (param < 0) {
            xx = lineStart.x;
            yy = lineStart.y;
        } else if (param > 1) {
            xx = lineEnd.x;
            yy = lineEnd.y;
        } else {
            xx = lineStart.x + param * C;
            yy = lineStart.y + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function showLineClassificationDialog(lineData) {
        // Create modal dialog
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;
        
        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 300px;
        `;
        
        dialog.innerHTML = `
            <h3>Classify Line</h3>
            <p>Is this line an eave or gable?</p>
            <div style="margin: 20px 0;">
                <button id="classifyEave" style="margin: 10px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Eave (Horizontal)</button>
                <button id="classifyGable" style="margin: 10px; padding: 10px 20px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Gable (Sloped/Vertical)</button>
            </div>
            <button id="cancelClassification" style="padding: 8px 16px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Cancel</button>
        `;
        
        modal.appendChild(dialog);
        document.body.appendChild(modal);
        
        // Add event listeners
        document.getElementById('classifyEave').onclick = () => {
            classifyAerialLine(lineData, 'eave');
            document.body.removeChild(modal);
        };
        
        document.getElementById('classifyGable').onclick = () => {
            classifyAerialLine(lineData, 'gable');
            document.body.removeChild(modal);
        };
        
        document.getElementById('cancelClassification').onclick = () => {
            document.body.removeChild(modal);
        };
    }

    function classifyAerialLine(lineData, classification) {
        // Store the classification with the line data
        if (!aerialCanvas.drawingData.paths[lineData.pathIndex].classification) {
            aerialCanvas.drawingData.paths[lineData.pathIndex].classification = [];
        }
        
        aerialCanvas.drawingData.paths[lineData.pathIndex].classification.push({
            segment: lineData.segmentIndex,
            type: classification
        });
        
        // Update measurements with the new classification
        calculateMeasurementsFromPaths(aerialCanvas, 'aerial');
        
        // Show confirmation
        showStatus(`Line classified as ${classification}`, 'success');
    }

        // Enhanced measurement calculation with side classification
    function calculateMeasurementsFromPaths(canvas, type) {
        const paths = canvas.drawingData.paths;
        if (!paths || paths.length === 0) {
            console.log('No paths to calculate measurements from:', { type, paths });
            return;
        }
        
        console.log('Calculating measurements:', { type, paths, pathsLength: paths.length });
        
        let totalLength = 0;
        
        // Initialize measurements for this type
        if (!measurements[type]) {
            measurements[type] = {};
        }
        
        // Initialize segments array if it doesn't exist
        if (!measurements[type].segments) {
            measurements[type].segments = [];
        }
        
        // Only calculate from the most recent path (the last one added)
        const currentPath = paths[paths.length - 1];
        if (!currentPath || currentPath.length < 2) {
            console.log('No valid current path to measure');
            return;
        }
        
        console.log('Measuring current path:', currentPath);
        
        // Calculate length only from the current path
        for (let i = 1; i < currentPath.length; i++) {
            const dx = currentPath[i].x - currentPath[i-1].x;
            const dy = currentPath[i].y - currentPath[i-1].y;
            const segmentLength = Math.sqrt(dx * dx + dy * dy);
            
            // Store individual segment measurements
            measurements[type].segments.push({
                start: currentPath[i-1],
                end: currentPath[i],
                length: segmentLength,
                type: 'front', // Default to front for now
                side: 'front'
            });
            
            totalLength += segmentLength;
            console.log(`Segment ${i-1} to ${i}: length=${segmentLength.toFixed(2)}`);
        }
        
        console.log('Current path pixel length:', totalLength);
        
        // Convert pixels to feet based on scale
        let scaleFactor = type === 'aerial' ? aerialScaleFactor : streetScaleFactor;
        let totalFeet = totalLength * scaleFactor;
        
        console.log('Scale conversion:', { type, scaleFactor, totalLength, totalFeet });
        
        // Update measurements based on selected side
        if (type === 'aerial') {
            // Get the currently selected side for aerial view
            const currentSide = getCurrentAerialSide();
            
            // ADD to the side measurement (accumulate multiple lines on same side)
            const existingMeasurement = measurements.aerial[currentSide] || 0;
            measurements.aerial[currentSide] = Math.round(existingMeasurement + totalFeet);
            
            // Recalculate total from all sides
            measurements.aerial.perimeter = (measurements.aerial.front || 0) + 
                                          (measurements.aerial.leftSide || 0) + 
                                          (measurements.aerial.rightSide || 0) + 
                                          (measurements.aerial.back || 0);
            
            console.log('Updated aerial measurements:', measurements.aerial);
            
            // Update display elements safely
            const frontElement = document.getElementById('aerialFront');
            const leftElement = document.getElementById('aerialLeftSide');
            const rightElement = document.getElementById('aerialRightSide');
            const backElement = document.getElementById('aerialBack');
            const totalElement = document.getElementById('aerialTotal');
            
            if (frontElement) frontElement.textContent = measurements.aerial.front || 0;
            if (leftElement) leftElement.textContent = measurements.aerial.leftSide || 0;
            if (rightElement) rightElement.textContent = measurements.aerial.rightSide || 0;
            if (backElement) backElement.textContent = measurements.aerial.back || 0;
            if (totalElement) totalElement.textContent = measurements.aerial.perimeter;
        } else if (type === 'street' || type === 'capturedStreet') {
            // Get the currently selected side for street view
            const currentSide = getCurrentStreetSide();
            
            // Initialize the side measurement if it doesn't exist
            if (!measurements.street[currentSide]) {
                measurements.street[currentSide] = 0;
            }
            
            // ADD to the side measurement (accumulate multiple lines on same side)
            const existingMeasurement = measurements.street[currentSide] || 0;
            measurements.street[currentSide] = Math.round(existingMeasurement + totalFeet);
            
            // Recalculate total from all sides
            measurements.street.total = (measurements.street.front || 0) + 
                                      (measurements.street.leftSide || 0) + 
                                      (measurements.street.rightSide || 0) + 
                                      (measurements.street.back || 0);
            
            console.log('Updated street measurements:', measurements.street);
            
            // Update display elements safely
            const frontElement = document.getElementById('streetFront');
            const leftElement = document.getElementById('streetLeftSide');
            const rightElement = document.getElementById('streetRightSide');
            const backElement = document.getElementById('streetBack');
            const totalElement = document.getElementById('streetTotal');
            
            if (frontElement) frontElement.textContent = measurements.street.front || 0;
            if (leftElement) leftElement.textContent = measurements.street.leftSide || 0;
            if (rightElement) rightElement.textContent = measurements.street.rightSide || 0;
            if (backElement) backElement.textContent = measurements.street.back || 0;
            if (totalElement) totalElement.textContent = measurements.street.total;
        }
        
        // Update light visualization and pricing
        updateLightVisualization();
        updatePricing();
        
        // Log the updated measurements for debugging
        console.log('Measurements updated:', {
            aerial: measurements.aerial,
            street: measurements.street,
            totalFeet: (measurements.aerial?.perimeter || 0) + (measurements.street?.total || 0)
        });
    }
    
    // Helper function to get current aerial side
    function getCurrentAerialSide() {
        const frontBtn = document.getElementById('sideFront');
        const leftBtn = document.getElementById('sideLeft');
        const rightBtn = document.getElementById('sideRight');
        const backBtn = document.getElementById('sideBack');
        
        if (frontBtn && frontBtn.classList.contains('active')) return 'front';
        if (leftBtn && leftBtn.classList.contains('active')) return 'leftSide';
        if (rightBtn && rightBtn.classList.contains('active')) return 'rightSide';
        if (backBtn && backBtn.classList.contains('active')) return 'back';
        
        return 'front'; // Default to front
    }
    
    // Helper function to get current street side
    function getCurrentStreetSide() {
        const sideSelect = document.getElementById('streetSideSelect');
        if (sideSelect) {
            return sideSelect.value;
        }
        return 'front'; // Default to front
    }

    // ===== NIGHT VISUALIZATION SYSTEM =====
let nightMode = {
    aerial: false,
    street: false
};

// Initialize night mode system
function initializeNightMode() {
    // Set initial button states
    const aerialBtn = document.getElementById('aerialNightView');
    const streetBtn = document.getElementById('streetNightView');
    
    if (aerialBtn) aerialBtn.textContent = 'ğŸŒ™ Night View';
    if (streetBtn) streetBtn.textContent = 'ğŸŒ™ Night View';
    
    // Hide status initially
    const statusDiv = document.getElementById('nightModeStatus');
    if (statusDiv) statusDiv.style.display = 'none';
    
    console.log('Night mode system initialized');
}

    // ===== LIGHT PREVIEW FUNCTIONS =====
    
    function toggleAerialLightPreview() {
        const previewContainer = document.getElementById('aerialLightPreview');
        const previewCanvas = document.getElementById('aerialLightPreviewCanvas');
        const toggleBtn = document.getElementById('toggleAerialLights');
        
        if (previewContainer.style.display === 'none' || !previewContainer.style.display) {
            // Show preview
            previewContainer.style.display = 'block';
            toggleBtn.textContent = 'ğŸ”„ Hide Aerial Light Preview';
            toggleBtn.style.background = '#ff9800';
            
            // Draw lights on preview canvas
            drawLightPreview('aerial', previewCanvas);
        } else {
            // Hide preview
            previewContainer.style.display = 'none';
            toggleBtn.textContent = 'ğŸŒŸ Toggle Aerial Light Preview';
            toggleBtn.style.background = '';
        }
    }
    
    function toggleStreetLightPreview() {
        const previewContainer = document.getElementById('streetLightPreview');
        const previewCanvas = document.getElementById('streetLightPreviewCanvas');
        const toggleBtn = document.getElementById('toggleStreetLights');
        
        if (previewContainer.style.display === 'none' || !previewContainer.style.display) {
            // Show preview
            previewContainer.style.display = 'block';
            toggleBtn.textContent = 'ğŸ”„ Hide Street Light Preview';
            toggleBtn.style.background = '#ff9800';
            
            // Draw lights on preview canvas
            drawLightPreview('street', previewCanvas);
        } else {
            // Hide preview
            previewContainer.style.display = 'none';
            toggleBtn.textContent = 'ğŸŒŸ Toggle Street Light Preview';
            toggleBtn.style.background = '';
        }
    }
    
    function drawLightPreview(viewType, canvas) {
        if (!canvas) {
            console.log('drawLightPreview: No canvas provided');
            return;
        }
        
        console.log('drawLightPreview called for:', viewType);
        console.log('Canvas:', canvas);
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        
        console.log('Canvas rect:', rect);
        
        // Set canvas size
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        console.log('Canvas dimensions set to:', canvas.width, 'x', canvas.height);
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Get measurements for this view type
        let totalFeet = 0;
        if (viewType === 'aerial' && measurements.aerial) {
            totalFeet = measurements.aerial.perimeter;
            console.log('Aerial measurements found:', measurements.aerial);
        } else if (viewType === 'street' && measurements.street) {
            totalFeet = measurements.street.total;
            console.log('Street measurements found:', measurements.street);
        }
        
        console.log('Total feet calculated:', totalFeet);
        
        if (totalFeet <= 0) {
            console.log('No measurements found, showing placeholder');
            // Show placeholder message
            ctx.fillStyle = '#999';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Draw measurements first to see light preview', canvas.width / 2, canvas.height / 2);
            return;
        }
        
        console.log('Drawing lights for', totalFeet, 'feet');
        // Draw lights without measurement lines - make them larger for preview
        drawLightsOnCanvas(ctx, canvas.width, canvas.height, totalFeet, viewType, true);
        console.log('Lights drawn successfully');
    }
    
    // ===== NIGHT MODE FUNCTIONS =====
    
    function toggleNightMode(type) {
        nightMode[type] = !nightMode[type];
        
        if (type === 'aerial') {
            const aerialContainer = document.getElementById('aerialContainer');
            if (nightMode.aerial) {
                aerialContainer.classList.add('night-mode');
                showStatus('Aerial night mode enabled - darkened view for light visualization', 'success');
            } else {
                aerialContainer.classList.remove('night-mode');
                showStatus('Aerial day mode restored', 'success');
            }
        } else if (type === 'street') {
            const streetContainer = document.getElementById('streetContainer');
            if (nightMode.street) {
                streetContainer.classList.add('night-mode');
                showStatus('Street view night mode enabled - darkened view for light visualization', 'success');
            } else {
                streetContainer.classList.remove('night-mode');
                showStatus('Street view day mode restored', 'success');
            }
        }
        
        // Update button appearance
        const button = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}Night`);
        if (button) {
            button.classList.toggle('active', nightMode[type]);
            button.textContent = nightMode[type] ? 'â˜€ï¸ Day Mode' : 'ğŸŒ™ Night Mode';
        }
        
        // Update light visualization
        updateLightVisualization();
    }

function updateNightModeStatus() {
    const statusDiv = document.getElementById('nightModeStatus');
    const statusText = document.getElementById('nightModeStatusText');
    
    if (nightMode.aerial || nightMode.street) {
        statusDiv.style.display = 'block';
        const activeModes = [];
        if (nightMode.aerial) activeModes.push('Aerial');
        if (nightMode.street) activeModes.push('Street View');
        statusText.textContent = `ğŸŒ™ Night mode active: ${activeModes.join(', ')}`;
    } else {
        statusDiv.style.display = 'none';
    }
}

    // Measurement drawing functions for uploaded image
    function setUploadedImageDrawingMode(mode) {
        uploadedImageDrawingMode = mode;
        
        // Update button states
        document.getElementById('uploadedStraightMode').classList.toggle('active', mode === 'straight');
        document.getElementById('uploadedFreehandMode').classList.toggle('active', mode === 'freehand');
        document.getElementById('currentUploadedMode').textContent = mode === 'straight' ? 'Straight Lines' : 'Freehand';
        
        // Setup measurement canvas with new mode
        setupMeasurementCanvas();
        
        showStatus(`Switched to ${mode} mode for uploaded image`, 'success');
    }
    
    function setupMeasurementCanvas() {
        try {
            if (!measurementCanvas) return;
            
            // Clear existing event listeners by cloning
            const newCanvas = measurementCanvas.cloneNode(true);
            measurementCanvas.parentNode.replaceChild(newCanvas, measurementCanvas);
            measurementCanvas = newCanvas;
            measurementCtx = measurementCanvas.getContext('2d');
            
            // Set canvas size to match image
            if (uploadedImageData) {
                measurementCanvas.width = uploadedImageData.width;
                measurementCanvas.height = uploadedImageData.height;
                // Set CSS dimensions to match the display
                measurementCanvas.style.width = '100%';
                measurementCanvas.style.height = '100%';
            }
            
            // Enable pointer events for drawing
            measurementCanvas.style.pointerEvents = 'auto';
            
            // Add drawing event listeners based on current mode
            if (uploadedImageDrawingMode === 'straight') {
                measurementCanvas.addEventListener('click', handleUploadedImageStraightLineClick);
            } else {
                measurementCanvas.addEventListener('mousedown', startUploadedImageFreehand);
                measurementCanvas.addEventListener('mousemove', continueUploadedImageFreehand);
                measurementCanvas.addEventListener('mouseup', endUploadedImageFreehand);
                measurementCanvas.addEventListener('mouseleave', endUploadedImageFreehand);
            }
            
            // Redraw existing paths
            redrawUploadedImagePaths();
            
            console.log('Measurement canvas setup complete for mode:', uploadedImageDrawingMode);
        } catch (error) {
            console.error('Error setting up measurement canvas:', error);
        }
    }
    
    function handleUploadedImageStraightLineClick(e) {
        try {
            const rect = measurementCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (measurementCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (measurementCanvas.height / rect.height);
            
            if (!uploadedImageCurrentPath.length) {
                // Start new path
                uploadedImageCurrentPath = [{ x, y }];
                measurementCtx.beginPath();
                measurementCtx.moveTo(x, y);
                measurementCtx.strokeStyle = '#00ff00';
                measurementCtx.lineWidth = 3;
            } else {
                // Complete the path
                uploadedImageCurrentPath.push({ x, y });
                measurementCtx.lineTo(x, y);
                measurementCtx.stroke();
                
                // Calculate and display measurement
                const startPoint = uploadedImageCurrentPath[0];
                const endPoint = uploadedImageCurrentPath[uploadedImageCurrentPath.length - 1];
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const lineLength = Math.sqrt(dx * dx + dy * dy);
                
                if (streetScaleFactor && lineLength > 0) {
                    const feet = lineLength * streetScaleFactor;
                    uploadedImagePaths.push({
                        points: [...uploadedImageCurrentPath],
                        length: feet,
                        type: 'straight',
                        side: currentUploadedImageSide,
                        timestamp: Date.now()
                    });
                    
                    // Display measurement with side label
                    measurementCtx.fillStyle = '#ffffff';
                    measurementCtx.font = '16px Arial';
                    measurementCtx.fillText(`${feet.toFixed(1)} ft (${currentUploadedImageSide})`, (startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
                    
                    showStatus(`Added ${currentUploadedImageSide} side measurement: ${feet.toFixed(1)} ft`, 'success');
                    updateUploadedImageMeasurements();
                }
                
                uploadedImageCurrentPath = [];
            }
        } catch (error) {
            console.error('Error handling uploaded image straight line click:', error);
        }
    }
    
    function startUploadedImageFreehand(e) {
        try {
            isUploadedImageDrawing = true;
            const rect = measurementCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (measurementCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (measurementCanvas.height / rect.height);
            
            uploadedImageCurrentPath = [{ x, y }];
            measurementCtx.beginPath();
            measurementCtx.moveTo(x, y);
            measurementCtx.strokeStyle = '#00ff00';
            measurementCtx.lineWidth = 3;
        } catch (error) {
            console.error('Error starting uploaded image freehand:', error);
        }
    }
    
    function continueUploadedImageFreehand(e) {
        try {
            if (!isUploadedImageDrawing) return;
            
            const rect = measurementCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (measurementCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (measurementCanvas.height / rect.height);
            
            uploadedImageCurrentPath.push({ x, y });
            measurementCtx.lineTo(x, y);
            measurementCtx.stroke();
        } catch (error) {
            console.error('Error continuing uploaded image freehand:', error);
        }
    }
    
    function endUploadedImageFreehand(e) {
        try {
            if (!isUploadedImageDrawing || uploadedImageCurrentPath.length < 2) return;
            
            isUploadedImageDrawing = false;
            
            // Calculate total path length
            let totalLength = 0;
            for (let i = 1; i < uploadedImageCurrentPath.length; i++) {
                const dx = uploadedImageCurrentPath[i].x - uploadedImageCurrentPath[i-1].x;
                const dy = uploadedImageCurrentPath[i].y - uploadedImageCurrentPath[i-1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            if (streetScaleFactor && totalLength > 0) {
                const feet = totalLength * streetScaleFactor;
                uploadedImagePaths.push({
                    points: [...uploadedImageCurrentPath],
                    length: feet,
                    type: 'freehand',
                    side: currentUploadedImageSide,
                    timestamp: Date.now()
                });
                
                showStatus(`Added ${currentUploadedImageSide} side freehand measurement: ${feet.toFixed(1)} ft`, 'success');
                updateUploadedImageMeasurements();
            }
            
            uploadedImageCurrentPath = [];
        } catch (error) {
            console.error('Error ending uploaded image freehand:', error);
        }
    }
    
    function redrawUploadedImagePaths() {
        try {
            if (!measurementCtx) return;
            
            uploadedImagePaths.forEach(path => {
                measurementCtx.beginPath();
                measurementCtx.moveTo(path.points[0].x, path.points[0].y);
                
                for (let i = 1; i < path.points.length; i++) {
                    measurementCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                
                measurementCtx.strokeStyle = '#00ff00';
                measurementCtx.lineWidth = 3;
                measurementCtx.stroke();
                
                // Display measurement text with side information
                if (path.points.length >= 2) {
                    const startPoint = path.points[0];
                    const endPoint = path.points[path.points.length - 1];
                    measurementCtx.fillStyle = '#ffffff';
                    measurementCtx.font = '16px Arial';
                    const sideLabel = path.side ? ` (${path.side})` : '';
                    measurementCtx.fillText(`${path.length.toFixed(1)} ft${sideLabel}`, (startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
                }
            });
        } catch (error) {
            console.error('Error redrawing uploaded image paths:', error);
        }
    }
    
    function updateUploadedImageMeasurements() {
        try {
            // Calculate actual distance from the most recent path only
            let totalFeet = 0;
            
            if (uploadedImagePaths.length > 0) {
                const currentPath = uploadedImagePaths[uploadedImagePaths.length - 1];
                if (currentPath && currentPath.length > 1) {
                    for (let i = 1; i < currentPath.length; i++) {
                        const dx = currentPath[i].x - currentPath[i-1].x;
                        const dy = currentPath[i].y - currentPath[i-1].y;
                        const segmentLength = Math.sqrt(dx * dx + dy * dy);
                        totalFeet += segmentLength;
                    }
                    
                    // Convert pixels to feet (assuming 1 pixel = 1 foot for now, adjust scale factor as needed)
                    const scaleFactor = 0.1; // Adjust this based on your image scale
                    totalFeet = totalFeet * scaleFactor;
                }
            }
            
            // Update street measurements with uploaded image measurements
            if (!measurements.street) {
                measurements.street = { front: 0, leftSide: 0, rightSide: 0, back: 0, total: 0, eaves: 0, gables: 0 };
            }
            
            // Get the currently selected side for uploaded image
            const currentSide = getCurrentUploadedImageSide();
            
            // Replace the side measurement (don't add to existing)
            measurements.street[currentSide] = Math.round(totalFeet);
            
            // Recalculate total from all sides
            measurements.street.total = (measurements.street.front || 0) + 
                                      (measurements.street.leftSide || 0) + 
                                      (measurements.street.rightSide || 0) + 
                                      (measurements.street.back || 0);
            
            // Update displays
            updateStreetDisplay();
            updateCombinedMeasurements();
            updateLightVisualization();
            updatePricing();
            
            showStatus(`Updated ${currentSide} side: ${totalFeet.toFixed(1)} ft`, 'success');
        } catch (error) {
            console.error('Error updating uploaded image measurements:', error);
        }
    }
    
    function clearUploadedImageMeasurements() {
        try {
            uploadedImagePaths = [];
            uploadedImageCurrentPath = [];
            isUploadedImageDrawing = false;
            
            if (measurementCtx && measurementCanvas) {
                measurementCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
            }
            
            // Reset street measurements
            if (measurements.street) {
                measurements.street.front = 0;
                measurements.street.leftSide = 0;
                measurements.street.rightSide = 0;
                measurements.street.back = 0;
                measurements.street.total = 0;
                measurements.street.eaves = 0;
                measurements.street.gables = 0;
            }
            
            updateStreetDisplay();
            updateCombinedMeasurements();
            updateLightVisualization();
            updatePricing();
            
            showStatus('Uploaded image measurements cleared', 'success');
        } catch (error) {
            console.error('Error clearing uploaded image measurements:', error);
        }
    }
    
    // Side selection functions
    function selectHouseSide(side) {
        currentAerialSide = side;
        
        // Update button states
        document.querySelectorAll('.side-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`side${side.charAt(0).toUpperCase() + side.slice(1)}`).classList.add('active');
        
        // Update label
        document.getElementById('currentSideLabel').textContent = side.charAt(0).toUpperCase() + side.slice(1);
        
        showStatus(`Selected ${side} side for aerial measurements`, 'success');
    }
    
    function selectUploadedImageSide(side) {
        currentUploadedImageSide = side;
        
        // Update button states
        document.querySelectorAll('#measurementControls .side-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`uploadedSide${side.charAt(0).toUpperCase() + side.slice(1)}`).classList.add('active');
        

        // Update label
        document.getElementById('currentUploadedSideLabel').textContent = side.charAt(0).toUpperCase() + side.slice(1);
        
        showStatus(`Selected ${side} side for uploaded image measurements`, 'success');
    }
    
    // ===== STREET VIEW DRAWING MODE FUNCTIONS =====
    
    function setStreetDrawingMode(mode) {
        try {
            // Update button states
            document.getElementById('streetStraightLineBtn').classList.remove('active');
            document.getElementById('streetFreehandBtn').classList.remove('active');
            
            if (mode === 'straight') {
                document.getElementById('streetStraightLineBtn').classList.add('active');
                currentStreetDrawingMode = 'straight';
                showStatus('Street View: Straight line mode activated. Click to place line endpoints.', 'info');
            } else if (mode === 'freehand') {
                document.getElementById('streetFreehandBtn').classList.add('active');
                currentStreetDrawingMode = 'freehand';
                showStatus('Street View: Freehand mode activated. Click and drag to draw.', 'info');
            }
            
            // Set up canvas event listeners based on mode
            setupStreetViewCanvasEvents(mode);
            
        } catch (error) {
            console.error('Error setting street drawing mode:', error);
            showStatus('Error setting drawing mode', 'error');
        }
    }
    
    function setupStreetViewCanvasEvents(mode) {
        try {
            const canvas = document.getElementById('capturedStreetCanvas');
            if (!canvas) {
                console.log('Captured Street View canvas not found');
                return;
            }
            
            // Remove existing event listeners
            canvas.removeEventListener('mousedown', handleStreetViewMouseDown);
            canvas.removeEventListener('mousemove', handleStreetViewMouseMove);
            canvas.removeEventListener('mouseup', handleStreetViewMouseUp);
            
            if (mode === 'straight') {
                canvas.addEventListener('mousedown', handleStreetViewMouseDown);
                canvas.addEventListener('click', handleStreetViewStraightLineClick);
            } else if (mode === 'freehand') {
                canvas.addEventListener('mousedown', handleStreetViewMouseDown);
                canvas.addEventListener('mousemove', handleStreetViewMouseMove);
                canvas.addEventListener('mouseup', handleStreetViewMouseUp);
            }
            
            console.log(`Street View canvas events set up for ${mode} mode`);
            
        } catch (error) {
            console.error('Error setting up street view canvas events:', error);
        }
    }
    
    // ===== STREET VIEW DRAWING FUNCTIONS =====
    // These functions draw measurement lines that lights will be placed along
    
    function handleStreetViewMouseDown(e) {
        try {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            
            // Get the actual canvas dimensions
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Calculate the scale factors
            const scaleX = canvasWidth / rect.width;
            const scaleY = canvasHeight / rect.height;
            
            // Calculate the offset-adjusted coordinates
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            console.log('Street view mouse down coordinates:', { x, y });
            
            if (currentStreetDrawingMode === 'freehand') {
                startStreetViewFreehand(e, canvas, canvas.getContext('2d'), 'capturedStreet');
            }
        } catch (error) {
            console.error('Error in street view mouse down:', error);
        }
    }
    
    function handleStreetViewMouseMove(e) {
        try {
            if (currentStreetDrawingMode === 'freehand') {
                drawStreetViewFreehand(e, e.target, e.target.getContext('2d'), 'capturedStreet');
            }
        } catch (error) {
            console.error('Error in street view mouse move:', error);
        }
    }
    
    function handleStreetViewMouseUp(e) {
        try {
            if (currentStreetDrawingMode === 'freehand') {
                endStreetViewFreehand(e, e.target, e.target.getContext('2d'), 'capturedStreet');
            }
        } catch (error) {
            console.error('Error in street view mouse up:', error);
        }
    }
    
    // Street View straight line click handler
    function handleStreetViewStraightLineClick(e) {
        try {
            const canvas = e.target;
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            
            // Calculate the scale factors for proper coordinate mapping
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Calculate the offset-adjusted coordinates
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            console.log('Street view straight line click coordinates:', { x, y });
            
            if (!canvas.streetViewDrawingData) {
                canvas.streetViewDrawingData = {
                    currentPath: [],
                    paths: [],
                    isDrawing: false
                };
            }
            
            if (!canvas.streetViewDrawingData.currentPath) {
                canvas.streetViewDrawingData.currentPath = [];
            }
            
            canvas.streetViewDrawingData.currentPath.push({ x, y });
            
            // Draw a small point to show where we clicked
            const pointSize = 3;
            ctx.fillStyle = '#0066cc';
            ctx.beginPath();
            ctx.arc(x, y, pointSize, 0, Math.PI * 2);
            ctx.fill();
            
            // If this is exactly 2 points, complete the path and place lights
            if (canvas.streetViewDrawingData.currentPath.length === 2) {
                // Complete the path
                const currentPath = [...canvas.streetViewDrawingData.currentPath];
                canvas.streetViewDrawingData.paths.push(currentPath);
                capturedStreetPaths.push(currentPath);
                
                console.log('Straight line path completed:', currentPath);
                
                // Check if this is a reference line (first line drawn)
                if (capturedStreetPaths.length === 1) {
                    // This is the reference line - calculate scale
                    const scaleInput = document.getElementById('streetScaleInput');
                    if (scaleInput) {
                        const referenceWidth = parseFloat(scaleInput.value);
                        if (!isNaN(referenceWidth) && referenceWidth > 0) {
                            calculateScaleFromReferenceLine(referenceWidth);
                        }
                    }
                } else {
                    // This is a measurement line - calculate measurements
                    calculateStreetViewMeasurements();
                }
                
                // Update light visualization
                updateLightVisualization();
                
                canvas.streetViewDrawingData.currentPath = [];
                showStatus('Street View straight line completed!', 'success');
            }
            
        } catch (error) {
            console.error('Error in street view straight line click:', error);
        }
    }
    
    // Street View freehand drawing functions
    function startStreetViewFreehand(e, canvas, ctx, type) {
        const rect = canvas.getBoundingClientRect();
        
        // Adjust for canvas scaling and positioning
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        
        if (!canvas.streetViewDrawingData) {
            canvas.streetViewDrawingData = {
                currentPath: [],
                paths: [],
                isDrawing: false
            };
        }
        
        canvas.streetViewDrawingData.isDrawing = true;
        canvas.streetViewDrawingData.currentPath = [{ x, y }];
        
        ctx.beginPath();
        ctx.moveTo(x, y);
    }
    
    function drawStreetViewFreehand(e, canvas, ctx, type) {
        try {
            if (!canvas.streetViewDrawingData || !canvas.streetViewDrawingData.isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            
            // Calculate the scale factors (same as startStreetViewFreehand)
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Calculate the offset-adjusted coordinates (same as startStreetViewFreehand)
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Place light at this point during freehand drawing
            const lightSize = 4;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(x, y, lightSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glow effect
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 6;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(x, y, lightSize + 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            canvas.streetViewDrawingData.currentPath.push({ x, y });
            
        } catch (error) {
            console.error('Error drawing street view freehand:', error);
        }
    }
    
    function endStreetViewFreehand(e, canvas, ctx, type) {
        try {
            if (!canvas.streetViewDrawingData || !canvas.streetViewDrawingData.isDrawing) return;
            
            canvas.streetViewDrawingData.isDrawing = false;
            isStreetViewDrawing = false;
            
            if (canvas.streetViewDrawingData.currentPath.length > 1) {
                // Only add the current path, don't connect to previous paths
                const currentPath = [...canvas.streetViewDrawingData.currentPath];
                canvas.streetViewDrawingData.paths.push(currentPath);
                capturedStreetPaths.push(currentPath);
                
                console.log('Freehand path completed:', currentPath);
                
                // Check if this is a reference line (first line drawn)
                if (capturedStreetPaths.length === 1) {
                    // This is the reference line - calculate scale
                    const scaleInput = document.getElementById('streetScaleInput');
                    if (scaleInput) {
                        const referenceWidth = parseFloat(scaleInput.value);
                        if (!isNaN(referenceWidth) && referenceWidth > 0) {
                            calculateScaleFromReferenceLine(referenceWidth);
                        }
                    }
                } else {
                    // This is a measurement line - calculate measurements
                    calculateStreetViewMeasurements();
                }
                
                // Update light visualization
                updateLightVisualization();
                
                showStatus('Street View freehand drawing completed!', 'success');
            }
            
            canvas.streetViewDrawingData.currentPath = [];
            
        } catch (error) {
            console.error('Error ending street view freehand:', error);
        }
    }
    
    // NEW CLEAN Street View measurement system
    function calculateStreetViewMeasurements() {
        try {
            console.log('ğŸ”„ Calculating Street View measurements...');
            
            // Ensure measurements object is properly initialized
            if (!measurements.street) {
                measurements.street = { 
                    front: 0, 
                    leftSide: 0, 
                    rightSide: 0, 
                    back: 0, 
                    total: 0, 
                    eaves: 0, 
                    gables: 0 
                };
            }
            
            // Get the currently selected side
            const currentSide = getCurrentStreetSide();
            console.log('Current side:', currentSide);
            
            // Calculate from the most recent path only
            if (capturedStreetPaths.length > 0) {
                const currentPath = capturedStreetPaths[capturedStreetPaths.length - 1];
                if (currentPath && currentPath.length >= 2) {
                    let totalFeet = 0;
                    
                    for (let i = 1; i < currentPath.length; i++) {
                        const dx = currentPath[i].x - currentPath[i-1].x;
                        const dy = currentPath[i].y - currentPath[i-1].y;
                        const pixelLength = Math.sqrt(dx * dx + dy * dy);
                        const segmentFeet = pixelLength * streetScaleFactor;
                        totalFeet += segmentFeet;
                        
                        console.log(`Segment ${i-1} to ${i}: pixels=${pixelLength.toFixed(2)}, scale=${streetScaleFactor.toFixed(4)}, feet=${segmentFeet.toFixed(2)}, running total=${totalFeet.toFixed(2)}`);
                    }
                    
                    // Replace the side measurement (don't add to existing)
                    measurements.street[currentSide] = Math.round(totalFeet);
                    
                    // Recalculate total from all sides
                    measurements.street.total = (measurements.street.front || 0) + 
                                              (measurements.street.leftSide || 0) + 
                                              (measurements.street.rightSide || 0) + 
                                              (measurements.street.back || 0);
                    
                    console.log('Updated street measurements:', measurements.street);
                    
                    // Update all displays
                    updateStreetDisplay();
                    updateCombinedMeasurements();
                    updateLightVisualization();
                    updatePricing();
                    
                    showStatus(`Street View ${currentSide} side updated: ${totalFeet.toFixed(1)} ft`, 'success');
                } else {
                    console.log('Invalid path for measurement');
                }
            } else {
                console.log('No paths available for measurement');
            }
            
        } catch (error) {
            console.error('Error calculating street view measurements:', error);
        }
    }
    
    function clearStreetDrawing() {
        try {
            // Clear captured street view canvas
            const canvas = document.getElementById('capturedStreetCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Clear drawing data
            if (canvas && canvas.streetViewDrawingData) {
                canvas.streetViewDrawingData.paths = [];
                canvas.streetViewDrawingData.currentPath = [];
                canvas.streetViewDrawingData.isDrawing = false;
            }
            
            // Clear global paths
            capturedStreetPaths = [];
            
            // Reset measurements
            if (measurements.street) {
                measurements.street.front = 0;
                measurements.street.leftSide = 0;
                measurements.street.rightSide = 0;
                measurements.street.back = 0;
                measurements.street.total = 0;
                measurements.street.eaves = 0;
                measurements.street.gables = 0;
            }
            
            // Update displays
            updateStreetDisplay();
            updateCombinedMeasurements();
            updateLightVisualization();
            updatePricing();
            
            showStatus('Street View drawing cleared', 'success');
        } catch (error) {
            console.error('Error clearing street drawing:', error);
        }
    }

    function clearStreetDebug() {
        try {
            const canvas = document.getElementById('capturedStreetCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                // Redraw the background image to clear debug elements
                const img = document.getElementById('capturedStreetViewImage');
                if (img && img.complete) {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
                console.log('Street View debug elements cleared');
            }
        } catch (error) {
            console.error('Error clearing street debug:', error);
        }
    }

    // Draw lights on street view
    function drawLightsOnStreetView(ctx, width, height, totalFeet, isPreview = false) {
        try {
            if (!totalFeet || totalFeet <= 0) return;
            
            // Calculate light spacing (1 foot between lights)
            const lightSpacing = 1;
            const totalLights = Math.ceil(totalFeet / lightSpacing);
            
            // Set light style
            ctx.fillStyle = isPreview ? 'rgba(255, 255, 0, 0.7)' : 'rgba(255, 255, 0, 0.9)';
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            ctx.shadowBlur = isPreview ? 5 : 10;
            
            // Draw lights along the street view measurements
            for (let i = 0; i < totalLights; i++) {
                const x = (i / totalLights) * width;
                const y = height / 2 + Math.sin(i * 0.1) * (height * 0.2);
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            
        } catch (error) {
            console.error('Error drawing lights on street view:', error);
        }
    }

    // Draw lights on aerial view
    function drawLightsOnAerialView(ctx, width, height, totalFeet, isPreview = false) {
        try {
            if (!totalFeet || totalFeet <= 0) return;
            
            // Calculate light spacing (1 foot between lights)
            const lightSpacing = 1;
            const totalLights = Math.ceil(totalFeet / lightSpacing);
            
            // Set light style
            ctx.fillStyle = isPreview ? 'rgba(255, 255, 0, 0.7)' : 'rgba(255, 255, 0, 0.9)';
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            ctx.shadowBlur = isPreview ? 5 : 10;
            
            // Draw lights along the perimeter in a circular pattern
            for (let i = 0; i < totalLights; i++) {
                const angle = (i / totalLights) * 2 * Math.PI;
                const x = width / 2 + Math.cos(angle) * (width * 0.3);
                const y = height / 2 + Math.sin(angle) * (height * 0.3);
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            
        } catch (error) {
            console.error('Error drawing lights on aerial view:', error);
        }
    }

    // Draw lights on live street view
    function drawLightsOnLiveStreetView(ctx, width, height, totalFeet, isPreview = false) {
        try {
            if (!totalFeet || totalFeet <= 0) return;
            
            // Calculate light spacing (1 foot between lights)
            const lightSpacing = 1;
            const totalLights = Math.ceil(totalFeet / lightSpacing);
            
            // Set light style
            ctx.fillStyle = isPreview ? 'rgba(255, 255, 0, 0.7)' : 'rgba(255, 255, 0, 0.9)';
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            ctx.shadowBlur = isPreview ? 5 : 10;
            
            // Draw lights along the street view measurements
            for (let i = 0; i < totalLights; i++) {
                const x = (i / totalLights) * width;
                const y = height / 2 + Math.sin(i * 0.1) * (height * 0.2);
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            
        } catch (error) {
            console.error('Error drawing lights on live street view:', error);
        }
    }

    // Draw lights on captured street view
    function drawLightsOnCapturedStreetView(ctx, width, height, totalFeet, isPreview = false) {
        try {
            if (!totalFeet || totalFeet <= 0) return;
            
            // Calculate light spacing (1 foot between lights)
            const lightSpacing = 1;
            const totalLights = Math.ceil(totalFeet / lightSpacing);
            
            // Set light style
            ctx.fillStyle = isPreview ? 'rgba(255, 255, 0, 0.7)' : 'rgba(255, 255, 0, 0.9)';
            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
            ctx.shadowBlur = isPreview ? 5 : 10;
            
            // Draw lights along the captured street view measurements
            for (let i = 0; i < totalLights; i++) {
                const x = (i / totalLights) * width;
                const y = height / 2 + Math.sin(i * 0.1) * (height * 0.2);
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            
        } catch (error) {
            console.error('Error drawing lights on captured street view:', error);
        }
    }

    // Redraw all paths on the current canvas
    function redrawAllPathsOnCurrentCanvas() {
        try {
            console.log('ğŸ”„ redrawAllPathsOnCurrentCanvas() called');
            
            // Redraw aerial paths
            if (aerialCanvas && aerialCanvas.drawingData && aerialCanvas.drawingData.paths.length > 0) {
                console.log('ğŸ”„ Redrawing all paths for aerial :', aerialCanvas.drawingData.paths.length, 'paths');
                const ctx = aerialCanvas.getContext('2d');
                ctx.clearRect(0, 0, aerialCanvas.width, aerialCanvas.height);
                
                aerialCanvas.drawingData.paths.forEach(path => {
                    if (path.points && path.points.length >= 2) {
                        // Place lights along the path instead of drawing lines
                        const points = path.points;
                        for (let i = 0; i < points.length; i++) {
                            const point = points[i];
                            const lightSize = 6;
                            
                            // Draw enhanced light with white core and yellow halo
                            drawEnhancedLight(ctx, point.x, point.y, lightSize, '#FFD700');
                        }
                    }
                });
            }
            
            // Redraw street paths
            if (streetCanvas && streetCanvas.drawingData && streetCanvas.drawingData.paths.length > 0) {
                console.log('ğŸ”„ Redrawing all paths for street :', streetCanvas.drawingData.paths.length, 'paths');
                const ctx = streetCanvas.getContext('2d');
                ctx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
                
                streetCanvas.drawingData.paths.forEach(path => {
                    if (path.length >= 2) {
                        // Place lights along the path instead of drawing lines
                        for (let i = 0; i < path.length; i++) {
                            const point = path[i];
                            const lightSize = 6;
                            
                            // Draw enhanced light with white core and yellow halo
                            drawEnhancedLight(ctx, point.x, point.y, lightSize, '#FFD700');
                        }
                    }
                });
            }
            
            console.log('âœ… All paths redrawn successfully');
            
        } catch (error) {
            console.error('Error redrawing all paths:', error);
        }
    }

    // Redraw all paths on captured street view
    function redrawAllPathsOnCapturedStreetView() {
        try {
            console.log('ğŸ”„ redrawAllPathsOnCapturedStreetView() called');
            
            const canvas = document.getElementById('capturedStreetCanvas');
            if (!canvas) {
                console.log('Captured street canvas not found');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (capturedStreetPaths.length > 0) {
                console.log('ğŸ”„ Redrawing all paths for captured street :', capturedStreetPaths.length, 'paths');
                
                capturedStreetPaths.forEach(path => {
                    if (path.length >= 2) {
                        // Place lights along the path instead of drawing lines
                        for (let i = 0; i < path.length; i++) {
                            const point = path[i];
                            const lightSize = 6;
                            
                            // Draw enhanced light with white core and yellow halo
                            drawEnhancedLight(ctx, point.x, point.y, lightSize, '#FFD700');
                        }
                    }
                });
                
                showStatus('All paths redrawn on captured Street View', 'success');
            } else {
                console.log('No captured street paths to redraw');
            }
            
        } catch (error) {
            console.error('Error redrawing captured street paths:', error);
        }
    }

// Street View scale calibration function
function applyStreetScale() {
    try {
        const scaleInput = document.getElementById('streetScaleInput');
        const scaleStatus = document.getElementById('streetScaleStatus');
        
        if (!scaleInput) {
            showStatus('Scale input not found', 'error');
            return;
        }
        
        const referenceWidth = parseFloat(scaleInput.value);
        if (isNaN(referenceWidth) || referenceWidth <= 0) {
            showStatus('Please enter a valid reference width', 'error');
            return;
        }
        
        // COMPLETELY RESET everything when applying scale
        console.log('ğŸ”„ Applying Street View scale - COMPLETE RESET');
        
        // Clear ALL old data
        capturedStreetPaths = [];
        
        // Reset measurements completely
        if (measurements.street) {
            measurements.street.front = 0;
            measurements.street.leftSide = 0;
            measurements.street.rightSide = 0;
            measurements.street.back = 0;
            measurements.street.total = 0;
            measurements.street.eaves = 0;
            measurements.street.gables = 0;
        }
        
        // Clear any simple arrays if they exist
        if (window.svSegs) {
            window.svSegs = [];
            window.svTypes = [];
            window.svSides = [];
        }
        
        // Clear the canvas completely
        const canvas = document.getElementById('capturedStreetCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            console.log('âœ… Canvas cleared');
        }
        
        // Reset drawing data
        if (canvas && canvas.streetViewDrawingData) {
            canvas.streetViewDrawingData.paths = [];
            canvas.streetViewDrawingData.currentPath = [];
            canvas.streetViewDrawingData.isDrawing = false;
            console.log('âœ… Drawing data reset');
        }
        
        // Set a basic scale factor (will be updated when user draws reference line)
        streetScaleFactor = 0.1; // Default small value
        
        // Update all displays
        updateStreetDisplay();
        updateCombinedMeasurements();
        updateLightVisualization();
        updatePricing();
        
        // Force capture toggle backgrounds
        setTimeout(() => {
            captureToggleBackgrounds();
        }, 500);
        
        showStatus(`Street View scale reset. Now draw a reference line across the ${referenceWidth}' feature.`, 'info');
        
    } catch (error) {
        console.error('Error applying street scale:', error);
        showStatus('Error applying scale: ' + error.message, 'error');
    }
}

// Force capture backgrounds for toggle system
function captureToggleBackgrounds() {
    try {
        console.log('ğŸ–¼ï¸ Capturing toggle backgrounds...');
        
        // Capture aerial background for toggle
        const mapDiv = document.getElementById('map');
        if (mapDiv && mapDiv.offsetWidth > 0 && mapDiv.offsetHeight > 0) {
            console.log('Capturing aerial view...');
            html2canvas(mapDiv, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: null,
                width: mapDiv.offsetWidth,
                height: mapDiv.offsetHeight
            }).then(canvas => {
                aerialTransitionBackgroundImage = canvas.toDataURL('image/png');
                console.log('âœ… Aerial toggle background captured:', canvas.width, 'x', canvas.height);
                
                // Force update the toggle display
                if (aerialTransitionBackgroundImage) {
                    updateAerialToggleDisplay();
                }
            }).catch(error => {
                console.error('Error capturing aerial toggle background:', error);
            });
        }
        
        // Capture street background for toggle
        if (isStreetViewCaptured && capturedStreetViewData && capturedStreetViewData.imageData) {
            // Use the exact captured street view image
            streetTransitionBackgroundImage = capturedStreetViewData.imageData;
            console.log('âœ… Street toggle background copied from captured view');
            
            // Force update the toggle display
            if (streetTransitionBackgroundImage) {
                updateStreetToggleDisplay();
            }
        } else {
            // Try to capture live street view
            const streetViewDiv = document.getElementById('streetView');
            if (streetViewDiv && streetViewDiv.offsetWidth > 0 && streetViewDiv.offsetHeight > 0) {
                console.log('Capturing live street view...');
                html2canvas(streetViewDiv, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    width: streetViewDiv.offsetWidth,
                    height: streetViewDiv.offsetHeight
                }).then(canvas => {
                    streetTransitionBackgroundImage = canvas.toDataURL('image/png');
                    console.log('âœ… Street toggle background captured from live view:', canvas.width, 'x', canvas.height);
                    
                    // Force update the toggle display
                    if (streetTransitionBackgroundImage) {
                        updateStreetToggleDisplay();
                    }
                }).catch(error => {
                    console.error('Error capturing street toggle background:', error);
                });
            }
        }
        
        console.log('Toggle backgrounds captured:', {
            aerial: !!aerialTransitionBackgroundImage,
            street: !!streetTransitionBackgroundImage
        });
        
    } catch (error) {
        console.error('Error capturing toggle backgrounds:', error);
    }
}

// Force update aerial toggle display
function updateAerialToggleDisplay() {
    try {
        const canvas = document.getElementById('aerialLightToggleCanvas');
        if (canvas && aerialTransitionBackgroundImage) {
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                // Ensure canvas dimensions match the image to prevent skewing
                if (canvas.width !== img.width || canvas.height !== img.height) {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    console.log('Canvas resized to match image:', img.width, 'x', img.height);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                console.log('âœ… Aerial toggle display updated with background');
            };
            img.src = aerialTransitionBackgroundImage;
        }
    } catch (error) {
        console.error('Error updating aerial toggle display:', error);
    }
}

// Force update street toggle display
function updateStreetToggleDisplay() {
    try {
        const canvas = document.getElementById('streetLightToggleCanvas');
        if (canvas && streetTransitionBackgroundImage) {
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                // Ensure canvas dimensions match the image to prevent skewing
                if (canvas.width !== img.width || canvas.height !== img.height) {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    console.log('Canvas resized to match image:', img.width, 'x', img.height);
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                console.log('âœ… Street toggle display updated with background');
            };
            img.src = streetTransitionBackgroundImage;
        }
    } catch (error) {
        console.error('Error updating street toggle display:', error);
    }
}

// Function to calculate scale from a drawn reference line
function calculateScaleFromReferenceLine(referenceWidth) {
    try {
        if (capturedStreetPaths.length === 0) {
            console.log('No reference line drawn yet');
            return;
        }
        
        // Get the most recent path as the reference line
        const referencePath = capturedStreetPaths[capturedStreetPaths.length - 1];
        if (!referencePath || referencePath.length < 2) {
            console.log('Invalid reference path');
            return;
        }
        
        const startPoint = referencePath[0];
        const endPoint = referencePath[referencePath.length - 1];
        const pixelLength = Math.sqrt(
            Math.pow(endPoint.x - startPoint.x, 2) + 
            Math.pow(endPoint.y - startPoint.y, 2)
        );
        
        if (pixelLength <= 0) {
            console.log('Invalid pixel length');
            return;
        }
        
        // Calculate the actual scale factor
        streetScaleFactor = referenceWidth / pixelLength;
        
        console.log('Scale calculation:', {
            referenceWidth,
            pixelLength,
            calculatedScale: streetScaleFactor,
            startPoint,
            endPoint
        });
        
        // Remove the reference line from paths (don't count it in measurements)
        capturedStreetPaths.pop();
        
        // Update the scale display
        const scaleStatus = document.getElementById('streetScaleStatus');
        if (scaleStatus) {
            scaleStatus.style.display = 'block';
            scaleStatus.textContent = `Scale: ${streetScaleFactor.toFixed(4)} ft/pixel`;
        }
        
        showStatus(`Scale calculated: ${referenceWidth}' = ${pixelLength} pixels (${streetScaleFactor.toFixed(4)} ft/pixel)`, 'success');
        
        // Redraw the canvas without the reference line
        const canvas = document.getElementById('capturedStreetCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Redraw the background image if it exists
                const img = document.getElementById('capturedStreetViewImage');
                if (img && img.complete) {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                }
                
                // Redraw all remaining paths (excluding the reference line)
                if (capturedStreetPaths.length > 0) {
                    capturedStreetPaths.forEach(path => {
                        if (path && path.length >= 2) {
                            ctx.strokeStyle = '#0066cc';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(path[0].x, path[0].y);
                            for (let i = 1; i < path.length; i++) {
                                ctx.lineTo(path[i].x, path[i].y);
                            }
                            ctx.stroke();
                        }
                    });
                }
            }
        }
        
        // Update light calculations
        updateLightVisualization();
        
    } catch (error) {
        console.error('Error calculating scale from reference line:', error);
    }
}

// Reset Street View back to live view
function resetStreetView() {
    try {
        // Hide captured view
        const capturedContainer = document.getElementById('capturedStreetViewContainer');
        if (capturedContainer) {
            capturedContainer.style.display = 'none';
        }
        
        // Show live view
        const streetViewDiv = document.getElementById('streetView');
        const streetCanvas = document.getElementById('streetCanvas');
        if (streetViewDiv) {
            streetViewDiv.style.display = 'block';
        }
        if (streetCanvas) {
            streetCanvas.style.display = 'block';
        }
        
        // Show/hide buttons
        const captureBtn = document.getElementById('captureStreetViewBtn');
        const resetBtn = document.getElementById('resetStreetViewBtn');
        if (captureBtn) captureBtn.style.display = 'inline-block';
        if (resetBtn) resetBtn.style.display = 'none';
        
        // Clear captured data
        capturedStreetViewData = null;
        isStreetViewCaptured = false;
        
        // Clear any drawn paths on captured view
        clearStreetDrawing();
        
        showStatus('Returned to live Street View', 'success');
        
    } catch (error) {
        console.error('Error resetting Street View:', error);
        showStatus('Error resetting Street View', 'error');
    }
}

// ===== SEPARATE AERIAL AND STREET VIEW SLIDER FUNCTIONS =====

// Aerial View Slider Functions
function playAerialLightTransition() {
    try {
        if (!aerialTransitionAnimationId) {
            aerialTransitionAnimationId = setInterval(() => {
                const slider = document.getElementById('aerialLightTransitionSlider');
                let value = parseInt(slider.value);
                value = (value + 2) % 101;
                slider.value = value;
                updateAerialLightTransition(value);
            }, 50);
            
            document.getElementById('playAerialTransitionBtn').style.display = 'none';
            document.getElementById('pauseAerialTransitionBtn').style.display = 'inline-block';
        }
    } catch (error) {
        console.error('Error playing aerial transition:', error);
    }
}

function pauseAerialLightTransition() {
    try {
        if (aerialTransitionAnimationId) {
            clearInterval(aerialTransitionAnimationId);
            aerialTransitionAnimationId = null;
            
            document.getElementById('playAerialTransitionBtn').style.display = 'inline-block';
            document.getElementById('pauseAerialTransitionBtn').style.display = 'none';
        }
    } catch (error) {
        console.error('Error pausing aerial transition:', error);
    }
}

function resetAerialLightTransition() {
    try {
        pauseAerialLightTransition();
        const slider = document.getElementById('aerialLightTransitionSlider');
        slider.value = 0;
        updateAerialLightTransition(0);
        showStatus('Aerial transition reset to day view', 'success');
    } catch (error) {
        console.error('Error resetting aerial transition:', error);
    }
}

function updateAerialLightTransition(value) {
    try {
        const canvas = document.getElementById('aerialLightTransitionCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Draw background image if available
        if (aerialTransitionBackgroundImage) {
            try {
                // Create image from data URL
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // DISABLED: Old light drawing system - now using new light placement system
                    // Draw lights based on aerial measurements
                    // if (measurements.aerial && measurements.aerial.perimeter > 0) {
                    //     drawAerialLights(ctx, width, height, lightIntensity);
                    // }
                };
                img.src = aerialTransitionBackgroundImage;
            } catch (error) {
                console.error('Error drawing aerial background:', error);
                aerialTransitionBackgroundImage = null;
            }
        } else {
            // Draw a placeholder if no background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('No aerial background captured', width/2, height/2);
        }
        
        // Calculate light intensity based on slider value
        const lightIntensity = value / 100;
        
        // DISABLED: Old light drawing system - now using new light placement system
        // Draw lights based on aerial measurements
        // if (measurements.aerial && measurements.aerial.perimeter > 0) {
        //     drawAerialLights(ctx, width, height, lightIntensity);
        // }
        
        // Update status
        console.log('ğŸ¨ Aerial light transition updated:', { value, lightIntensity });
        
    } catch (error) {
        console.error('Error updating aerial light transition:', error);
    }
}

function captureAerialTransitionBackground() {
    try {
        console.log('ğŸ–¼ï¸ Capturing aerial transition background...');
        
        if (!map || typeof map.getVisible !== 'function') {
            showStatus('Map not initialized. Please wait for the map to load.', 'warning');
            return;
        }
        
        if (!map.getVisible()) {
            showStatus('Map not visible. Please make sure the aerial view is loaded.', 'warning');
            return;
        }
        
        // Use html2canvas to capture the map
        const mapDiv = document.getElementById('map');
        if (mapDiv) {
            html2canvas(mapDiv, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: null
            }).then(canvas => {
                aerialTransitionBackgroundImage = canvas.toDataURL('image/png');
                console.log('âœ… Aerial transition background captured successfully');
                showStatus('Aerial background captured! Now you can see your house in the slider.', 'success');
                
                // Update the toggle to show the new background
                console.log('âœ… Aerial background captured! Now you can see your house in the toggle.');
            }).catch(error => {
                console.error('Error capturing aerial view:', error);
                showStatus('Error capturing aerial view: ' + error.message, 'error');
            });
        }
        
    } catch (error) {
        console.error('Error capturing aerial transition background:', error);
        showStatus('Error capturing aerial background: ' + error.message, 'error');
    }
}

function updateAerialTransitionBackground() {
    try {
        console.log('ğŸ”„ Updating aerial transition background for new measurements');
        captureAerialTransitionBackground();
    } catch (error) {
        console.error('Error updating aerial transition background:', error);
    }
}

// Street View Slider Functions
function playStreetLightTransition() {
    try {
        if (!streetTransitionAnimationId) {
            streetTransitionAnimationId = setInterval(() => {
                const slider = document.getElementById('streetLightTransitionSlider');
                let value = parseInt(slider.value);
                value = (value + 2) % 101;
                slider.value = value;
                updateStreetLightTransition(value);
            }, 50);
            
            document.getElementById('playStreetTransitionBtn').style.display = 'none';
            document.getElementById('pauseStreetTransitionBtn').style.display = 'inline-block';
        }
    } catch (error) {
        console.error('Error playing street transition:', error);
    }
}

function pauseStreetLightTransition() {
    try {
        if (streetTransitionAnimationId) {
            clearInterval(streetTransitionAnimationId);
            streetTransitionAnimationId = null;
            
            document.getElementById('playStreetTransitionBtn').style.display = 'inline-block';
            document.getElementById('pauseStreetTransitionBtn').style.display = 'none';
        }
    } catch (error) {
        console.error('Error pausing street transition:', error);
    }
}

function resetStreetLightTransition() {
    try {
        pauseStreetLightTransition();
        const slider = document.getElementById('streetLightTransitionSlider');
        slider.value = 0;
        updateStreetLightTransition(0);
        showStatus('Street transition reset to day view', 'success');
    } catch (error) {
        console.error('Error resetting street transition:', error);
    }
}

function updateStreetLightTransition(value) {
    try {
        const canvas = document.getElementById('streetLightTransitionCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Draw background image if available
        if (streetTransitionBackgroundImage) {
            try {
                // Create image from data URL
                const img = new Image();
                img.src = streetTransitionBackgroundImage;
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Draw lights based on street measurements
                    if (measurements.street && measurements.street.total > 0) {
                        drawStreetLights(ctx, width, height, lightIntensity);
                    }
                };
            } catch (error) {
                console.error('Error drawing street background:', error);
                streetTransitionBackgroundImage = null;
            }
        } else {
            // Draw a placeholder if no background
            ctx.fillStyle = '#98FB98';
            ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('No street background captured', width/2, height/2);
        }
        
        // Calculate light intensity based on slider value
        const lightIntensity = value / 100;
        
        // Draw lights based on street measurements
        if (measurements.street && measurements.street.total > 0) {
            drawStreetLights(ctx, width, height, lightIntensity);
        }
        
        // Update status
        console.log('ğŸ¨ Street light transition updated:', { value, lightIntensity });
        
    } catch (error) {
        console.error('Error updating street light transition:', error);
    }
}

function captureStreetTransitionBackground() {
    try {
        console.log('ğŸ–¼ï¸ Capturing street transition background...');
        
        if (isStreetViewCaptured && capturedStreetViewData) {
            console.log('Using captured street view as background');
            streetTransitionBackgroundImage = capturedStreetViewData.imageData;
            console.log('âœ… Street transition background captured successfully');
            showStatus('Street background captured! Now you can see your house in the slider.', 'success');
            
            // Update the slider to show the new background
            updateStreetLightTransition(0);
        } else {
            showStatus('No captured Street View available. Please capture Street View first.', 'warning');
        }
        
    } catch (error) {
        console.error('Error capturing street transition background:', error);
        showStatus('Error capturing street background: ' + error.message, 'error');
    }
}

function updateStreetTransitionBackground() {
    try {
        console.log('ğŸ”„ Updating street transition background for new measurements');
        captureStreetTransitionBackground();
    } catch (error) {
        console.error('Error updating street transition background:', error);
    }
}

// ===== NEW LIGHT-BASED MEASUREMENT SYSTEM =====

// Global variables for light placement system
let aerialLights = [];
let streetLights = [];
let isAerialLightPlacementActive = false;
let isStreetLightPlacementActive = false;

// Toggle light placement mode for aerial view
function toggleAerialLightPlacement() {
    try {
        window.isAerialLightPlacementActive = !window.isAerialLightPlacementActive;
        const btn = document.getElementById('aerialPlaceLightsBtn');
        
        if (window.isAerialLightPlacementActive) {
            btn.innerHTML = 'â¸ï¸ Stop Placement';
            btn.style.background = '#F44336';
            btn.style.color = 'white';
            
            // Add click listener to aerial canvas
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas) {
                aerialCanvas.style.cursor = 'crosshair';
                aerialCanvas.addEventListener('click', handleAerialLightPlacement);
            }
            
            console.log('Aerial light placement mode activated');
        } else {
            btn.innerHTML = 'ğŸ“ Place Lights';
            btn.style.background = '#FFC107';
            btn.style.color = 'white';
            
            // Remove click listener
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas) {
                aerialCanvas.style.cursor = 'default';
                aerialCanvas.removeEventListener('click', handleAerialLightPlacement);
            }
            
            console.log('Aerial light placement mode deactivated');
        }
    } catch (error) {
        console.error('Error toggling aerial light placement:', error);
    }
}

// Toggle light placement mode for street view
function toggleStreetLightPlacement() {
    try {
        window.isStreetLightPlacementActive = !window.isStreetLightPlacementActive;
        const btn = document.getElementById('streetPlaceLightsBtn');
        
        if (window.isStreetLightPlacementActive) {
            btn.innerHTML = 'â¸ï¸ Stop Placement';
            btn.style.background = '#F44336';
            btn.style.color = 'white';
            
            // Add click listener to captured street canvas
            const streetCanvas = document.getElementById('capturedStreetCanvas');
            if (streetCanvas) {
                streetCanvas.style.cursor = 'crosshair';
                streetCanvas.addEventListener('click', handleStreetLightPlacement);
            }
            
            console.log('Street light placement mode activated');
        } else {
            btn.innerHTML = 'ğŸ“ Place Lights';
            btn.style.background = '#FFC107';
            btn.style.color = 'white';
            
            // Remove click listener
            const streetCanvas = document.getElementById('capturedStreetCanvas');
            if (streetCanvas) {
                streetCanvas.style.cursor = 'default';
                streetCanvas.removeEventListener('click', handleStreetLightPlacement);
            }
            
            console.log('Street light placement mode deactivated');
        }
    } catch (error) {
        console.error('Error toggling street light placement:', error);
    }
}

// Handle light placement on aerial view
function handleAerialLightPlacement(event) {
    try {
        if (!isAerialLightPlacementActive) return;
        
        const canvas = event.target;
        if (!canvas) {
            console.error('No canvas found for aerial light placement');
            return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Add new light
        const newLight = { x, y, timestamp: Date.now() };
        if (!window.aerialLights) window.aerialLights = [];
        window.aerialLights.push(newLight);
        
        // Redraw all lights
        if (typeof drawAerialPlacedLights === 'function') {
            drawAerialPlacedLights();
        }
        
        // Update measurements
        if (typeof updateAerialMeasurementsFromLights === 'function') {
            updateAerialMeasurementsFromLights();
        }
        
        console.log('Aerial light placed at:', { x, y }, 'Total lights:', window.aerialLights.length);
        
    } catch (error) {
        console.error('Error placing aerial light:', error);
    }
}

// Handle light placement on street view
function handleStreetLightPlacement(event) {
    try {
        if (!isStreetLightPlacementActive) return;
        
        const canvas = event.target;
        if (!canvas) {
            console.error('No canvas found for street light placement');
            return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Add new light
        const newLight = { x, y, timestamp: Date.now() };
        if (!window.streetLights) window.streetLights = [];
        window.streetLights.push(newLight);
        
        // Redraw all lights
        if (typeof drawStreetPlacedLights === 'function') {
            drawStreetPlacedLights();
        }
        
        // Update measurements
        if (typeof updateStreetMeasurementsFromLights === 'function') {
            updateStreetMeasurementsFromLights();
        }
        
        console.log('Street light placed at:', { x, y }, 'Total lights:', window.streetLights.length);
        
    } catch (error) {
        console.error('Error placing street light:', error);
    }
}

// Draw all placed lights on aerial view
function drawAerialPlacedLights() {
    try {
        const canvas = document.getElementById('aerialCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Clear previous lights
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Redraw paths if they exist
        if (canvas.drawingData && canvas.drawingData.paths) {
            redrawAllPaths(canvas, ctx, 'aerial');
        }
        
        // Draw all placed lights
        if (window.aerialLights) {
            const lightColor = document.getElementById('aerialLightColor')?.value || '#FFD700';
            
            window.aerialLights.forEach((light, index) => {
                // Draw light circle
                ctx.fillStyle = lightColor;
                ctx.shadowColor = lightColor;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(light.x, light.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw light number
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), light.x, light.y + 4);
                
                // Draw connection line to next light (if exists)
                if (index < window.aerialLights.length - 1) {
                    const nextLight = window.aerialLights[index + 1];
                    ctx.strokeStyle = lightColor;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.moveTo(light.x, light.y);
                    ctx.lineTo(nextLight.x, nextLight.y);
                    ctx.stroke();
                }
            });
            
            console.log('Aerial placed lights redrawn:', window.aerialLights.length);
        }
        
    } catch (error) {
        console.error('Error drawing aerial placed lights:', error);
    }
}

// Draw all placed lights on street view
function drawStreetPlacedLights() {
    try {
        const canvas = document.getElementById('capturedStreetCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Clear previous lights
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Redraw paths if they exist
        if (canvas.drawingData && canvas.drawingData.paths) {
            redrawAllPaths(canvas, ctx, 'street');
        }
        
        // Draw all placed lights
        if (window.streetLights) {
            const lightColor = document.getElementById('streetLightColor')?.value || '#FFD700';
            
            window.streetLights.forEach((light, index) => {
                // Draw light circle
                ctx.fillStyle = lightColor;
                ctx.shadowColor = lightColor;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(light.x, light.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw light number
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), light.x, light.y + 4);
                
                // Draw connection line to next light (if exists)
                if (index < window.streetLights.length - 1) {
                    const nextLight = window.streetLights[index + 1];
                    ctx.strokeStyle = lightColor;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.moveTo(light.x, light.y);
                    ctx.lineTo(nextLight.x, nextLight.y);
                    ctx.stroke();
                }
            });
            
            console.log('Street placed lights redrawn:', window.streetLights.length);
        }
        
    } catch (error) {
        console.error('Error drawing street placed lights:', error);
    }
}

// Calculate measurements from placed lights (aerial)
function updateAerialMeasurementsFromLights() {
    try {
        if (!window.aerialLights || window.aerialLights.length < 2) {
            // Not enough lights for measurement
            if (typeof updateAerialDisplay === 'function') {
                updateAerialDisplay();
            }
            return;
        }
        
        let totalDistance = 0;
        const segments = [];
        
        // Calculate distances between consecutive lights
        for (let i = 1; i < window.aerialLights.length; i++) {
            const prevLight = window.aerialLights[i - 1];
            const currentLight = window.aerialLights[i];
            
            const dx = currentLight.x - prevLight.x;
            const dy = currentLight.y - prevLight.y;
            const pixelDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Convert pixels to feet using scale factor
            const distanceFeet = pixelDistance * (aerialScaleFactor || 0.1);
            
            segments.push({
                start: prevLight,
                end: currentLight,
                length: distanceFeet,
                type: 'front', // Default
                side: 'front'
            });
            
            totalDistance += distanceFeet;
        }
        
        // Update measurements object
        if (!measurements.aerial) measurements.aerial = {};
        measurements.aerial.total = totalDistance;
        measurements.aerial.segments = segments;
        measurements.aerial.front = totalDistance; // For now, all in front
        
        // Update display with safety checks
        if (typeof updateAerialDisplay === 'function') updateAerialDisplay();
        if (typeof updateCombinedMeasurements === 'function') updateCombinedMeasurements();
        if (typeof updateLightVisualization === 'function') updateLightVisualization();
        if (typeof updatePricing === 'function') updatePricing();
        
        console.log('Aerial measurements updated from lights:', { totalDistance: totalDistance.toFixed(2), segments: segments.length });
        
    } catch (error) {
        console.error('Error updating aerial measurements from lights:', error);
    }
}

// Calculate measurements from placed lights (street)
function updateStreetMeasurementsFromLights() {
    try {
        if (!window.streetLights || window.streetLights.length < 2) {
            // Not enough lights for measurement
            if (typeof updateStreetDisplay === 'function') {
                updateStreetDisplay();
            }
            return;
        }
        
        let totalDistance = 0;
        const segments = [];
        
        // Calculate distances between consecutive lights
        for (let i = 1; i < window.streetLights.length; i++) {
            const prevLight = window.streetLights[i - 1];
            const currentLight = window.streetLights[i];
            
            const dx = currentLight.x - prevLight.x;
            const dy = currentLight.y - prevLight.y;
            const pixelDistance = Math.sqrt(dx * dx + dy * dy);
            
            // Convert pixels to feet using scale factor
            const distanceFeet = pixelDistance * (streetScaleFactor || 0.1);
            
            segments.push({
                start: prevLight,
                end: currentLight,
                length: distanceFeet,
                type: 'front', // Default
                side: 'front'
            });
            
            totalDistance += distanceFeet;
        }
        
        // Update measurements object
        if (!measurements.street) measurements.street = {};
        measurements.street.total = totalDistance;
        measurements.street.segments = segments;
        
        // Reset all side measurements to 0 since we're not using the old side system
        measurements.street.front = 0;
        measurements.street.leftSide = 0;
        measurements.street.rightSide = 0;
        measurements.street.back = 0;
        
        // Update display with safety checks
        if (typeof updateStreetDisplay === 'function') updateStreetDisplay();
        if (typeof updateCombinedMeasurements === 'function') updateCombinedMeasurements();
        if (typeof updateLightVisualization === 'function') updateLightVisualization();
        if (typeof updatePricing === 'function') updatePricing();
        
        console.log('Street measurements updated from lights:', { totalDistance: totalDistance.toFixed(2), segments: segments.length });
        
    } catch (error) {
        console.error('Error updating street measurements from lights:', error);
    }
}

// Clear all placed lights (aerial)
function clearAerialLights() {
    try {
        window.aerialLights = [];
        window.isAerialLightPlacementActive = false;
        
        // Reset button
        const btn = document.getElementById('aerialPlaceLightsBtn');
        if (btn) {
            btn.innerHTML = 'ğŸ“ Place Lights';
            btn.style.background = '#FFC107';
            btn.style.color = 'white';
        }
        
        // Remove click listener
        const aerialCanvas = document.getElementById('aerialCanvas');
        if (aerialCanvas) {
            aerialCanvas.style.cursor = 'default';
            aerialCanvas.removeEventListener('click', handleAerialLightPlacement);
        }
        
        // Clear canvas and redraw
        if (typeof drawAerialPlacedLights === 'function') {
            drawAerialPlacedLights();
        }
        
        // Reset measurements
        if (measurements.aerial) {
            measurements.aerial.total = 0;
            measurements.aerial.segments = [];
        }
        
        // Update display with safety checks
        if (typeof updateAerialDisplay === 'function') updateAerialDisplay();
        if (typeof updateCombinedMeasurements === 'function') updateCombinedMeasurements();
        if (typeof updateLightVisualization === 'function') updateLightVisualization();
        if (typeof updatePricing === 'function') updatePricing();
        
        console.log('Aerial lights cleared');
        
    } catch (error) {
        console.error('Error clearing aerial lights:', error);
    }
}

// Clear all placed lights (street)
function clearStreetLights() {
    try {
        window.streetLights = [];
        window.isStreetLightPlacementActive = false;
        
        // Reset button
        const btn = document.getElementById('streetPlaceLightsBtn');
        if (btn) {
            btn.innerHTML = 'ğŸ“ Place Lights';
            btn.style.background = '#FFC107';
            btn.style.color = 'white';
        }
        
        // Remove click listener
        const streetCanvas = document.getElementById('capturedStreetCanvas');
        if (streetCanvas) {
            streetCanvas.style.cursor = 'default';
            streetCanvas.removeEventListener('click', handleStreetLightPlacement);
        }
        
        // Clear canvas and redraw
        if (typeof drawStreetPlacedLights === 'function') {
            drawStreetPlacedLights();
        }
        
        // Reset measurements
        if (measurements.street) {
            measurements.street.total = 0;
            measurements.street.segments = [];
        }
        
        // Update display with safety checks
        if (typeof updateStreetDisplay === 'function') updateStreetDisplay();
        if (typeof updateCombinedMeasurements === 'function') updateCombinedMeasurements();
        if (typeof updateLightVisualization === 'function') updateLightVisualization();
        if (typeof updatePricing === 'function') updatePricing();
        
        console.log('Street lights cleared');
        
    } catch (error) {
        console.error('Error clearing street lights:', error);
    }
}

// Update light spacing for aerial view
function updateAerialLightSpacing() {
    try {
        const spacing = document.getElementById('aerialLightSpacing')?.value || 8;
        console.log('Aerial light spacing updated to:', spacing, 'inches');
        
        // Automatically space lights at the specified interval
        if (window.aerialLights && window.aerialLights.length >= 2) {
            // Calculate total path length
            let totalLength = 0;
            for (let i = 1; i < window.aerialLights.length; i++) {
                const prev = window.aerialLights[i - 1];
                const curr = window.aerialLights[i];
                const distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
                totalLength += distance;
            }
            
            // Convert spacing from inches to pixels using scale factor
            const spacingPixels = (spacing / 12) * aerialScaleFactor;
            
            // Calculate how many lights we need
            const numLights = Math.floor(totalLength / spacingPixels) + 1;
            
            // Redistribute lights evenly along the path
            const newLights = [];
            for (let i = 0; i < numLights; i++) {
                const t = i / (numLights - 1);
                const lightIndex = Math.floor(t * (window.aerialLights.length - 1));
                const nextIndex = Math.min(lightIndex + 1, window.aerialLights.length - 1);
                const lightT = (t * (window.aerialLights.length - 1)) - lightIndex;
                
                const light = window.aerialLights[lightIndex];
                const nextLight = window.aerialLights[nextIndex];
                
                const x = light.x + (nextLight.x - light.x) * lightT;
                const y = light.y + (nextLight.y - light.y) * lightT;
                
                newLights.push({ x, y, timestamp: Date.now() });
            }
            
            window.aerialLights = newLights;
            
            // Redraw with new spacing
            if (typeof drawAerialPlacedLights === 'function') {
                drawAerialPlacedLights();
            }
            
            // Update measurements
            if (typeof updateAerialMeasurementsFromLights === 'function') {
                updateAerialMeasurementsFromLights();
            }
        }
    } catch (error) {
        console.error('Error updating aerial light spacing:', error);
    }
}

// Update bulb size for aerial view
function updateAerialBulbSize() {
    try {
        const bulbSize = parseFloat(document.getElementById('aerialBulbSize')?.value || 1);
        const bulbSizeValue = document.getElementById('aerialBulbSizeValue');
        if (bulbSizeValue) {
            bulbSizeValue.textContent = bulbSize.toFixed(1) + '"';
        }
        console.log('Aerial bulb size updated to:', bulbSize, 'inches');
        
        // Store the bulb size for use in drawing functions
        window.aerialBulbSize = bulbSize;
        
        // Redraw lights with new size
        const aerialCanvas = document.getElementById('aerialCanvas');
        if (aerialCanvas && window.aerialLightPositions && window.aerialLightPositions.length > 0) {
            redrawCanvasWithLights(aerialCanvas, 'aerial');
        }
        
    } catch (error) {
        console.error('Error updating aerial bulb size:', error);
    }
}

// Update bulb size for street view
function updateStreetBulbSize() {
    try {
        const bulbSize = parseFloat(document.getElementById('streetBulbSize')?.value || 1);
        const bulbSizeValue = document.getElementById('streetBulbSizeValue');
        if (bulbSizeValue) {
            bulbSizeValue.textContent = bulbSize.toFixed(1) + '"';
        }
        console.log('Street bulb size updated to:', bulbSize, 'inches');
        
        // Store the bulb size for use in drawing functions
        window.streetBulbSize = bulbSize;
        
        // Redraw lights with new size
        const streetCanvas = document.getElementById('capturedStreetCanvas');
        if (streetCanvas && window.capturedStreetLightPositions && window.capturedStreetLightPositions.length > 0) {
            redrawCanvasWithLights(streetCanvas, 'capturedStreet');
        }
        
    } catch (error) {
        console.error('Error updating street bulb size:', error);
    }
}

// Update light spacing for street view
function updateStreetLightSpacing() {
    try {
        const spacing = document.getElementById('streetLightSpacing')?.value || 8;
        console.log('Street light spacing updated to:', spacing, 'inches');
        
        // Automatically space lights at the specified interval
        if (window.streetLights && window.streetLights.length >= 2) {
            // Calculate total path length
            let totalLength = 0;
            for (let i = 1; i < window.streetLights.length; i++) {
                const prev = window.streetLights[i - 1];
                const curr = window.streetLights[i];
                const distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
                totalLength += distance;
            }
            
            // Convert spacing from inches to pixels using scale factor
            const spacingPixels = (spacing / 12) * streetScaleFactor;
            
            // Calculate how many lights we need
            const numLights = Math.floor(totalLength / spacingPixels) + 1;
            
            // Redistribute lights evenly along the path
            const newLights = [];
            for (let i = 0; i < numLights; i++) {
                const t = i / (numLights - 1);
                const lightIndex = Math.floor(t * (window.streetLights.length - 1));
                const nextIndex = Math.min(lightIndex + 1, window.streetLights.length - 1);
                const lightT = (t * (window.streetLights.length - 1)) - lightIndex;
                
                const light = window.streetLights[lightIndex];
                const nextLight = window.streetLights[nextIndex];
                
                const x = light.x + (nextLight.x - light.x) * lightT;
                const y = light.y + (nextLight.y - light.y) * lightT;
                
                newLights.push({ x, y, timestamp: Date.now() });
            }
            
            window.streetLights = newLights;
            
            // Redraw with new spacing
            if (typeof drawStreetPlacedLights === 'function') {
                drawStreetPlacedLights();
            }
            
            // Update measurements
            if (typeof updateStreetMeasurementsFromLights === 'function') {
                updateStreetMeasurementsFromLights();
            }
        }
    } catch (error) {
        console.error('Error updating street light spacing:', error);
    }
}

// Update aerial darkness
function updateAerialDarkness() {
    try {
        const darkness = parseInt(document.getElementById('aerialDarknessSlider')?.value || 0);
        const darknessValue = document.getElementById('aerialDarknessValue');
        if (darknessValue) {
            darknessValue.textContent = darkness + '%';
        }
        
        console.log('ğŸ¨ Updating aerial darkness to:', darkness + '%');
        
        // Apply darkness filter to aerial canvas
        const aerialCanvas = document.getElementById('aerialCanvas');
        if (aerialCanvas) {
            const ctx = aerialCanvas.getContext('2d');
            if (ctx) {
                // Check if there's content on the canvas
                const imageData = ctx.getImageData(0, 0, aerialCanvas.width, aerialCanvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                
                if (hasContent) {
                    // Create a temporary canvas to store the current state
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = aerialCanvas.width;
                    tempCanvas.height = aerialCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Copy current aerial canvas content to temp canvas
                    tempCtx.drawImage(aerialCanvas, 0, 0);
                    
                    // Clear the aerial canvas
                    ctx.clearRect(0, 0, aerialCanvas.width, aerialCanvas.height);
                    
                    // Redraw the temp canvas content
                    ctx.drawImage(tempCanvas, 0, 0);
                    
                    // Apply darkness filter only if darkness > 0
                    if (darkness > 0) {
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = `rgba(0, 0, 0, ${darkness / 100})`;
                        ctx.fillRect(0, 0, aerialCanvas.width, aerialCanvas.height);
                        ctx.globalCompositeOperation = 'source-over';
                        console.log('âœ… Darkness filter applied to aerial canvas');
                    } else {
                        console.log('âœ… No darkness filter (value is 0)');
                    }
                } else {
                    console.log('âš ï¸ Aerial canvas has no content to darken');
                }
            }
        } else {
            console.log('âš ï¸ Aerial canvas not found');
        }
        
        console.log('Aerial darkness updated to:', darkness + '%');
    } catch (error) {
        console.error('Error updating aerial darkness:', error);
    }
}

// Update street darkness
function updateStreetDarkness() {
    try {
        const darkness = parseInt(document.getElementById('streetDarknessSlider')?.value || 0);
        const darknessValue = document.getElementById('streetDarknessValue');
        if (darknessValue) {
            darknessValue.textContent = darkness + '%';
        }
        
        console.log('ğŸ¨ Updating street darkness to:', darkness + '%');
        
        // Apply darkness filter to street canvas
        const streetCanvas = document.getElementById('capturedStreetCanvas');
        if (streetCanvas) {
            const ctx = streetCanvas.getContext('2d');
            if (ctx) {
                // Check if there's content on the canvas
                const imageData = ctx.getImageData(0, 0, streetCanvas.width, streetCanvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                
                if (hasContent) {
                    // Create a temporary canvas to store the current state
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = streetCanvas.width;
                    tempCanvas.height = streetCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Copy current street canvas content to temp canvas
                    tempCtx.drawImage(streetCanvas, 0, 0);
                    
                    // Clear the street canvas
                    ctx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
                    
                    // Redraw the temp canvas content
                    ctx.drawImage(tempCanvas, 0, 0);
                    
                    // Apply darkness filter only if darkness > 0
                    if (darkness > 0) {
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = `rgba(0, 0, 0, ${darkness / 100})`;
                        ctx.fillRect(0, 0, streetCanvas.width, streetCanvas.height);
                        ctx.globalCompositeOperation = 'source-over';
                        console.log('âœ… Darkness filter applied to street canvas');
                    } else {
                        console.log('âœ… No darkness filter (value is 0)');
                    }
                } else {
                    console.log('âš ï¸ Street canvas has no content to darken');
                }
            }
        } else {
            console.log('âš ï¸ Street canvas not found');
        }
        
        console.log('Street darkness updated to:', darkness + '%');
    } catch (error) {
        console.error('Error updating street darkness:', error);
    }
}

// Update aerial light color
function updateAerialLightColor() {
    try {
        const color = document.getElementById('aerialLightColor')?.value || '#FFD700';
        console.log('Aerial light color updated to:', color);
        
        // Redraw lights with new color
        if (window.aerialLights && window.aerialLights.length > 0) {
            if (typeof drawAerialPlacedLights === 'function') {
                drawAerialPlacedLights();
            }
        }
    } catch (error) {
        console.error('Error updating aerial light color:', error);
    }
}

// Update street light color
function updateStreetLightColor() {
    try {
        const color = document.getElementById('streetLightColor')?.value || '#FFD700';
        console.log('Street light color updated to:', color);
        
        // Redraw lights with new color
        if (window.streetLights && window.streetLights.length > 0) {
            if (typeof drawStreetPlacedLights === 'function') {
                drawStreetPlacedLights();
            }
        }
    } catch (error) {
        console.error('Error updating street light color:', error);
    }
}

// Update aerial animation speed
function updateAerialAnimationSpeed() {
    try {
        const speed = document.getElementById('aerialAnimationSpeed')?.value || 5;
        const speedValue = document.getElementById('aerialSpeedValue');
        if (speedValue) {
            speedValue.textContent = speed;
        }
        console.log('Aerial animation speed updated to:', speed);
    } catch (error) {
        console.error('Error updating aerial animation speed:', error);
    }
}

// Update street animation speed
function updateStreetAnimationSpeed() {
    try {
        const speed = document.getElementById('streetAnimationSpeed')?.value || 5;
        const speedValue = document.getElementById('streetSpeedValue');
        if (speedValue) {
            speedValue.textContent = speed;
        }
        console.log('Street animation speed updated to:', speed);
    } catch (error) {
        console.error('Error updating street animation speed:', error);
    }
}

// Street View Orientation Controls
function updateStreetViewOrientation() {
    try {
        const heading = parseInt(document.getElementById('streetHeading')?.value || 0);
        const pitch = parseInt(document.getElementById('streetPitch')?.value || 0);
        const zoom = parseFloat(document.getElementById('streetZoom')?.value || 1);
        
        // Update display values
        const headingValue = document.getElementById('headingValue');
        const pitchValue = document.getElementById('pitchValue');
        const zoomValue = document.getElementById('zoomValue');
        
        if (headingValue) headingValue.textContent = heading + 'Â°';
        if (pitchValue) pitchValue.textContent = pitch + 'Â°';
        if (zoomValue) zoomValue.textContent = zoom.toFixed(1);
        
        console.log('Street view orientation updated:', { heading, pitch, zoom });
        
        // Store the orientation values for use in capture
        window.streetViewOrientation = { heading, pitch, zoom };
        
    } catch (error) {
        console.error('Error updating street view orientation:', error);
    }
}

function resetStreetViewOrientation() {
    try {
        // Reset sliders to default values
        const headingSlider = document.getElementById('streetHeading');
        const pitchSlider = document.getElementById('streetPitch');
        const zoomSlider = document.getElementById('streetZoom');
        
        if (headingSlider) headingSlider.value = 0;
        if (pitchSlider) pitchSlider.value = 0;
        if (zoomSlider) zoomSlider.value = 1;
        
        // Update display values
        updateStreetViewOrientation();
        
        console.log('Street view orientation reset to defaults');
        
    } catch (error) {
        console.error('Error resetting street view orientation:', error);
    }
}

function applyStreetViewOrientation() {
    try {
        if (!streetView) {
            showStatus('Street View not available. Please load a property first.', 'error');
            return;
        }
        
        const orientation = window.streetViewOrientation || { heading: 0, pitch: 0, zoom: 1 };
        
        // Apply the orientation to the live street view
        streetView.setPov({
            heading: orientation.heading,
            pitch: orientation.pitch
        });
        
        // Note: Google Street View doesn't support zoom changes in the live view
        // The zoom will be applied when capturing the static image
        
        showStatus(`Street view orientation applied: ${orientation.heading}Â° heading, ${orientation.pitch}Â° pitch`, 'success');
        console.log('Street view orientation applied:', orientation);
        
    } catch (error) {
        console.error('Error applying street view orientation:', error);
        showStatus('Failed to apply orientation changes.', 'error');
    }
}

// Helper function to redraw all paths on a canvas
function redrawAllPaths(canvas, ctx, type) {
    try {
        if (!canvas.drawingData || !canvas.drawingData.paths) return;
        
        const paths = canvas.drawingData.paths;
        
        // Place lights along all paths instead of drawing lines
        paths.forEach(path => {
            if (path.length >= 2) {
                // Place lights along the path
                for (let i = 0; i < path.length; i++) {
                    const point = path[i];
                    const lightSize = 5;
                    
                    // Draw light
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, lightSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add subtle glow effect
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, lightSize + 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        });
        
        console.log('Paths redrawn for', type, 'view');
        
    } catch (error) {
        console.error('Error redrawing paths:', error);
    }
}

// Animation system for lights
let lightAnimationId = null;
let lightAnimationFrame = 0;
let isLightAnimationRunning = false;

function startLightAnimation() {
    try {
        if (isLightAnimationRunning) return;
        
        isLightAnimationRunning = true;
        lightAnimationFrame = 0;
        animateLights();
        console.log('Light animation started');
    } catch (error) {
        console.error('Error starting light animation:', error);
    }
}

function stopLightAnimation() {
    try {
        if (lightAnimationId) {
            cancelAnimationFrame(lightAnimationId);
            lightAnimationId = null;
        }
        isLightAnimationRunning = false;
        lightAnimationFrame = 0;
        console.log('Light animation stopped');
    } catch (error) {
        console.error('Error stopping light animation:', error);
    }
}

function animateLights() {
    try {
        if (!isLightAnimationRunning) return;
        
        lightAnimationFrame++;
        
        // Get animation mode from user selection
        const animationMode = document.getElementById('animationMode')?.value || 'static';
        const animationSpeed = parseFloat(document.getElementById('animationSpeed')?.value || 5);
        
        // Calculate intensity based on animation mode and frame
        let intensity = 0.8;
        
        switch (animationMode) {
            case 'twinkle':
                intensity = 0.3 + 0.5 * Math.sin(lightAnimationFrame * 0.1);
                break;
            case 'chase':
                intensity = 0.3 + 0.5 * Math.sin(lightAnimationFrame * 0.05);
                break;
            case 'fade':
                intensity = 0.2 + 0.6 * Math.sin(lightAnimationFrame * 0.02);
                break;
            case 'rainbow':
                intensity = 0.8;
                break;
            case 'patriotic':
                intensity = 0.4 + 0.4 * Math.sin(lightAnimationFrame * 0.03);
                break;
            case 'fireworks':
                intensity = 0.1 + 0.7 * Math.random();
                break;
            default:
                intensity = 0.8;
        }
        
        // DISABLED: Old light drawing system - now using new light placement system
        // Redraw lights with current intensity
        // const aerialCanvas = document.getElementById('aerialLightOverlay');
        // if (aerialCanvas) {
        //     const ctx = aerialCanvas.getContext('2d');
        //     const rect = aerialCanvas.getBoundingClientRect();
        //     aerialCanvas.width = rect.width;
        //     aerialCanvas.height = rect.height;
        //     drawAerialLights(ctx, aerialCanvas.width, aerialCanvas.height, intensity);
        // }
        // 
        // const streetCanvas = document.getElementById('capturedStreetLightOverlay');
        // if (streetCanvas) {
        //     const ctx = streetCanvas.getContext('2d');
        //     const rect = streetCanvas.getBoundingClientRect();
        //     streetCanvas.width = rect.width;
        //     streetCanvas.height = rect.height;
        //     drawStreetLights(ctx, streetCanvas.width, streetCanvas.height, intensity);
        // }
        // 
        // Continue animation
        // lightAnimationId = requestAnimationFrame(animateLights);
        
    } catch (error) {
        console.error('Error in light animation:', error);
        stopLightAnimation();
    }
}

// DISABLED: Old light animation system - now using new light placement system
// function toggleLightAnimation() {
//     try {
//         const toggleBtn = document.getElementById('animationToggle');
//         const isRunning = isLightAnimationRunning;
//         
//         if (isRunning) {
//             stopLightAnimation();
//             toggleBtn.innerHTML = 'â–¶ï¸ Start Animation';
//             toggleBtn.style.background = '#9C27B0';
//         } else {
//             startLightAnimation();
//             toggleBtn.innerHTML = 'â¸ï¸ Stop Animation';
//             toggleBtn.style.background = '#F44336';
//         }
//         
//         console.log('Light animation toggled:', !isRunning ? 'started' : 'stopped');
//     } catch (error) {
//         console.error('Error toggling light animation:', error);
//     }
// }

// Update speed display when slider changes
function updateAnimationSpeed() {
    try {
        const speedSlider = document.getElementById('animationSpeed');
        const speedValue = document.getElementById('speedValue');
        
        if (speedSlider && speedValue) {
            speedValue.textContent = speedSlider.value;
        }
    } catch (error) {
        console.error('Error updating animation speed:', error);
    }
}

// Individual animation controls for aerial and street views
function toggleAerialAnimation() {
    try {
        const toggleBtn = document.getElementById('aerialAnimationToggle');
        const isRunning = aerialAnimationRunning;
        
        if (isRunning) {
            stopAerialAnimation();
            toggleBtn.innerHTML = 'â–¶ï¸ Start Animation';
            toggleBtn.style.background = '#9C27B0';
        } else {
            startAerialAnimation();
            toggleBtn.innerHTML = 'â¸ï¸ Stop Animation';
            toggleBtn.style.background = '#F44336';
        }
        
        console.log('Aerial animation toggled:', !isRunning ? 'started' : 'stopped');
    } catch (error) {
        console.error('Error toggling aerial animation:', error);
    }
}

function toggleStreetAnimation() {
    try {
        const toggleBtn = document.getElementById('streetAnimationToggle');
        const isRunning = streetAnimationRunning;
        
        if (isRunning) {
            stopStreetAnimation();
            toggleBtn.innerHTML = 'â–¶ï¸ Start Animation';
            toggleBtn.style.background = '#9C27B0';
        } else {
            startStreetAnimation();
            toggleBtn.innerHTML = 'â¸ï¸ Stop Animation';
            toggleBtn.style.background = '#F44336';
        }
        
        console.log('Street animation toggled:', !isRunning ? 'started' : 'stopped');
    } catch (error) {
        console.error('Error toggling street animation:', error);
    }
}

function updateAerialAnimationSpeed() {
    try {
        const speedSlider = document.getElementById('aerialAnimationSpeed');
        const speedValue = document.getElementById('aerialSpeedValue');
        
        if (speedSlider && speedValue) {
            speedValue.textContent = speedSlider.value;
        }
    } catch (error) {
        console.error('Error updating aerial animation speed:', error);
    }
}

function updateStreetAnimationSpeed() {
    try {
        const speedSlider = document.getElementById('streetAnimationSpeed');
        const speedValue = document.getElementById('streetSpeedValue');
        
        if (speedSlider && speedValue) {
            speedValue.textContent = speedSlider.value;
        }
    } catch (error) {
        console.error('Error updating street animation speed:', error);
    }
}

// Individual animation state variables
let aerialAnimationRunning = false;
let streetAnimationRunning = false;

function startAerialAnimation() {
    try {
        if (aerialAnimationRunning) return;
        
        aerialAnimationRunning = true;
        animateAerialLights();
        console.log('Aerial animation started');
    } catch (error) {
        console.error('Error starting aerial animation:', error);
    }
}

function stopAerialAnimation() {
    try {
        if (aerialAnimationId) {
            cancelAnimationFrame(aerialAnimationId);
            aerialAnimationId = null;
        }
        aerialAnimationRunning = false;
        console.log('Aerial animation stopped');
    } catch (error) {
        console.error('Error stopping aerial animation:', error);
    }
}

function startStreetAnimation() {
    try {
        if (streetAnimationRunning) return;
        
        streetAnimationRunning = true;
        animateStreetLights();
        console.log('Street animation started');
    } catch (error) {
        console.error('Error starting street animation:', error);
    }
}

function stopStreetAnimation() {
    try {
        if (streetAnimationId) {
            cancelAnimationFrame(streetAnimationId);
            streetAnimationId = null;
        }
        streetAnimationRunning = false;
        console.log('Street animation stopped');
    } catch (error) {
        console.error('Error stopping street animation:', error);
    }
}

function animateAerialLights() {
    try {
        if (!aerialAnimationRunning) return;
        
        // Get animation mode from aerial controls
        const animationMode = document.getElementById('aerialAnimationMode')?.value || 'static';
        const animationSpeed = parseFloat(document.getElementById('aerialAnimationSpeed')?.value || 5);
        
        // Calculate intensity based on animation mode
        let intensity = 0.8;
        
        switch (animationMode) {
            case 'twinkle':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.005 * animationSpeed);
                break;
            case 'chase':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.003 * animationSpeed);
                break;
            case 'fade':
                intensity = 0.2 + 0.6 * Math.sin(Date.now() * 0.002 * animationSpeed);
                break;
            case 'rainbow':
                intensity = 0.8;
                break;
            case 'christmas':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.006 * animationSpeed);
                break;
            case 'patriotic':
                intensity = 0.4 + 0.4 * Math.sin(Date.now() * 0.004 * animationSpeed);
                break;
            case 'fireworks':
                intensity = 0.1 + 0.7 * Math.random();
                break;
            default:
                intensity = 0.8;
        }
        
        // Redraw aerial lights with current intensity
        const aerialCanvas = document.getElementById('aerialCanvas');
        if (aerialCanvas) {
            const ctx = aerialCanvas.getContext('2d');
            // Clear and redraw paths
            redrawAllPaths(aerialCanvas, ctx, 'aerial');
            // Draw placed lights with animation
            drawAerialPlacedLightsWithAnimation(intensity);
        }
        
        // Continue animation
        aerialAnimationId = requestAnimationFrame(animateAerialLights);
        
    } catch (error) {
        console.error('Error in aerial light animation:', error);
        stopAerialAnimation();
    }
}

function animateStreetLights() {
    try {
        if (!streetAnimationRunning) return;
        
        // Get animation mode from street controls
        const animationMode = document.getElementById('streetAnimationMode')?.value || 'static';
        const animationSpeed = parseFloat(document.getElementById('streetAnimationSpeed')?.value || 5);
        
        // Calculate intensity based on animation mode
        let intensity = 0.8;
        
        switch (animationMode) {
            case 'twinkle':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.005 * animationSpeed);
                break;
            case 'chase':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.003 * animationSpeed);
                break;
            case 'fade':
                intensity = 0.2 + 0.6 * Math.sin(Date.now() * 0.002 * animationSpeed);
                break;
            case 'rainbow':
                intensity = 0.8;
                break;
            case 'christmas':
                intensity = 0.3 + 0.5 * Math.sin(Date.now() * 0.006 * animationSpeed);
                break;
            case 'patriotic':
                intensity = 0.4 + 0.4 * Math.sin(Date.now() * 0.004 * animationSpeed);
                break;
            case 'fireworks':
                intensity = 0.1 + 0.7 * Math.random();
                break;
            default:
                intensity = 0.8;
        }
        
        // Redraw street lights with current intensity
        const capturedCanvas = document.getElementById('capturedStreetCanvas');
        if (capturedCanvas) {
            const ctx = capturedCanvas.getContext('2d');
            // Clear and redraw paths
            redrawAllPaths(capturedCanvas, ctx, 'street');
            // Draw placed lights with animation
            drawStreetPlacedLightsWithAnimation(intensity);
        }
        
        // Continue animation
        streetAnimationId = requestAnimationFrame(animateStreetLights);
        
    } catch (error) {
        console.error('Error in street light animation:', error);
        stopStreetAnimation();
    }
}

// Function to draw measurement labels on lines (like inchr.io)
function drawMeasurementLabels(canvas, ctx, viewType) {
    try {
        if (!canvas || !canvas.drawingData || !canvas.drawingData.paths) {
            return;
        }
        
        const paths = canvas.drawingData.paths;
        const scaleFactor = viewType === 'aerial' ? aerialScaleFactor : streetScaleFactor;
        
        ctx.font = '12px Arial';
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        paths.forEach((path, pathIndex) => {
            if (path.length < 2) return;
            
            // Calculate total length of this path
            let pathLength = 0;
            for (let i = 1; i < path.length; i++) {
                const dx = path[i].x - path[i-1].x;
                const dy = path[i].y - path[i-1].y;
                pathLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // Convert pixels to feet
            const pathLengthFeet = pathLength * scaleFactor;
            
            // Find the middle point of the path for label placement
            let midPoint = Math.floor(path.length / 2);
            if (midPoint >= path.length) midPoint = path.length - 1;
            
            const x = path[midPoint].x;
            const y = path[midPoint].y;
            
            // Format measurement (feet and inches like inchr.io)
            const feet = Math.floor(pathLengthFeet);
            const inches = Math.round((pathLengthFeet - feet) * 12);
            
            let labelText;
            if (feet > 0 && inches > 0) {
                labelText = `${feet}' ${inches}"`;
            } else if (feet > 0) {
                labelText = `${feet}'`;
            } else {
                labelText = `${inches}"`;
            }
            
            // Draw label background for readability
            const textMetrics = ctx.measureText(labelText);
            const padding = 4;
            const bgWidth = textMetrics.width + padding * 2;
            const bgHeight = 16 + padding * 2;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - bgWidth/2, y - bgHeight/2, bgWidth, bgHeight);
            
            // Draw label text
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.fillText(labelText, x, y);
            ctx.strokeText(labelText, x, y);
            
            console.log(`Measurement label drawn: ${labelText} at (${x}, ${y})`);
        });
        
    } catch (error) {
        console.error('Error drawing measurement labels:', error);
    }
}

// Initialize the new sliders
function initializeSeparateSliders() {
    try {
        // Initialize aerial slider
        const aerialSlider = document.getElementById('aerialLightTransitionSlider');
        if (aerialSlider) {
            aerialSlider.addEventListener('input', (e) => {
                updateAerialLightTransition(parseInt(e.target.value));
            });
        }
        
        // Initialize street slider
        const streetSlider = document.getElementById('streetLightTransitionSlider');
        if (streetSlider) {
            streetSlider.addEventListener('input', (e) => {
                updateStreetLightTransition(parseInt(e.target.value));
            });
        }
        
        // Initialize canvases
        initializeSeparateSliderCanvases();
        
        console.log('âœ… Separate sliders initialized successfully');
        
    } catch (error) {
        console.error('Error initializing separate sliders:', error);
    }
}

function initializeSeparateSliderCanvases() {
    try {
        // Initialize aerial canvas
        const aerialCanvas = document.getElementById('aerialLightTransitionCanvas');
        if (aerialCanvas) {
            aerialCanvas.width = aerialCanvas.offsetWidth;
            aerialCanvas.height = aerialCanvas.offsetHeight;
            console.log('ğŸ¨ Aerial canvas initialized with dimensions:', aerialCanvas.width, 'x', aerialCanvas.height);
        }
        
        // Initialize street canvas
        const streetCanvas = document.getElementById('streetLightTransitionCanvas');
        if (streetCanvas) {
            streetCanvas.width = streetCanvas.offsetWidth;
            streetCanvas.height = streetCanvas.offsetHeight;
            console.log('ğŸ¨ Street canvas initialized with dimensions:', streetCanvas.width, 'x', streetCanvas.height);
        }
        
    } catch (error) {
        console.error('Error initializing separate slider canvases:', error);
    }
}
    
    function switchToMeasurementMode() {
        try {
            // Hide scale canvas and show measurement canvas
            if (scaleCanvas) {
                scaleCanvas.style.display = 'none';
            }
            if (measurementCanvas) {
                measurementCanvas.style.display = 'block';
                // Ensure measurement canvas is positioned correctly and doesn't cover controls
                measurementCanvas.style.zIndex = '5';
            }
            
            // Show measurement controls
            const measurementControls = document.getElementById('measurementControls');
            if (measurementControls) {
                measurementControls.style.display = 'block';
                measurementControls.style.position = 'relative';
                measurementControls.style.zIndex = '10';
            }
            
            // Setup measurement canvas with current mode
            setupMeasurementCanvas();
            
            showStatus('Switched to measurement mode! Use the buttons above to choose drawing style.', 'success');
        } catch (error) {
            console.error('Error switching to measurement mode:', error);
        }
    }
    
    // Redraw all paths on live street view
    function redrawAllPathsOnLiveStreetView() {
        try {
            console.log('ğŸ”„ redrawAllPathsOnLiveStreetView() called');
            
            if (!streetCanvas || !streetCanvas.drawingData) {
                console.log('Live street canvas not found');
                return;
            }
            
            const ctx = streetCanvas.getContext('2d');
            ctx.clearRect(0, 0, streetCanvas.width, streetCanvas.height);
            
            if (streetCanvas.drawingData.paths.length > 0) {
                console.log('ğŸ”„ Redrawing all paths for live street :', streetCanvas.drawingData.paths.length, 'paths');
                
                streetCanvas.drawingData.paths.forEach(path => {
                    if (path.length >= 2) {
                        // Place lights along the path instead of drawing lines
                        for (let i = 0; i < path.length; i++) {
                            const point = path[i];
                            const lightSize = 5;
                            
                            // Draw light
                            ctx.fillStyle = '#FFD700';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, lightSize, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Add subtle glow effect
                            ctx.shadowColor = '#FFD700';
                            ctx.shadowBlur = 6;
                            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                            ctx.beginPath();
                            ctx.arc(point.x, point.y, lightSize + 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                });
                
                showStatus('All paths redrawn on live Street View', 'success');
            } else {
                console.log('No live street paths to redraw');
            }
            
        } catch (error) {
            console.error('Error redrawing live street paths:', error);
        }
    }
    
    // Setup measurement canvas
    function setupMeasurementCanvas() {
        try {
            if (!measurementCanvas || !measurementCtx) {
                console.log('Measurement canvas not available');
                return;
            }
            
            // Clear any existing event listeners
            measurementCanvas.replaceWith(measurementCanvas.cloneNode(true));
            measurementCanvas = document.getElementById('measurementCanvas');
            measurementCtx = measurementCanvas.getContext('2d');
            
            // Add drawing event listeners based on current mode
            if (uploadedImageDrawingMode === 'straight') {
                measurementCanvas.addEventListener('click', handleMeasurementStraightLineClick);
            } else if (uploadedImageDrawingMode === 'freehand') {
                measurementCanvas.addEventListener('mousedown', startMeasurementFreehand);
                measurementCanvas.addEventListener('mousemove', drawMeasurementFreehand);
                measurementCanvas.addEventListener('mouseup', endMeasurementFreehand);
                measurementCanvas.addEventListener('mouseleave', endMeasurementFreehand);
            }
            
            console.log('Measurement canvas setup complete');
            
        } catch (error) {
            console.error('Error setting up measurement canvas:', error);
        }
    }
    
    // Measurement canvas event handlers
    function handleMeasurementStraightLineClick(e) {
        try {
            const rect = measurementCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (!uploadedImageCurrentPath) {
                uploadedImageCurrentPath = [];
            }
            
            uploadedImageCurrentPath.push({ x, y });
            
            // Draw point
            measurementCtx.fillStyle = '#0066cc';
            measurementCtx.beginPath();
            measurementCtx.arc(x, y, 3, 0, Math.PI * 2);
            measurementCtx.fill();
            
            // Draw line if we have at least 2 points
            if (uploadedImageCurrentPath.length >= 2) {
                const points = uploadedImageCurrentPath;
                const lastPoint = points[points.length - 2];
                
                measurementCtx.strokeStyle = '#0066cc';
                measurementCtx.lineWidth = 2;
                measurementCtx.beginPath();
                measurementCtx.moveTo(lastPoint.x, lastPoint.y);
                measurementCtx.lineTo(x, y);
                measurementCtx.stroke();
                
                // Complete the path
                uploadedImagePaths.push([...uploadedImageCurrentPath]);
                uploadedImageCurrentPath = [];
                
                // Update measurements
                updateUploadedImageMeasurements();
                
                showStatus('Measurement line completed!', 'success');
            }
            
        } catch (error) {
            console.error('Error in measurement straight line click:', error);
        }
    }
    
    function startMeasurementFreehand(e) {
        try {
            const rect = measurementCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            isUploadedImageDrawing = true;
            uploadedImageCurrentPath = [{ x, y }];
            
            measurementCtx.beginPath();
            measurementCtx.moveTo(x, y);
            
        } catch (error) {
            console.error('Error starting measurement freehand:', error);
        }
    }
    
    function drawMeasurementFreehand(e) {
        try {
            if (!isUploadedImageDrawing) return;
            
            const rect = measurementCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            measurementCtx.lineTo(x, y);
            measurementCtx.strokeStyle = '#0066cc';
            measurementCtx.lineWidth = 2;
            measurementCtx.stroke();
            
            uploadedImageCurrentPath.push({ x, y });
            
        } catch (error) {
            console.error('Error drawing measurement freehand:', error);
        }
    }
    
    function endMeasurementFreehand(e) {
        try {
            if (!isUploadedImageDrawing) return;
            
            isUploadedImageDrawing = false;
            
            if (uploadedImageCurrentPath.length > 1) {
                uploadedImagePaths.push([...uploadedImageCurrentPath]);
                
                // Update measurements
                updateUploadedImageMeasurements();
                
                showStatus('Measurement drawing completed!', 'success');
            }
            
            uploadedImageCurrentPath = [];
            
        } catch (error) {
            console.error('Error ending measurement freehand:', error);
        }
    }
    
    // Scale canvas event handlers
    function startScaleDrawing(e) {
        try {
            const rect = scaleCanvas.getBoundingClientRect();
            
            // Adjust for canvas scaling and positioning
            const scaleX = scaleCanvas.width / rect.width;
            const scaleY = scaleCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            scaleDrawingData.isDrawing = true;
            scaleDrawingData.startPoint = { x, y };
            
            scaleCtx.beginPath();
            scaleCtx.moveTo(x, y);
            
        } catch (error) {
            console.error('Error starting scale drawing:', error);
        }
    }
    
    function continueScaleDrawing(e) {
        try {
            if (!scaleDrawingData.isDrawing) return;
            
            const rect = scaleCanvas.getBoundingClientRect();
            
            // Adjust for canvas scaling and positioning
            const scaleX = scaleCanvas.width / rect.width;
            const scaleY = scaleCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            scaleCtx.lineTo(x, y);
            scaleCtx.strokeStyle = '#0066cc';
            scaleCtx.lineWidth = 3;
            scaleCtx.stroke();
            
        } catch (error) {
            console.error('Error continuing scale drawing:', error);
        }
    }
    
    function endScaleDrawing(e) {
        try {
            if (!scaleDrawingData.isDrawing) return;
            
            const rect = scaleCanvas.getBoundingClientRect();
            
            // Adjust for canvas scaling and positioning
            const scaleX = scaleCanvas.width / rect.width;
            const scaleY = scaleCanvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            scaleDrawingData.endPoint = { x, y };
            scaleDrawingData.isDrawing = false;
            
            // Draw the final line
            scaleCtx.lineTo(x, y);
            scaleCtx.strokeStyle = '#0066cc';
            scaleCtx.lineWidth = 3;
            scaleCtx.stroke();
            
            // Calculate pixel length
            const dx = scaleDrawingData.endPoint.x - scaleDrawingData.startPoint.x;
            const dy = scaleDrawingData.endPoint.y - scaleDrawingData.startPoint.y;
            const pixelLength = Math.sqrt(dx * dx + dy * dy);
            
            console.log('Scale line drawn:', { start: scaleDrawingData.startPoint, end: scaleDrawingData.endPoint, pixelLength });
            
        } catch (error) {
            console.error('Error ending scale drawing:', error);
        }
    }
    
    // Touch event handlers for mobile
    function handleTouchStart(e) {
        try {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startScaleDrawing(mouseEvent);
        } catch (error) {
            console.error('Error handling touch start:', error);
        }
    }
    
    function handleTouchMove(e) {
        try {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            continueScaleDrawing(mouseEvent);
        } catch (error) {
            console.error('Error handling touch move:', error);
        }
    }
    
    function handleTouchEnd(e) {
        try {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            endScaleDrawing(mouseEvent);
        } catch (error) {
            console.error('Error handling touch end:', error);
        }
    }
    
    // Display uploaded image
    function displayUploadedImage() {
        try {
            const previewDiv = document.getElementById('uploadedImagePreview');
            const previewImg = document.getElementById('previewImage');
            
            if (uploadedImageData && previewDiv && previewImg) {
                previewImg.src = uploadedImageData.image.src;
                previewDiv.style.display = 'block';
                
                // Set canvas size to match image
                const scaleCanvas = document.getElementById('scaleCanvas');
                if (scaleCanvas) {
                    scaleCanvas.width = uploadedImageData.width;
                    scaleCanvas.height = uploadedImageData.height;
                    scaleCanvas.style.width = '100%';
                    scaleCanvas.style.height = '100%';
                }
            }
        } catch (error) {
            console.error('Error displaying uploaded image:', error);
        }
    }
    
    // Setup scale canvas
    // SECOND setupScaleCanvas function - for street view
    function setupScaleCanvas() {
        try {
            scaleCanvas = document.getElementById('scaleCanvas');
            if (!scaleCanvas) return;
            
            scaleCtx = scaleCanvas.getContext('2d');
            
            // Set canvas dimensions to match the container
            const container = scaleCanvas.parentElement;
            if (container) {
                scaleCanvas.width = container.offsetWidth;
                scaleCanvas.height = container.offsetHeight;
                console.log('Scale Canvas dimensions set to:', scaleCanvas.width, 'x', scaleCanvas.height);
            }
            
            // Clear any existing event listeners
            scaleCanvas.replaceWith(scaleCanvas.cloneNode(true));
            scaleCanvas = document.getElementById('scaleCanvas');
            scaleCtx = scaleCanvas.getContext('2d');
            
            // Set dimensions for the new canvas
            if (container) {
                scaleCanvas.width = container.offsetWidth;
                scaleCanvas.height = container.offsetHeight;
                console.log('New Scale Canvas dimensions set to:', scaleCanvas.width, 'x', scaleCanvas.height);
            }
            
            // Add drawing event listeners
            scaleCanvas.addEventListener('mousedown', startScaleDrawing);
            scaleCanvas.addEventListener('mousemove', continueScaleDrawing);
            scaleCanvas.addEventListener('mouseup', endScaleDrawing);
            scaleCanvas.addEventListener('mouseleave', endScaleDrawing);
            
            // Touch support for mobile
            scaleCanvas.addEventListener('touchstart', handleTouchStart);
            scaleCanvas.addEventListener('touchmove', handleTouchMove);
            scaleCanvas.addEventListener('touchend', handleTouchEnd);
            
            // Initialize measurement canvas
            measurementCanvas = document.getElementById('measurementCanvas');
            if (measurementCanvas) {
                measurementCtx = measurementCanvas.getContext('2d');
                // Set canvas size to match image
                if (uploadedImageData) {
                    measurementCanvas.width = uploadedImageData.width;
                    measurementCanvas.height = uploadedImageData.height;
                    // Set CSS dimensions to match the display
                    measurementCanvas.style.width = '100%';
                    measurementCanvas.style.height = '100%';
                }
            }
            
            console.log('Scale canvas setup complete - SECOND FUNCTION');
        } catch (error) {
            console.error('Error setting up scale canvas:', error);
        }
    }
    
    // Apply scale from uploaded image
    function applyUploadedImageScale() {
        try {
            const scaleInput = document.getElementById('uploadedImageScale');
            if (!scaleInput) {
                showStatus('Scale input not found', 'error');
                return;
            }
            
            const referenceWidth = parseFloat(scaleInput.value);
            if (isNaN(referenceWidth) || referenceWidth <= 0) {
                showStatus('Please enter a valid reference width', 'error');
                return;
            }
            
            // Calculate scale factor based on reference width
            if (scaleDrawingData.startPoint && scaleDrawingData.endPoint) {
                const dx = scaleDrawingData.endPoint.x - scaleDrawingData.startPoint.x;
                const dy = scaleDrawingData.endPoint.y - scaleDrawingData.startPoint.y;
                const pixelLength = Math.sqrt(dx * dx + dy * dy);
                
                streetScaleFactor = referenceWidth / pixelLength;
                
                showStatus(`Scale applied: ${referenceWidth} ft = ${pixelLength.toFixed(1)} pixels (${streetScaleFactor.toFixed(4)} ft/pixel)`, 'success');
                
                // Switch to measurement mode
                switchToMeasurementMode();
                
            } else {
                showStatus('Please draw a reference line first', 'warning');
            }
            
        } catch (error) {
            console.error('Error applying uploaded image scale:', error);
            showStatus('Error applying scale: ' + error.message, 'error');
        }
    }
    
    // Clear uploaded image
    function clearUploadedImage() {
        try {
            // Clear image data
            uploadedImageData = null;
            
            // Clear paths
            uploadedImagePaths = [];
            uploadedImageCurrentPath = [];
            isUploadedImageDrawing = false;
            
            // Clear canvases
            if (scaleCanvas && scaleCtx) {
                scaleCtx.clearRect(0, 0, scaleCanvas.width, scaleCanvas.height);
            }
            if (measurementCanvas && measurementCtx) {
                measurementCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
            }
            
            // Hide preview
            const previewDiv = document.getElementById('uploadedImagePreview');
            if (previewDiv) {
                previewDiv.style.display = 'none';
            }
            
            // Reset measurements
            clearUploadedImageMeasurements();
            
            showStatus('Uploaded image cleared', 'success');
            
        } catch (error) {
            console.error('Error clearing uploaded image:', error);
        }
    }
    
    // Redraw uploaded image paths
    function redrawUploadedImagePaths() {
        try {
            if (!measurementCanvas || !measurementCtx) {
                console.log('Measurement canvas not available');
                return;
            }
            
            // Clear canvas
            measurementCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
            
            // Redraw all paths
            uploadedImagePaths.forEach(path => {
                if (path.length >= 2) {
                    measurementCtx.strokeStyle = '#0066cc';
                    measurementCtx.lineWidth = 2;
                    measurementCtx.beginPath();
                    measurementCtx.moveTo(path[0].x, path[0].y);
                    
                    for (let i = 1; i < path.length; i++) {
                        measurementCtx.lineTo(path[i].x, path[i].y);
                    }
                    measurementCtx.stroke();
                }
            });
            
            // Draw measurement labels
            uploadedImagePaths.forEach(path => {
                if (path.length >= 2) {
                    const startPoint = path[0];
                    const endPoint = path[path.length - 1];
                    
                    // Calculate length in feet
                    let totalLength = 0;
                    for (let i = 1; i < path.length; i++) {
                        const dx = path[i].x - path[i-1].x;
                        const dy = path[i].y - path[i-1].y;
                        const segmentLength = Math.sqrt(dx * dx + dy * dy);
                        totalLength += segmentLength * streetScaleFactor;
                    }
                    
                    // Draw length label
                    measurementCtx.fillStyle = '#000';
                    measurementCtx.font = '12px Arial';
                    measurementCtx.textAlign = 'center';
                    const sideLabel = path.side ? ` (${path.side})` : '';
                    measurementCtx.fillText(`${totalLength.toFixed(1)} ft${sideLabel}`, (startPoint.x + endPoint.x) / 2, (startPoint.y + endPoint.y) / 2);
                }
            });
            
        } catch (error) {
            console.error('Error redrawing uploaded image paths:', error);
        }
    }
    
    // Update uploaded image measurements
    function updateUploadedImageMeasurements() {
        try {
            const totalFeet = uploadedImagePaths.reduce((sum, path) => {
                if (path.length >= 2) {
                    let pathLength = 0;
                    for (let i = 1; i < path.length; i++) {
                        const dx = path[i].x - path[i-1].x;
                        const dy = path[i].y - path[i-1].y;
                        const segmentLength = Math.sqrt(dx * dx + dy * dy);
                        pathLength += segmentLength * streetScaleFactor;
                    }
                    return sum + pathLength;
                }
                return sum;
            }, 0);
            
            // Update street measurements with uploaded image measurements
            if (!measurements.street) {
                measurements.street = { front: 0, leftSide: 0, rightSide: 0, back: 0, total: 0, eaves: 0, gables: 0 };
            }
            
            // Get the currently selected side for uploaded image
            const currentSide = getCurrentUploadedImageSide();
            
            // Replace the side measurement (don't add to existing)
            measurements.street[currentSide] = Math.round(totalFeet);
            
            // Recalculate total from all sides
            measurements.street.total = (measurements.street.front || 0) + 
                                      (measurements.street.leftSide || 0) + 
                                      (measurements.street.rightSide || 0) + 
                                      (measurements.street.back || 0);
            
            // Update displays
            updateStreetDisplay();
            updateCombinedMeasurements();
            updateLightVisualization();
            updatePricing();
            
            showStatus(`Updated measurements: ${totalFeet.toFixed(1)} ft total`, 'success');
            
        } catch (error) {
            console.error('Error updating uploaded image measurements:', error);
        }
    }
    
    // Clear uploaded image measurements
    function clearUploadedImageMeasurements() {
        try {
            uploadedImagePaths = [];
            uploadedImageCurrentPath = [];
            isUploadedImageDrawing = false;
            
            if (measurementCtx && measurementCanvas) {
                measurementCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
            }
            
            // Reset street measurements
            if (measurements.street) {
                measurements.street.front = 0;
                measurements.street.leftSide = 0;
                measurements.street.rightSide = 0;
                measurements.street.back = 0;
                measurements.street.total = 0;
                measurements.street.eaves = 0;
                measurements.street.gables = 0;
            }
            
            updateStreetDisplay();
            updateCombinedMeasurements();
            updateLightVisualization();
            updatePricing();
            
            showStatus('Uploaded image measurements cleared', 'success');
            
        } catch (error) {
            console.error('Error clearing uploaded image measurements:', error);
        }
    }
    
    // Side selection functions
    function selectHouseSide(side) {
        currentAerialSide = side;
        
        // Update button states
        document.querySelectorAll('.side-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`side${side.charAt(0).toUpperCase() + side.slice(1)}`).classList.add('active');
        
        // Update label
        document.getElementById('currentSideLabel').textContent = side.charAt(0).toUpperCase() + side.slice(1);
        
        showStatus(`Selected ${side} side for aerial measurements`, 'success');
    }
    
    function selectUploadedImageSide(side) {
        currentUploadedImageSide = side;
        
        // Update button states
        document.querySelectorAll('#measurementControls .side-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`uploadedSide${side.charAt(0).toUpperCase() + side.slice(1)}`).classList.add('active');
        
        // Update label
        document.getElementById('currentUploadedSideLabel').textContent = side.charAt(0).toUpperCase() + side.slice(1);
        
        showStatus(`Selected ${side} side for uploaded image measurements`, 'success');
    }
    
    // Status display function
    function showStatus(message, type = 'info') {
        const statusDiv = document.getElementById('statusMessage');
        if (statusDiv) {
            statusDiv.textContent = message;
            statusDiv.className = `status-message ${type}`;
            statusDiv.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }
    }
    
    // Get light position along a path
    function getLightPositionAlongPath(path, index, totalLights) {
        if (!path || path.length < 2 || totalLights <= 0) {
            return null;
        }
        
        // Calculate position along the path
        const pathLength = path.length;
        const position = (index / (totalLights - 1)) * (pathLength - 1);
        
        // Get the two closest points
        const index1 = Math.floor(position);
        const index2 = Math.min(index1 + 1, pathLength - 1);
        
        // Interpolate between the two points
        const x = path[index1].x + (path[index2].x - path[index1].x) * fraction;
        const y = path[index1].y + (path[index2].y - path[index1].y) * fraction;
        
        return { x, y };
    }
    
    // Apply night mode effect to canvas
    function applyNightModeEffect(ctx, width, height, intensity = 0.5) {
        try {
            // Create a dark overlay
            ctx.fillStyle = `rgba(0, 0, 0, ${intensity})`;
            ctx.fillRect(0, 0, width, height);
            
            // Add some blue tint for night effect
            ctx.fillStyle = `rgba(0, 50, 100, ${intensity * 0.3})`;
            ctx.fillRect(0, 0, width, height);
            
        } catch (error) {
            console.error('Error applying night mode effect:', error);
        }
    }
    
    // Create image from data URL
    function createImageFromDataURL(dataURL) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                // Validate image dimensions
                if (img.width > 0 && img.height > 0) {
                    resolve(img);
                } else {
                    console.error('Invalid image dimensions:', img.width, 'x', img.height);
                    reject(new Error('Invalid image dimensions'));
                }
            };
            img.onerror = () => {
                console.error('Failed to load image from data URL');
                reject(new Error('Failed to load image'));
            };
            img.src = dataURL;
        });
    }
    
    // Draw background image on canvas
    function drawBackgroundImage(ctx, backgroundImage, width, height) {
        if (!backgroundImage || !ctx) {
            console.warn('Missing background image or context');
            return false;
        }
        
        try {
            // Validate image dimensions
            if (backgroundImage.width <= 0 || backgroundImage.height <= 0) {
                console.error('Invalid background image dimensions:', backgroundImage.width, 'x', backgroundImage.height);
                return false;
            }
            
            // Clear canvas first
            ctx.clearRect(0, 0, width, height);
            
            // Draw the background image
            ctx.drawImage(backgroundImage, 0, 0, width, height);
            
            return true;
            
        } catch (error) {
            console.error('Error drawing background image:', error);
            return false;
        }
    }
    
    // Draw placeholder background
    function drawPlaceholderBackground(ctx, width, height) {
        if (!ctx) {
            console.warn('Missing context for placeholder background');
            return;
        }
        
        try {
            console.log('Drawing placeholder background with dimensions:', width, height);
            
            // Validate dimensions
            if (width <= 0 || height <= 0) {
                console.warn('Invalid dimensions for placeholder background:', width, 'x', height);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw a subtle grid pattern
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Add text
            ctx.fillStyle = '#999';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Background will appear here after capture', width / 2, height / 2);
            
            console.log('Placeholder background drawn successfully');
            
        } catch (error) {
            console.error('Error drawing placeholder background:', error);
        }
    }
    
    // Update transition background
    function updateTransitionBackground() {
        try {
            console.log('ğŸ”„ Updating transition background for new measurements');
            
            // Capture new background if we have measurements
            if (measurements.aerial.total > 0 || measurements.street.total > 0) {
                captureTransitionBackground();
            }
            
        } catch (error) {
            console.error('Error updating transition background:', error);
        }
    }
    
    // ===== ANIMATED LIGHT DRAWING FUNCTIONS =====
    
    // Draw aerial lights with animation effects
    function drawAerialPlacedLightsWithAnimation(intensity) {
        try {
            const canvas = document.getElementById('aerialCanvas');
            if (!canvas || !window.aerialLights) return;
            
            const ctx = canvas.getContext('2d');
            const lightColor = document.getElementById('aerialLightColor')?.value || '#FFD700';
            const animationMode = document.getElementById('aerialAnimationMode')?.value || 'static';
            
            // Apply animation effects
            let animatedColor = lightColor;
            let animatedSize = 6 * intensity;
            
            switch (animationMode) {
                case 'twinkle':
                    animatedSize = 4 + (4 * intensity);
                    break;
                case 'chase':
                    animatedSize = 5 + (3 * intensity);
                    break;
                case 'fade':
                    animatedSize = 3 + (5 * intensity);
                    break;
                case 'rainbow':
                    const hue = (Date.now() * 0.1) % 360;
                    animatedColor = `hsl(${hue}, 100%, 50%)`;
                    break;
                case 'christmas':
                    animatedColor = intensity > 0.5 ? '#FF0000' : '#00FF00';
                    break;
                case 'patriotic':
                    animatedColor = intensity > 0.5 ? '#FF0000' : '#0000FF';
                    break;
                case 'fireworks':
                    animatedColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    animatedSize = 3 + (Math.random() * 8);
                    break;
            }
            
            // Draw all placed lights with animation
            window.aerialLights.forEach((light, index) => {
                // Draw light circle
                ctx.fillStyle = animatedColor;
                ctx.shadowColor = animatedColor;
                ctx.shadowBlur = 8 * intensity;
                ctx.beginPath();
                ctx.arc(light.x, light.y, animatedSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw light number
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), light.x, light.y + 4);
            });
            
        } catch (error) {
            console.error('Error drawing animated aerial lights:', error);
        }
    }
    
    // Draw street lights with animation effects
    function drawStreetPlacedLightsWithAnimation(intensity) {
        try {
            const canvas = document.getElementById('capturedStreetCanvas');
            if (!canvas || !window.streetLights) return;
            
            const ctx = canvas.getContext('2d');
            const lightColor = document.getElementById('streetLightColor')?.value || '#FFD700';
            const animationMode = document.getElementById('streetAnimationMode')?.value || 'static';
            
            // Apply animation effects
            let animatedColor = lightColor;
            let animatedSize = 6 * intensity;
            
            switch (animationMode) {
                case 'twinkle':
                    animatedSize = 4 + (4 * intensity);
                    break;
                case 'chase':
                    animatedSize = 5 + (3 * intensity);
                    break;
                case 'fade':
                    animatedSize = 3 + (5 * intensity);
                    break;
                case 'rainbow':
                    const hue = (Date.now() * 0.1) % 360;
                    animatedColor = `hsl(${hue}, 100%, 50%)`;
                    break;
                case 'christmas':
                    animatedColor = intensity > 0.5 ? '#FF0000' : '#00FF00';
                    break;
                case 'patriotic':
                    animatedColor = intensity > 0.5 ? '#FF0000' : '#0000FF';
                    break;
                case 'fireworks':
                    animatedColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    animatedSize = 3 + (Math.random() * 8);
                    break;
            }
            
            // Draw all placed lights with animation
            window.streetLights.forEach((light, index) => {
                // Draw light circle
                ctx.fillStyle = animatedColor;
                ctx.shadowColor = animatedColor;
                ctx.shadowBlur = 8 * intensity;
                ctx.beginPath();
                ctx.arc(light.x, light.y, animatedSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw light number
                ctx.fillStyle = '#000';
                ctx.shadowBlur = 0;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText((index + 1).toString(), light.x, light.y + 4);
            });
            
        } catch (error) {
            console.error('Error drawing animated street lights:', error);
        }
    }
    
    // Initialize the page when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        try {
            console.log('ğŸš€ FireflyIQ Roof Measurer initializing...');
            
            // Initialize all systems
            initializeSeparateSliders();
            initializeLightTransitionSlider();
            initializeNightMode();
            
            // Ensure lights are off by default
            clearLightOverlays();
            
            // Initialize new light-based measurement system
            console.log('ğŸ’¡ Initializing light-based measurement system...');
            
            // Ensure global variables are properly initialized
            if (typeof aerialLights === 'undefined') {
                window.aerialLights = [];
                window.streetLights = [];
                window.isAerialLightPlacementActive = false;
                window.isStreetLightPlacementActive = false;
            }
            
            // Initialize light placement mode (always active now)
            window.isAerialLightPlacementActive = true;
            window.isStreetLightPlacementActive = true;
            
            // Initialize bulb sizes (default to 1 inch)
            window.aerialBulbSize = 1.0;
            window.streetBulbSize = 1.0;
            
            // Update bulb size display values
            const aerialBulbSizeValue = document.getElementById('aerialBulbSizeValue');
            const streetBulbSizeValue = document.getElementById('streetBulbSizeValue');
            if (aerialBulbSizeValue) aerialBulbSizeValue.textContent = '1.0"';
            if (streetBulbSizeValue) streetBulbSizeValue.textContent = '1.0"';
            
            // Add click listeners to canvases
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas) {
                aerialCanvas.style.cursor = 'crosshair';
                aerialCanvas.addEventListener('click', handleAerialLightPlacement);
            }
            
            const streetCanvas = document.getElementById('capturedStreetCanvas');
            if (streetCanvas) {
                streetCanvas.style.cursor = 'crosshair';
                streetCanvas.addEventListener('click', handleStreetLightPlacement);
            }
            
            console.log('âœ… Light-based measurement system initialized');
            console.log('âœ… FireflyIQ Roof Measurer initialized successfully');
            
            // Start continuous light animation loop
            startContinuousLightAnimation();
            
        } catch (error) {
            console.error('Error initializing FireflyIQ Roof Measurer:', error);
        }
    });
    
    // ===== CONTINUOUS LIGHT ANIMATION SYSTEM =====
    // This creates a smooth, continuous animation loop for all lights
    
    let continuousAnimationId = null;
    let isContinuousAnimationRunning = false;
    
    function startContinuousLightAnimation() {
        try {
            if (isContinuousAnimationRunning) return;
            
            isContinuousAnimationRunning = true;
            console.log('ğŸ¬ Starting continuous light animation...');
            animateLightsContinuously();
            
        } catch (error) {
            console.error('Error starting continuous animation:', error);
        }
    }
    
    function stopContinuousLightAnimation() {
        try {
            if (continuousAnimationId) {
                cancelAnimationFrame(continuousAnimationId);
                continuousAnimationId = null;
            }
            isContinuousAnimationRunning = false;
            console.log('ğŸ¬ Continuous light animation stopped');
            
        } catch (error) {
            console.error('Error stopping continuous animation:', error);
        }
    }
    
    function animateLightsContinuously() {
        try {
            if (!isContinuousAnimationRunning) return;
            
            // Animate aerial lights
            const aerialCanvas = document.getElementById('aerialCanvas');
            if (aerialCanvas && window.aerialLightPositions && window.aerialLightPositions.length > 0) {
                redrawCanvasWithLights(aerialCanvas, 'aerial');
            }
            
            // Animate street view lights
            const streetCanvas = document.getElementById('capturedStreetCanvas');
            if (streetCanvas && window.capturedStreetLightPositions && window.capturedStreetLightPositions.length > 0) {
                redrawCanvasWithLights(streetCanvas, 'capturedStreet');
            }
            
            // Animate live street view lights
            const liveStreetCanvas = document.getElementById('streetCanvas');
            if (liveStreetCanvas && window.streetLightPositions && window.streetLightPositions.length > 0) {
                redrawCanvasWithLights(liveStreetCanvas, 'street');
            }
            
            // Continue animation loop
            continuousAnimationId = requestAnimationFrame(animateLightsContinuously);
            
        } catch (error) {
            console.error('Error in continuous light animation:', error);
            stopContinuousLightAnimation();
        }
    }
    
</script>

<!-- html2canvas for screen capture -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<!-- Google Maps API -->
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB1KpT96Ce5EzrS_18k6iljxhqfEhSUgAs&libraries=geometry&callback=initMap"></script>

